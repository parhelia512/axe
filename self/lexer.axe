// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
//
// Handles the lexical analysis and tokenization process.

use std.string;
use std.lists;

enum TokenType {
    MAIN,
    PRINTLN,
    PRINT,
    LOOP,
    BREAK,
    STR,
    CHAR,
    SEMICOLON,
    LBRACE,
    RBRACE,
    DEF,
    IDENTIFIER,
    RETURN,
    WHITESPACE,
    NEWLINE,
    LPAREN,
    RPAREN,
    LBRACKET,
    RBRACKET,
    COMMA,
    DOT,
    COLON,
    OPERATOR,
    IF,
    VAL,
    MUT,
    PLUS,
    MINUS,
    STAR,
    SLASH,
    PERCENT,
    CARET,
    AMPERSAND,
    PIPE,
    TILDE,
    RAW,
    COMMENT,
    USE,
    MODEL,
    NEW,
    EQUALS,
    SWITCH,
    CASE,
    DEFAULT,
    INCREMENT,
    DECREMENT,
    ELSE,
    ELIF,
    FOR,
    CONTINUE,
    IN,
    EXTERNAL,
    REF,
    ENUM,
    AND,
    OR,
    XOR,
    MOD,
    MACRO,
    OVERLOAD,
    TEST,
    ASSERT,
    PLATFORM,
    PARALLEL,
    SINGLE,
    WINDOWS,
    POSIX,
    TO,
    REDUCE,
    INTERPOLATED_STR,
    OPAQUE,
    EXTERN,
    UNSAFE,
    STAR_DOT,
    PUB
}

pub model Token {
    pub type: TokenType;
    pub value: string;
}

def is_alpha(ch: char): bool {
    return (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z');
}

def is_digit(ch: char): bool {
    return ch >= '0' and ch <= '9';
}

def is_alphanum(ch: char): bool {
    return is_alpha(ch) or is_digit(ch) or ch == '_';
}

pub def lex(source: string): ref Token[] {
    mut tokens: Token[];
    mut pos: i32 = 0;
    val src_len: i32 = source.len;

    loop {
        if !(pos < src_len) {
            break;
        }
        val ch: char = source[pos];

        if ch == '*' {
            if pos + 1 < src_len and source[pos + 1] == '.' {
                mut tok: Token;
                tok.type = TokenType.STAR_DOT;
                tok.value = "*.";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } elif tokens.len > 0 and tokens[tokens.len - 1].type == TokenType.IDENTIFIER {
                tokens[tokens.len - 1].value = string_concat(tokens[tokens.len - 1].value, "*");
                pos = pos + 1;
            } else {
                mut tok: Token;
                tok.type = TokenType.STAR;
                tok.value = "*";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == ' ' or ch == '\t' or ch == '\r' {
            mut tok: Token;
            tok.type = TokenType.WHITESPACE;
            tok.value = substring(source, pos, pos + 1);
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '\n' {
            mut tok: Token;
            tok.type = TokenType.NEWLINE;
            tok.value = "\\n";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '{' {
            mut tok: Token;
            tok.type = TokenType.LBRACE;
            tok.value = "{";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '}' {
            mut tok: Token;
            tok.type = TokenType.RBRACE;
            tok.value = "}";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == ';' {
            mut tok: Token;
            tok.type = TokenType.SEMICOLON;
            tok.value = ";";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == ':' {
            mut tok: Token;
            tok.type = TokenType.COLON;
            tok.value = ":";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '!' {
            if pos + 1 < src_len and source[pos + 1] == '=' {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "!=";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } else {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "!";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == '=' {
            if pos + 1 < src_len and source[pos + 1] == '=' {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "==";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } elif pos + 1 < src_len and source[pos + 1] == '>' {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "=>";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } else {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "=";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == '-' {
            if pos + 1 < src_len and source[pos + 1] == '-' {
                mut tok: Token;
                tok.type = TokenType.DECREMENT;
                tok.value = "--";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } else {
                mut tok: Token;
                tok.type = TokenType.MINUS;
                tok.value = "-";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == '+' {
            if pos + 1 < src_len and source[pos + 1] == '+' {
                mut tok: Token;
                tok.type = TokenType.INCREMENT;
                tok.value = "++";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } else {
                mut tok: Token;
                tok.type = TokenType.PLUS;
                tok.value = "+";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == '>' {
            if pos + 1 < src_len and source[pos + 1] == '=' {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = ">=";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } elif pos + 1 < src_len and source[pos + 1] == '>' {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = ">>";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } else {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = ">";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == '<' {
            if pos + 1 < src_len and source[pos + 1] == '=' {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "<=";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } elif pos + 1 < src_len and source[pos + 1] == '<' {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "<<";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } else {
                mut tok: Token;
                tok.type = TokenType.OPERATOR;
                tok.value = "<";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == '/' {
            if pos + 1 < src_len and source[pos + 1] == '/' {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and source[pos] != '\n') {
                        break;
                    }
                    pos = pos + 1;
                }
                mut tok: Token;
                tok.type = TokenType.COMMENT;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            } else {
                mut tok: Token;
                tok.type = TokenType.SLASH;
                tok.value = "/";
                tokens = Token[].append(tokens, tok);
                pos = pos + 1;
            }
        } elif ch == '&' {
            mut tok: Token;
            tok.type = TokenType.OPERATOR;
            tok.value = "&";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '|' {
            mut tok: Token;
            tok.type = TokenType.OPERATOR;
            tok.value = "|";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '^' {
            mut tok: Token;
            tok.type = TokenType.OPERATOR;
            tok.value = "^";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '~' {
            mut tok: Token;
            tok.type = TokenType.OPERATOR;
            tok.value = "~";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '$' {
            if pos + 1 < src_len and source[pos + 1] == '"' {
                pos = pos + 2;
                val str_start: i32 = pos;
                mut ending: i32 = pos;
                loop {
                    if !(ending < src_len) {
                        break;
                    }
                    val end_ch: char = source[ending];
                    if end_ch == '"' and (ending == 0 or source[ending - 1] != '\\') {
                        break;
                    } elif end_ch == '\\' and ending + 1 < src_len {
                        ending = ending + 2;
                    } else {
                        ending = ending + 1;
                    }
                }
                val interp_content: string = substring(source, str_start, ending);
                mut tok: Token;
                tok.type = TokenType.INTERPOLATED_STR;
                tok.value = interp_content;
                tokens = Token[].append(tokens, tok);
                pos = ending + 1;
            }
        } elif ch == '"' {
            mut ending: i32 = pos + 1;
            loop {
                if !(ending < src_len) {
                    break;
                }
                val end_ch: char = source[ending];
                if end_ch == '"' {
                    break;
                } elif end_ch == '\\' and ending + 1 < src_len {
                    ending = ending + 2;
                } else {
                    ending = ending + 1;
                }
            }
            mut tok: Token;
            tok.type = TokenType.STR;
            tok.value = substring(source, pos + 1, ending);
            tokens = Token[].append(tokens, tok);
            pos = ending + 1;
        } elif substring(source, pos, pos + 1) == "'" {
            mut cend: i32 = pos + 1;
            loop {
                if !(cend < src_len and substring(source, cend, cend + 1) != "'") {
                    break;
                }
                cend = cend + 1;
            }
            mut tok: Token;
            tok.type = TokenType.CHAR;
            tok.value = substring(source, pos + 1, cend);
            tokens = Token[].append(tokens, tok);
            pos = cend + 1;
        } elif ch == '(' {
            mut tok: Token;
            tok.type = TokenType.LPAREN;
            tok.value = "(";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == ')' {
            mut tok: Token;
            tok.type = TokenType.RPAREN;
            tok.value = ")";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == ',' {
            mut tok: Token;
            tok.type = TokenType.COMMA;
            tok.value = ",";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '[' {
            mut tok: Token;
            tok.type = TokenType.LBRACKET;
            tok.value = "[";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == ']' {
            mut tok: Token;
            tok.type = TokenType.RBRACKET;
            tok.value = "]";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == '.' {
            mut tok: Token;
            tok.type = TokenType.DOT;
            tok.value = ".";
            tokens = Token[].append(tokens, tok);
            pos = pos + 1;
        } elif ch == 'a' {
            if pos + 6 <= src_len and substring(source, pos, pos + 6) == "assert" and 
               (pos + 6 >= src_len or !is_alphanum(source[pos + 6])) {
                mut tok: Token;
                tok.type = TokenType.ASSERT;
                tok.value = "assert";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "and" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.AND;
                tok.value = "and";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } else {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and is_alphanum(source[pos])) {
                        break;
                    }
                    pos = pos + 1;
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            }
        } elif ch == 'b' {
            if pos + 5 <= src_len and substring(source, pos, pos + 5) == "break" {
                mut tok: Token;
                tok.type = TokenType.BREAK;
                tok.value = "break";
                tokens = Token[].append(tokens, tok);
                pos = pos + 5;
            } else {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and is_alphanum(source[pos])) {
                        break;
                    }
                    pos = pos + 1;
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            }
        } elif ch == 'd' {
            if pos + 7 <= src_len and substring(source, pos, pos + 7) == "default" and
               (pos + 7 >= src_len or !is_alphanum(source[pos + 7])) {
                mut tok: Token;
                tok.type = TokenType.DEFAULT;
                tok.value = "default";
                tokens = Token[].append(tokens, tok);
                pos = pos + 7;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "def" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.DEF;
                tok.value = "def";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } else {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and is_alphanum(source[pos])) {
                        break;
                    }
                    pos = pos + 1;
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            }
        } elif ch == 't' {
            if pos + 4 <= src_len and substring(source, pos, pos + 4) == "test" and
               (pos + 4 >= src_len or !is_alphanum(source[pos + 4])) {
                mut tok: Token;
                tok.type = TokenType.TEST;
                tok.value = "test";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 2 <= src_len and substring(source, pos, pos + 2) == "to" and
                  (pos + 2 >= src_len or !is_alphanum(source[pos + 2])) {
                mut tok: Token;
                tok.type = TokenType.TO;
                tok.value = "to";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } else {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and is_alphanum(source[pos])) {
                        break;
                    }
                    pos = pos + 1;
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            }
        } elif ch == 'v' {
            if pos + 3 <= src_len and substring(source, pos, pos + 3) == "val" and
               (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.VAL;
                tok.value = "val";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } else {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and is_alphanum(source[pos])) {
                        break;
                    }
                    pos = pos + 1;
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            }
        } elif ch == 'm' {
            if pos + 5 <= src_len and substring(source, pos, pos + 5) == "macro" and
               (pos + 5 >= src_len or !is_alphanum(source[pos + 5])) {
                mut tok: Token;
                tok.type = TokenType.MACRO;
                tok.value = "macro";
                tokens = Token[].append(tokens, tok);
                pos = pos + 5;
            } elif pos + 5 <= src_len and substring(source, pos, pos + 5) == "model" and
                  (pos + 5 >= src_len or !is_alphanum(source[pos + 5])) {
                mut tok: Token;
                tok.type = TokenType.MODEL;
                tok.value = "model";
                tokens = Token[].append(tokens, tok);
                pos = pos + 5;
            } elif pos + 4 <= src_len and substring(source, pos, pos + 4) == "main" and
                  (pos + 4 >= src_len or !is_alphanum(source[pos + 4])) {
                mut tok: Token;
                tok.type = TokenType.MAIN;
                tok.value = "main";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "mut" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.MUT;
                tok.value = "mut";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "mod" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.MOD;
                tok.value = "mod";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } else {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and is_alphanum(source[pos])) {
                        break;
                    }
                    pos = pos + 1;
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            }
        } else {
            if pos + 4 <= src_len and substring(source, pos, pos + 4) == "main" {
                mut tok: Token;
                tok.type = TokenType.MAIN;
                tok.value = "main";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "pub" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.PUB;
                tok.value = "pub";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "put" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.PRINT;
                tok.value = "put";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 8 <= src_len and substring(source, pos, pos + 8) == "platform" and
                  (pos + 8 >= src_len or !is_alphanum(source[pos + 8])) {
                mut tok: Token;
                tok.type = TokenType.PLATFORM;
                tok.value = "platform";
                tokens = Token[].append(tokens, tok);
                pos = pos + 8;
            } elif pos + 6 <= src_len and substring(source, pos, pos + 6) == "opaque" and
                  (pos + 6 >= src_len or !is_alphanum(source[pos + 6])) {
                mut tok: Token;
                tok.type = TokenType.OPAQUE;
                tok.value = "opaque";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 6 <= src_len and substring(source, pos, pos + 6) == "extern" and
                  (pos + 6 >= src_len or !is_alphanum(source[pos + 6])) {
                mut tok: Token;
                tok.type = TokenType.EXTERN;
                tok.value = "extern";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 6 <= src_len and substring(source, pos, pos + 6) == "unsafe" and
                  (pos + 6 >= src_len or !is_alphanum(source[pos + 6])) {
                mut tok: Token;
                tok.type = TokenType.UNSAFE;
                tok.value = "unsafe";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 8 <= src_len and substring(source, pos, pos + 8) == "parallel" and
                  (pos + 8 >= src_len or !is_alphanum(source[pos + 8])) {
                mut tok: Token;
                tok.type = TokenType.PARALLEL;
                tok.value = "parallel";
                tokens = Token[].append(tokens, tok);
                pos = pos + 8;
            } elif pos + 6 <= src_len and substring(source, pos, pos + 6) == "single" and
                  (pos + 6 >= src_len or !is_alphanum(source[pos + 6])) {
                mut tok: Token;
                tok.type = TokenType.SINGLE;
                tok.value = "single";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 5 <= src_len and substring(source, pos, pos + 5) == "posix" and
                  (pos + 5 >= src_len or !is_alphanum(source[pos + 5])) {
                mut tok: Token;
                tok.type = TokenType.POSIX;
                tok.value = "posix";
                tokens = Token[].append(tokens, tok);
                pos = pos + 5;
            } elif pos + 4 <= src_len and substring(source, pos, pos + 4) == "loop" {
                mut tok: Token;
                tok.type = TokenType.LOOP;
                tok.value = "loop";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "for" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.FOR;
                tok.value = "for";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 8 <= src_len and substring(source, pos, pos + 8) == "continue" {
                mut tok: Token;
                tok.type = TokenType.CONTINUE;
                tok.value = "continue";
                tokens = Token[].append(tokens, tok);
                pos = pos + 8;
            } elif pos + 5 <= src_len and substring(source, pos, pos + 5) == "break" {
                mut tok: Token;
                tok.type = TokenType.BREAK;
                tok.value = "break";
                tokens = Token[].append(tokens, tok);
                pos = pos + 5;
            } elif pos + 5 <= src_len and substring(source, pos, pos + 5) == "model" {
                mut tok: Token;
                tok.type = TokenType.MODEL;
                tok.value = "model";
                tokens = Token[].append(tokens, tok);
                pos = pos + 5;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "new" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.NEW;
                tok.value = "new";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 4 <= src_len and substring(source, pos, pos + 4) == "elif" {
                mut tok: Token;
                tok.type = TokenType.ELIF;
                tok.value = "elif";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 4 <= src_len and substring(source, pos, pos + 4) == "else" {
                mut tok: Token;
                tok.type = TokenType.ELSE;
                tok.value = "else";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 6 <= src_len and substring(source, pos, pos + 6) == "reduce" and
                  (pos + 6 >= src_len or !is_alphanum(source[pos + 6])) {
                mut tok: Token;
                tok.type = TokenType.REDUCE;
                tok.value = "reduce";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 2 <= src_len and substring(source, pos, pos + 2) == "in" and
                  (pos + 2 >= src_len or !is_alphanum(source[pos + 2])) {
                mut tok: Token;
                tok.type = TokenType.IN;
                tok.value = "in";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } elif pos + 2 <= src_len and substring(source, pos, pos + 2) == "if" and
                  (pos + 2 >= src_len or !is_alphanum(source[pos + 2])) {
                mut tok: Token;
                tok.type = TokenType.IF;
                tok.value = "if";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } elif pos + 6 <= src_len and substring(source, pos, pos + 6) == "return" {
                mut tok: Token;
                tok.type = TokenType.RETURN;
                tok.value = "return";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "ref" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.REF;
                tok.value = "ref";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "raw" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.RAW;
                tok.value = "raw";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;

                loop {
                    if !pos < src_len and (source[pos] == ' ' or source[pos] == '\t' or
                      source[pos] == '\n' or source[pos] == '\r') {
                        break;
                    }
                    if source[pos] == '\n' {
                        mut ntok: Token;
                        ntok.type = TokenType.NEWLINE;
                        ntok.value = "\\n";
                        tokens = Token[].append(tokens, ntok);
                    } elif source[pos] == ' ' or source[pos] == '\t' {
                        mut wtok: Token;
                        wtok.type = TokenType.WHITESPACE;
                        wtok.value = substring(source, pos, pos + 1);
                        tokens = Token[].append(tokens, wtok);
                    }
                    pos = pos + 1;
                }

                if pos < src_len and source[pos] == '{' {
                    mut btok: Token;
                    btok.type = TokenType.LBRACE;
                    btok.value = "{";
                    tokens = Token[].append(tokens, btok);
                    pos = pos + 1;

                    mut brace_depth: i32 = 1;
                    val content_start: i32 = pos;
                    loop {
                        if !(pos < src_len and brace_depth > 0) {
                            break;
                        }
                        if source[pos] == '{' {
                            brace_depth = brace_depth + 1;
                        } elif source[pos] == '}' {
                            brace_depth = brace_depth - 1;
                            if brace_depth == 0 {
                                break;
                            }
                        }
                        pos = pos + 1;
                    }

                    if pos > content_start {
                        val raw_content: string = substring(source, content_start, pos);
                        mut ctok: Token;
                        ctok.type = TokenType.IDENTIFIER;
                        ctok.value = raw_content;
                        tokens = Token[].append(tokens, ctok);
                    }

                    if pos < src_len and source[pos] == '}' {
                        mut rbtok: Token;
                        rbtok.type = TokenType.RBRACE;
                        rbtok.value = "}";
                        tokens = Token[].append(tokens, rbtok);
                        pos = pos + 1;
                    }
                }
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "use" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.USE;
                tok.value = "use";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 8 <= src_len and substring(source, pos, pos + 8) == "overload" and
                  (pos + 8 >= src_len or !is_alphanum(source[pos + 8])) {
                mut tok: Token;
                tok.type = TokenType.OVERLOAD;
                tok.value = "overload";
                tokens = Token[].append(tokens, tok);
                pos = pos + 8;
            } elif pos + 8 <= src_len and substring(source, pos, pos + 8) == "external" and
                  (pos + 8 >= src_len or !is_alphanum(source[pos + 8])) {
                mut tok: Token;
                tok.type = TokenType.EXTERNAL;
                tok.value = "external";
                tokens = Token[].append(tokens, tok);
                pos = pos + 8;
            } elif pos + 7 <= src_len and substring(source, pos, pos + 7) == "windows" and
                  (pos + 7 >= src_len or !is_alphanum(source[pos + 7])) {
                mut tok: Token;
                tok.type = TokenType.WINDOWS;
                tok.value = "windows";
                tokens = Token[].append(tokens, tok);
                pos = pos + 7;
            } elif pos + 6 <= src_len and substring(source, pos, pos + 6) == "switch" and
                  (pos + 6 >= src_len or !is_alphanum(source[pos + 6])) {
                mut tok: Token;
                tok.type = TokenType.SWITCH;
                tok.value = "switch";
                tokens = Token[].append(tokens, tok);
                pos = pos + 6;
            } elif pos + 4 <= src_len and substring(source, pos, pos + 4) == "case" and
                  (pos + 4 >= src_len or !is_alphanum(source[pos + 4])) {
                mut tok: Token;
                tok.type = TokenType.CASE;
                tok.value = "case";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 4 <= src_len and substring(source, pos, pos + 4) == "enum" and
                  (pos + 4 >= src_len or !is_alphanum(source[pos + 4])) {
                mut tok: Token;
                tok.type = TokenType.ENUM;
                tok.value = "enum";
                tokens = Token[].append(tokens, tok);
                pos = pos + 4;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "and" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.AND;
                tok.value = "and";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif pos + 2 <= src_len and substring(source, pos, pos + 2) == "or" and
                  (pos + 2 >= src_len or !is_alphanum(source[pos + 2])) {
                mut tok: Token;
                tok.type = TokenType.OR;
                tok.value = "or";
                tokens = Token[].append(tokens, tok);
                pos = pos + 2;
            } elif pos + 3 <= src_len and substring(source, pos, pos + 3) == "xor" and
                  (pos + 3 >= src_len or !is_alphanum(source[pos + 3])) {
                mut tok: Token;
                tok.type = TokenType.XOR;
                tok.value = "xor";
                tokens = Token[].append(tokens, tok);
                pos = pos + 3;
            } elif source[pos] == '0' and pos + 1 < src_len and
                  (source[pos + 1] == 'x' or source[pos + 1] == 'X') {
                val start: i32 = pos;
                pos = pos + 2;
                loop {
                    if !(pos < src_len) { 
                        break;
                    }
                    val hex_ch: char = source[pos];
                    if (hex_ch >= '0' and hex_ch <= '9') or
                       (hex_ch >= 'a' and hex_ch <= 'f') or
                       (hex_ch >= 'A' and hex_ch <= 'F') {
                        pos = pos + 1;
                    } else {
                        break;
                    }
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            } elif is_alphanum(ch) or ch == '_' {
                val start: i32 = pos;
                loop {
                    if !(pos < src_len and is_alphanum(source[pos])) {
                        break;
                    }
                    pos++;
                }
                mut tok: Token;
                tok.type = TokenType.IDENTIFIER;
                tok.value = substring(source, start, pos);
                tokens = Token[].append(tokens, tok);
            } else {
                pos = pos + 1;
            }
        }
    }

    mut filtered: Token[];
    mut i: i32 = 0;
    loop {
        if !(i < tokens.len) {
            break;
        }
        val tok: Token = tokens[i];
        if tok.type != TokenType.WHITESPACE and 
           tok.type != TokenType.NEWLINE and 
           tok.type != TokenType.COMMENT {
            filtered = Token[].append(filtered, tok);
        }
        i = i + 1;
    }

    return filtered;
}
