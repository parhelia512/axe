use structs (
    ASTNode
);

use lexer (
    Token, 
    lex
);

use parser (
    parse
);

use std.io;
use std.string;
use std.lists;
use std.maps;
use std.os;

mut g_processed_modules: StringBoolMap;

pub def reset_processed_modules() {
    mut arena: Arena = Arena.create(1024 * 16);
    g_processed_modules = deref(StringBoolMap.create(addr_of(arena), 128));
}

pub def has_imported_module(name: string): bool {
    if StringBoolMap.contains(addr_of(g_processed_modules), name) {
        return true;
    }
    return false;
}

def add_processed_module(path: string) {
    mut arena: Arena = Arena.create(1024);
    StringBoolMap.set(addr_of(g_processed_modules), addr_of(arena), path, true);
}

def is_module_processed(path: string): bool {
    return StringBoolMap.contains(addr_of(g_processed_modules), path);
}

def get_module_prefix(module_name: string): string {
    mut result: string = str("");
    mut i: i32 = 0;
    val n: i32 = str_len(module_name);
    loop {
        if i >= n {
            break;
        }
        val ch: char = get_char(module_name, i);
        if ch == '.' {
            result = concat(result, str("__"));
        } elif ch == '-' {
            result = concat(result, str("_"));
        } else {
            mut tmp: string = substring_se(module_name, i, i + 1);
            result = concat(result, tmp);
        }
        i = i + 1;
    }
    return result;
}

def get_dir_from_path(path: string): string {
    val lenp: i32 = str_len(path);
    mut i: i32 = lenp - 1;
    loop {
        if i < 0 {
            return str(".");
        }
        val ch: char = get_char(path, i);
        if ch == '/' or ch == '\\' {
            return substring_se(path, 0, i);
        }
        i = i - 1;
    }
}

def join_path(base_dir: string, rel: string): string {
    if str_len(base_dir) == 0 or equals_c(base_dir, ".") {
        return rel;
    }

    val last: char = get_char(base_dir, str_len(base_dir) - 1);
    if last == '/' or last == '\\' {
        return concat(base_dir, rel);
    }

    return concat(concat(base_dir, str("/")), rel);
}

def make_module_path(base_dir: string, use_module: string): string {
    if has_prefix(use_module, str("std.")) {
        val rest: string = substring_se(use_module, 4, str_len(use_module));
        mut path_rest: string = str("");
        mut i: i32 = 0;
        val n: i32 = str_len(rest);
        loop {
            if i >= n {
                break;
            }
            val ch: char = get_char(rest, i);
            if ch == '.' {
                path_rest = concat(path_rest, str("/"));
            } else {
                mut tmp: string = substring_se(rest, i, i + 1);
                path_rest = concat(path_rest, tmp);
            }
            i = i + 1;
        }

        val rel: string = concat(path_rest, str(".axec"));
        val std_base: string = join_path(base_dir, str("std"));
        val local_path: string = join_path(std_base, rel);
        if file_exists(local_path) {
            return local_path;
        }

        val cwd: string = get_cwd();
        val cwd_parent: string = get_dir_from_path(cwd);
        val proj_std: string = join_path(cwd_parent, str("std"));
        val proj_path: string = join_path(proj_std, rel);
        if file_exists(proj_path) {
            return proj_path;
        }

        val home: string = get_user_home_dir();
        if str_len(home) > 0 {
            val home_axe: string = join_path(home, str(".axe"));
            val home_std: string = join_path(home_axe, str("std"));
            val home_path: string = join_path(home_std, rel);
            if file_exists(home_path) {
                return home_path;
            }
        }

        return local_path;
    }

    if has_prefix(use_module, str("./")) or has_prefix(use_module, str("../")) {
        val rel2: string = concat(use_module, str(".axe"));
        return join_path(base_dir, rel2);
    }

    mut path_mod: string = str("");
    mut j: i32 = 0;
    val mlen: i32 = str_len(use_module);
    loop {
        if j >= mlen {
            break;
        }
        val ch2: char = get_char(use_module, j);
        if ch2 == '.' {
            path_mod = concat(path_mod, str("/"));
        } else {
            mut tmp2: string = substring_se(use_module, j, j + 1);
            path_mod = concat(path_mod, tmp2);
        }
        j = j + 1;
    }

    val rel3: string = concat(path_mod, str(".axe"));
    return join_path(base_dir, rel3);
}

def append_child(program: ref ASTNode, child: ASTNode) {
    if program.children == nil {
        unsafe {
            mut lst: list(ASTNode);
            val sz: usize = C.sizeof(list(ASTNode));
            val heap_lst: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz));
            if heap_lst != nil {
                C.memcpy(heap_lst, addr_of(lst), sz);
                program.children = heap_lst;
            }
        }
    }

    if program.children != nil {
        unsafe {
            mut tmp: list(ASTNode);
            val sz2: usize = C.sizeof(list(ASTNode));
            C.memcpy(addr_of(tmp), program.children, sz2);
            append(tmp, child);
            C.memcpy(program.children, addr_of(tmp), sz2);
        }
    }
}

def prefix_function_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.function.name;
    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.function.name = pref;
}

def prefix_model_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.model_node.name;
    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.model_node.name = pref;
}

def prefix_enum_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.enum_node.name;
    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.enum_node.name = pref;
}

def merge_imported_module(program: ref ASTNode, imported: ref ASTNode, use_module: string) {
    val module_prefix: string = get_module_prefix(use_module);

    if imported.children == nil {
        return;
    }

    val children: ref list(ASTNode) = imported.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }

        mut child: ASTNode = children.data[i];

        if equals_c(child.node_type, "Use") {
            i = i + 1;
            continue;
        }

        if equals_c(child.node_type, "Function") {
            prefix_function_node(addr_of(child), module_prefix);
        } elif equals_c(child.node_type, "Model") {
            prefix_model_node(addr_of(child), module_prefix);
        } elif equals_c(child.node_type, "Enum") {
            prefix_enum_node(addr_of(child), module_prefix);
        }

        append_child(program, child);
        i = i + 1;
    }
}

pub def process_imports(ast: ref ASTNode, base_dir: string, is_axec: bool, current_file: string, is_top_level: bool, module_name: string): ASTNode {
    if !equals_c(ast.node_type, "Program") {
        return *ast;
    }

    if str_len(current_file) > 0 {
        if is_module_processed(current_file) {
            return *ast;
        }
        add_processed_module(current_file);
    }

    mut effective_base: string = base_dir;
    if str_len(effective_base) == 0 {
        if str_len(current_file) > 0 {
            effective_base = get_dir_from_path(current_file);
        } else {
            effective_base = str(".");
        }
    }

    if ast.children == nil {
        return *ast;
    }

    val program_children: ref list(ASTNode) = ast.children;
    mut idx: i32 = 0;
    loop {
        if idx >= len(deref(program_children)) {
            break;
        }

        mut child: ASTNode = program_children.data[idx];

        if equals_c(child.node_type, "Use") {
            val use_mod: string = child.data.use_node.module_name;
            val module_path: string = make_module_path(effective_base, use_mod);
            val src: string = read_file(module_path);
            if str_len(src) == 0 {
                idx = idx + 1;
                continue;
            }

            val toks: list(Token) = lex(src);
            mut import_is_axec: bool = false;
            if str_len(module_path) >= 5 {
                val ext: string = substring_se(module_path, str_len(module_path) - 5, str_len(module_path));
                if equals_c(ext, ".axec") {
                    import_is_axec = true;
                }
            }

            mut import_ast: ASTNode = parse(addr_of(toks), import_is_axec, false, use_mod);

            val import_base: string = get_dir_from_path(module_path);

            import_ast = process_imports(addr_of(import_ast), import_base, import_is_axec, module_path, false, use_mod);

            merge_imported_module(ast, addr_of(import_ast), use_mod);
        }

        idx = idx + 1;
    }

    return *ast;
}
