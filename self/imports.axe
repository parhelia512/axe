use structs (
    ASTNode
);

use lexer (
    Token, 
    lex
);

use parser (
    parse,
    add_child_to_ast
);

use std.io;
use std.string;
use std.lists;
use std.maps;
use std.os;

mut g_processed_modules: StringBoolMap;

/// Global map tracking model short names to their prefixed C names
/// e.g., "string" -> "std__string__string", "Token" -> "lexer__Token"
mut g_import_model_names: StringStringMap;

/// Global arena for model name storage
mut g_model_names_arena: Arena;

pub def reset_processed_modules() {
    mut arena: Arena = Arena.create(1024 * 16);
    g_processed_modules = deref(StringBoolMap.create(addr(arena), 128));
    g_model_names_arena = Arena.create(1024 * 16);
    g_import_model_names = deref(StringStringMap.create(addr(g_model_names_arena), 128));
}

/// Register a model name mapping (short name -> prefixed name)
def register_model_name(short_name: string, prefixed_name: string) {
    StringStringMap.set(addr(g_import_model_names), addr(g_model_names_arena), short_name, prefixed_name);
}

/// Look up a model's prefixed name by its short name
def lookup_model_name(short_name: string): string {
    if StringStringMap.contains(addr(g_import_model_names), short_name) {
        return StringStringMap.get(addr(g_import_model_names), short_name);
    }
    return str("");
}

pub def has_imported_module(name: string): bool {
    if StringBoolMap.contains(addr(g_processed_modules), name) {
        return true;
    }
    return false;
}

def add_processed_module(path: string) {
    mut arena: Arena = Arena.create(1024);
    StringBoolMap.set(addr(g_processed_modules), addr(arena), path, true);
}

def is_module_processed(path: string): bool {
    return StringBoolMap.contains(addr(g_processed_modules), path);
}

def get_module_prefix(module_name: string): string {
    mut result: string = str("");
    mut i: i32 = 0;
    val n: i32 = str_len(module_name);
    loop {
        if i >= n {
            break;
        }
        val ch: char = get_char(module_name, i);
        if ch == '.' {
            result = concat(result, str("__"));
        } elif ch == '-' {
            result = concat(result, str("_"));
        } else {
            mut tmp: string = substring_se(module_name, i, i + 1);
            result = concat(result, tmp);
        }
        i = i + 1;
    }
    return result;
}

def get_dir_from_path(path: string): string {
    val lenp: i32 = str_len(path);
    mut i: i32 = lenp - 1;
    loop {
        if i < 0 {
            return str(".");
        }
        val ch: char = get_char(path, i);
        if ch == '/' or ch == '\\' {
            return substring_se(path, 0, i);
        }
        i = i - 1;
    }
}

def join_path(base_dir: string, rel: string): string {
    if str_len(base_dir) == 0 or equals_c(base_dir, ".") {
        return rel;
    }

    val last: char = get_char(base_dir, str_len(base_dir) - 1);
    if last == '/' or last == '\\' {
        return concat(base_dir, rel);
    }

    return concat(concat(base_dir, str("/")), rel);
}

def make_module_path(base_dir: string, use_module: string): string {
    if has_prefix(use_module, str("std.")) {
        val rest: string = substring_se(use_module, 4, str_len(use_module));
        mut path_rest: string = str("");
        mut i: i32 = 0;
        val n: i32 = str_len(rest);
        loop {
            if i >= n {
                break;
            }
            val ch: char = get_char(rest, i);
            if ch == '.' {
                path_rest = concat(path_rest, str("/"));
            } else {
                mut tmp: string = substring_se(rest, i, i + 1);
                path_rest = concat(path_rest, tmp);
            }
            i++;
        }

        val rel: string = concat(path_rest, str(".axec"));
        val std_base: string = join_path(base_dir, str("std"));
        val local_path: string = join_path(std_base, rel);
        if file_exists(local_path) {
            return local_path;
        }

        val cwd: string = get_cwd();
        val cwd_parent: string = get_dir_from_path(cwd);
        val proj_std: string = join_path(cwd_parent, str("std"));
        val proj_path: string = join_path(proj_std, rel);
        if file_exists(proj_path) {
            return proj_path;
        }

        val home: string = get_user_home_dir();
        if str_len(home) > 0 {
            val home_axe: string = join_path(home, str(".axe"));
            val home_std: string = join_path(home_axe, str("std"));
            val home_path: string = join_path(home_std, rel);
            if file_exists(home_path) {
                return home_path;
            }
        }

        return local_path;
    }

    if has_prefix(use_module, str("./")) or has_prefix(use_module, str("../")) {
        val rel2: string = concat(use_module, str(".axe"));
        return join_path(base_dir, rel2);
    }

    mut path_mod: string = str("");
    mut j: i32 = 0;
    val mlen: i32 = str_len(use_module);
    loop {
        if j >= mlen {
            break;
        }
        val ch2: char = get_char(use_module, j);
        if ch2 == '.' {
            path_mod = concat(path_mod, str("/"));
        } else {
            mut tmp2: string = substring_se(use_module, j, j + 1);
            path_mod = concat(path_mod, tmp2);
        }
        j++;
    }

    val rel3: string = concat(path_mod, str(".axe"));
    return join_path(base_dir, rel3);
}

def append_child(program: ref ASTNode, child: ASTNode) {
    if program.children == nil {
        unsafe {
            mut lst: list(ASTNode);
            val sz: usize = C.sizeof(list(ASTNode));
            val heap_lst: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz));
            if heap_lst != nil {
                C.memcpy(heap_lst, addr(lst), sz);
                program.children = heap_lst;
            }
        }
    }

    if program.children != nil {
        unsafe {
            mut tmp: list(ASTNode);
            val sz2: usize = C.sizeof(list(ASTNode));
            C.memcpy(addr(tmp), program.children, sz2);
            append(tmp, child);
            C.memcpy(program.children, addr(tmp), sz2);
        }
    }
}

def prefix_function_node(node: ref ASTNode, module_prefix: string, exported: ref StringBoolMap) {
    val name: string = node.data.function.name;

    if find_char_from(name, '_', 0) >= 0 {
        val len_name: i32 = str_len(name);
        mut has_double_underscore: bool = false;
        mut first_underscore_idx: i32 = -1;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                first_underscore_idx = i;
                break;
            }
            i++;
        }

        if has_double_underscore {
            val potential_model: string = substring_se(name, 0, first_underscore_idx);
            if !StringBoolMap.contains(exported, potential_model) {
                return;
            }
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.function.name = pref;
}

def prefix_model_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.model_node.name;

    if find_char_from(name, '_', 0) >= 0 {
        val len_name: i32 = str_len(name);
        mut has_double_underscore: bool = false;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return;
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.model_node.name = pref;
}

def prefix_enum_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.enum_node.name;

    if find_char_from(name, '_', 0) >= 0 {
        val len_name: i32 = str_len(name);
        mut has_double_underscore: bool = false;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return;
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.enum_node.name = pref;
}

def build_exported_name_map(imported: ref ASTNode): StringBoolMap {
    mut arena: Arena = Arena.create(1024);
    mut m: StringBoolMap = deref(StringBoolMap.create(addr(arena), 128));
    if imported.children == nil {
        return m;
    }

    val children: ref list(ASTNode) = imported.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }
        val child: ASTNode = children.data[i];
        if equals_c(child.node_type, "Function") {
            StringBoolMap.set(addr(m), addr(arena), child.data.function.name, true);
        } elif equals_c(child.node_type, "Model") {
            StringBoolMap.set(addr(m), addr(arena), child.data.model_node.name, true);
        } elif equals_c(child.node_type, "Enum") {
            StringBoolMap.set(addr(m), addr(arena), child.data.enum_node.name, true);
        }
        i++;
    }

    return m;
}

def prefix_type_name(type_name: string, module_prefix: string, exported: ref StringBoolMap): string {
    if str_len(type_name) == 0 {
        return type_name;
    }

    mut t: string = type_name;

    if has_prefix(t, str("ref ")) {
        val rest: string = strip(substr(t, 4, str_len(t) - 4));
        return concat(str("ref "), prefix_type_name(rest, module_prefix, exported));
    }
    
    if has_prefix(t, str("mut ")) {
        val rest: string = strip(substr(t, 4, str_len(t) - 4));
        return concat(str("mut "), prefix_type_name(rest, module_prefix, exported));
    }

    if has_suffix(t, str("*")) {
        val base: string = strip(substring_se(t, 0, str_len(t) - 1));
        return concat(prefix_type_name(base, module_prefix, exported), str("*"));
    }

    if has_suffix(t, str("[999]")) {
        val base: string = strip(substring_se(t, 0, str_len(t) - 5));
        return concat(prefix_type_name(base, module_prefix, exported), str("[999]"));
    }

    if find_char_from(t, '_', 0) >= 0 {
        val len_t: i32 = str_len(t);
        mut has_double_underscore: bool = false;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_t {
                break;
            }
            val c1: char = get_char(t, i);
            val c2: char = get_char(t, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return t;
        }
    }

    if StringBoolMap.contains(exported, t) {
        if !has_prefix(t, concat(module_prefix, str("__"))) {
            return concat(concat(module_prefix, str("__")), t);
        }
    }

    val known_prefixed: string = lookup_model_name(t);
    if str_len(known_prefixed) > 0 {
        return known_prefixed;
    }

    return type_name;
}

def prefix_types_in_node(node: ref ASTNode, module_prefix: string, exported: ref StringBoolMap) {
    if node == nil {
        return;
    }

    val nt: string = node.node_type;

    if equals_c(nt, "Function") {
        node.data.function.return_type = prefix_type_name(node.data.function.return_type, module_prefix, exported);

        mut params: ref list(string) = node.data.function.params;
        if params != nil {
            mut i: i32 = 0;
            loop {
                if i >= len(deref(params)) {
                    break;
                }
                val p: string = params.data[i];
                val colon_pos: i32 = find_char_from(p, ':', 0);
                if colon_pos >= 0 {
                    val pname: string = strip(substring_se(p, 0, colon_pos));
                    val ptype: string = strip(substr(p, colon_pos + 1, str_len(p) - colon_pos - 1));
                    val new_ptype: string = prefix_type_name(ptype, module_prefix, exported);
                    mut newp: string = concat(pname, str(":"));
                    if str_len(new_ptype) > 0 {
                        newp = concat(concat(newp, str(" ")), new_ptype);
                    }
                    params.data[i] = newp;
                }
                i = i + 1;
            }
        }
    } elif equals_c(nt, "Declaration") {
        node.data.declaration.type_name = prefix_type_name(node.data.declaration.type_name, module_prefix, exported);
    } elif equals_c(nt, "ArrayDecl") {
        node.data.array_decl.element_type = prefix_type_name(node.data.array_decl.element_type, module_prefix, exported);
    } elif equals_c(nt, "ArrayLiteral") {
        node.data.array_literal.element_type = prefix_type_name(node.data.array_literal.element_type, module_prefix, exported);
    } elif equals_c(nt, "Macro") {
        mut ptypes: ref list(string) = node.data.macro_node.param_types;
        if ptypes != nil {
            mut j: i32 = 0;
            loop {
                if j >= len(deref(ptypes)) {
                    break;
                }
                ptypes.data[j] = prefix_type_name(ptypes.data[j], module_prefix, exported);
                j = j + 1;
            }
        }
    } elif equals_c(nt, "For") {
        node.data.for_loop.var_type = prefix_type_name(node.data.for_loop.var_type, module_prefix, exported);
    } elif equals_c(nt, "Model") {
        mut ftypes: ref list(string) = node.data.model_node.field_types;
        if ftypes != nil {
            mut k: i32 = 0;
            loop {
                if k >= len(deref(ftypes)) {
                    break;
                }
                ftypes.data[k] = prefix_type_name(ftypes.data[k], module_prefix, exported);
                k = k + 1;
            }
        }

        mut umtypes: ref list(string) = node.data.model_node.union_member_types;
        if umtypes != nil {
            mut x: i32 = 0;
            loop {
                if x >= len(deref(umtypes)) {
                    break;
                }
                umtypes.data[x] = prefix_type_name(umtypes.data[x], module_prefix, exported);
                x = x + 1;
            }
        }
    } elif equals_c(nt, "Overload") {
        val ovl_name: string = node.data.overload_node.name;
        val ovl_already_prefixed: bool = str_contains_c(ovl_name, "__");
        if !ovl_already_prefixed {
            node.data.overload_node.name = concat(concat(module_prefix, str("__")), ovl_name);
        }
        
        mut type_names_ref: ref list(string) = node.data.overload_node.type_names;
        if type_names_ref != nil {
            mut iov: i32 = 0;
            loop {
                if iov >= len(deref(type_names_ref)) {
                    break;
                }
                type_names_ref.data[iov] = prefix_type_name(type_names_ref.data[iov], module_prefix, exported);
                iov = iov + 1;
            }
        }
        
        mut target_funcs_ref: ref list(string) = node.data.overload_node.target_functions;
        if target_funcs_ref != nil {
            mut itf: i32 = 0;
            loop {
                if itf >= len(deref(target_funcs_ref)) {
                    break;
                }

                val target_name: string = target_funcs_ref.data[itf];
                val already_prefixed: bool = str_contains_c(target_name, "__");
                
                if !already_prefixed {
                    target_funcs_ref.data[itf] = concat(concat(module_prefix, str("__")), target_name);
                }

                itf++;
            }
        }
    } elif equals_c(nt, "Opaque") {
        mut tnames: ref list(string) = node.data.opaque_node.type_names;
        if tnames != nil {
            mut iy: i32 = 0;
            loop {
                if iy >= len(deref(tnames)) {
                    break;
                }
                tnames.data[iy] = prefix_type_name(tnames.data[iy], module_prefix, exported);
                iy = iy + 1;
            }
        }
    } elif equals_c(nt, "Extern") {
        mut eparams: ref list(string) = node.data.extern_node.params;
        if eparams != nil {
            mut ep: i32 = 0;
            loop {
                if ep >= len(deref(eparams)) {
                    break;
                }
                eparams.data[ep] = prefix_type_name(eparams.data[ep], module_prefix, exported);
                ep = ep + 1;
            }
        }

        node.data.extern_node.return_type = prefix_type_name(node.data.extern_node.return_type, module_prefix, exported);
    }

    if node.children != nil {
        mut children: ref list(ASTNode) = node.children;
        mut ii: i32 = 0;
        loop {
            if ii >= len(deref(children)) {
                break;
            }
            prefix_types_in_node(addr(children.data[ii]), module_prefix, exported);
            ii = ii + 1;
        }
    }
}

def merge_imported_module(program: ref ASTNode, imported: ref ASTNode, use_module: string) {
    val module_prefix: string = get_module_prefix(use_module);

    if imported.children == nil {
        return;
    }

    val children: ref list(ASTNode) = imported.children;
    mut exported: StringBoolMap = build_exported_name_map(imported);
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }

        mut child: ASTNode = children.data[i];

        if equals_c(child.node_type, "Use") {
            i++;
            continue;
        }

        if equals_c(child.node_type, "Test") {
            i++;
            continue;
        }

        if equals_c(child.node_type, "Function") {
            if equals_c(child.data.function.name, "main") {
                i++;
                continue;
            }
            prefix_function_node(addr(child), module_prefix, addr(exported));
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Model") {
            val original_name: string = child.data.model_node.name;
            prefix_model_node(addr(child), module_prefix);
            val prefixed_name: string = child.data.model_node.name;
            register_model_name(original_name, prefixed_name);
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Enum") {
            prefix_enum_node(addr(child), module_prefix);
        } elif equals_c(child.node_type, "Overload") {
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        }

        append_child(program, child);
        i++;
    }
}

pub def process_imports(ast: ref ASTNode, base_dir: string, is_axec: bool, current_file: string, is_top_level: bool, module_name: string): ASTNode {
    if !equals_c(ast.node_type, "Program") {
        return *ast;
    }

    if str_len(current_file) > 0 {
        if is_module_processed(current_file) {
            return *ast;
        }
        add_processed_module(current_file);
    }

    mut effective_base: string = base_dir;
    if str_len(effective_base) == 0 {
        if str_len(current_file) > 0 {
            effective_base = get_dir_from_path(current_file);
        } else {
            effective_base = str(".");
        }
    }

    if ast.children == nil {
        return *ast;
    }

    val program_children: ref list(ASTNode) = ast.children;
    mut idx: i32 = 0;
    loop {
        if idx >= len(deref(program_children)) {
            break;
        }

        mut child: ASTNode = program_children.data[idx];

        if equals_c(child.node_type, "Use") {
            val use_mod: string = child.data.use_node.module_name;
            val module_path: string = make_module_path(effective_base, use_mod);
            val src: string = read_file(module_path);
            if str_len(src) == 0 {
                idx = idx + 1;
                continue;
            }

            val toks: list(Token) = lex(src);
            mut import_is_axec: bool = false;
            if str_len(module_path) >= 5 {
                val ext: string = substring_se(module_path, str_len(module_path) - 5, str_len(module_path));
                if equals_c(ext, ".axec") {
                    import_is_axec = true;
                }
            }

            mut import_ast: ASTNode = parse(addr(toks), import_is_axec, false, use_mod);

            val import_base: string = get_dir_from_path(module_path);

            import_ast = process_imports(addr(import_ast), import_base, import_is_axec, module_path, false, use_mod);

            merge_imported_module(ast, addr(import_ast), use_mod);
        }

        idx++;
    }

    return *ast;
}

test {
    mut prog: ASTNode;
    prog.node_type = str("Program");

    mut fn: ASTNode;
    fn.node_type = str("Function");
    fn.data.function.name = str("test_fn");
    fn.data.function.return_type = str("string");

    append_child(addr(prog), fn);

    mut im: ASTNode;
    im.node_type = str("Program");

    mut model_node: ASTNode;
    model_node.node_type = str("Model");
    model_node.data.model_node.name = str("string");
    append_child(addr(im), model_node);

    merge_imported_module(addr(prog), addr(im), str("std.string"));

    val children: ref list(ASTNode) = prog.children;
    assert len(deref(children)) >= 2, "Expected at least 2 children after import merge";
}
