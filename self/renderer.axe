// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
// 
// Handles the rendering process.

use structs     (ASTNode);
use std.lists   (StringList);
use std.string;
use std.io;
use std.maps;

/// Type mappings from Axe to C
mut g_type_mappings: StringStringMap;

/// Track reference depths for variables
mut g_ref_depths: StringIntMap;

/// Track mutability
mut g_is_mutable: StringBoolMap;

/// Function prefixes for imported modules
mut g_function_prefixes: StringStringMap;

/// Model name mappings
mut g_model_names: StringStringMap;

/// Enum names
mut g_enum_names: StringBoolMap;

/// Generated typedefs to avoid duplicates
mut g_generated_typedefs: StringBoolMap;

/// Generated functions to avoid duplicates
mut g_generated_functions: StringBoolMap;

/// Field types for models
mut g_field_types: StringStringMap;

/// Variable types
mut g_var_types: StringStringMap;

/// Track discovered list element types used in generated code (for C list helpers)
mut g_list_element_types: StringBoolMap;

/// Ordered list of discovered element type strings (for deterministic emission)
mut g_list_elements: ref StringList;

/// Initialize renderer globals
pub def initialize_renderer() {
    mut arena: Arena = Arena.create(1024 * 1024 * 100);
    
    g_type_mappings = deref(StringStringMap.create(addr_of(arena), 128));
    g_ref_depths = deref(StringIntMap.create(addr_of(arena), 128));
    g_is_mutable = deref(StringBoolMap.create(addr_of(arena), 128));
    g_function_prefixes = deref(StringStringMap.create(addr_of(arena), 128));
    g_model_names = deref(StringStringMap.create(addr_of(arena), 128));
    g_enum_names = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_typedefs = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_functions = deref(StringBoolMap.create(addr_of(arena), 128));
    g_field_types = deref(StringStringMap.create(addr_of(arena), 128));
    g_var_types = deref(StringStringMap.create(addr_of(arena), 128));
    g_list_element_types = deref(StringBoolMap.create(addr_of(arena), 128));
    g_list_elements = StringList.create(addr_of(arena), 64);
    
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i8"), str("int8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u8"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i16"), str("int16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u16"), str("uint16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i32"), str("int32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u32"), str("uint32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i64"), str("int64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u64"), str("uint64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("isize"), str("intptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("usize"), str("uintptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f32"), str("float"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f64"), str("double"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("bool"), str("bool"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("char"), str("char"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("rchar"), str("char*"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("byte"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("ptrdiff"), str("isize"));
}

def build_function_prefixes(ast: ref ASTNode) {
    StringStringMap.clear(addr_of(g_function_prefixes));

    if ast == nil or ast.children == nil {
        return;
    }

    val children: ref list(ASTNode) = ast.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }
        val child: ref ASTNode = addr_of(children.data[i]);
        if equals_c(child.node_type, "Function") {
            val full_name: string = child.data.function.name;

            mut last_sep: i32 = -1;
            mut j: i32 = 0;
            val n: i32 = str_len(full_name);
            loop {
                if j + 1 >= n {
                    break;
                }
                val c1: char = get_char(full_name, j);
                val c2: char = get_char(full_name, j + 1);
                if c1 == '_' and c2 == '_' {
                    last_sep = j;
                }
                j = j + 1;
            }

            if last_sep >= 0 and last_sep + 2 < n {
                val short_name: string = substring_se(full_name, last_sep + 2, n);

                if str_len(short_name) > 0 {
                    if !StringStringMap.contains(addr_of(g_function_prefixes), short_name) {
                        mut arena: Arena = Arena.create(1256);
                        StringStringMap.set(addr_of(g_function_prefixes), addr_of(arena), short_name, full_name);
                    }
                }
            }
        }

        i++;
    }
}

/// Map Axe type to C type
def map_type(axe_type: string): string {
    if StringStringMap.contains(addr_of(g_type_mappings), axe_type) {
        return StringStringMap.get(addr_of(g_type_mappings), axe_type);
    }
    return axe_type;
}

/// Get canonical model C name from g_model_names
def canonical_model_c_name(name: string): string {
    println "[DBG-MODEL] canonical_model_c_name lookup:";
    println name;

    if StringStringMap.contains(addr_of(g_model_names), name) {
        val mapped: string = StringStringMap.get(addr_of(g_model_names), name);
        println "[DBG-MODEL]   found canonical name:";
        println mapped;
        return mapped;
    }

    println "[DBG-MODEL]   no canonical name found";
    return str("");
}

/// Map Axe type to C type (comprehensive version for model fields)
def map_axe_type_to_c(axe_type: string): string {
    mut result: string = axe_type;
    
    // Handle mut prefix
    if has_prefix(result, str("mut ")) {
        result = strip(substr(result, 4, str_len(result) - 4));
        return map_axe_type_to_c(result);
    }
    
    // Handle list types [999]
    if has_suffix(result, str("[999]")) {
        val element_type: string = strip(substring_se(result, 0, str_len(result) - 5));
        if has_prefix(element_type, str("ref ")) {
            val base_elem: string = strip(substr(element_type, 4, str_len(element_type) - 4));
            val mapped_elem: string = map_axe_type_to_c(base_elem);
            // register list element type for later helper generation
            add_list_element(mapped_elem);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t*"));
            return struct_name;
        } else {
            val mapped_elem: string = map_axe_type_to_c(element_type);
            // register list element type for later helper generation
            add_list_element(mapped_elem);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t"));
            return struct_name;
        }
    }
    
    // Handle ref prefix
    if has_prefix(result, str("ref ")) {
        val base_type: string = strip(substr(result, 4, str_len(result) - 4));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    // Handle pointer suffix
    if has_suffix(result, str("*")) {
        val base_type: string = strip(substring_se(result, 0, str_len(result) - 1));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    val br_idx: i32 = find_char_from(result, '[', 0);
    if br_idx >= 0 and find_char_from(result, ']', br_idx) >= 0 {
        val base_raw: string = strip(substring_se(result, 0, br_idx));
        val suffix: string = substring_se(result, br_idx, str_len(result));
        if str_len(base_raw) > 0 {
            val mapped_base2: string = map_axe_type_to_c(base_raw);
            return concat(mapped_base2, suffix);
        }
    }
    
    // Check type mappings
    if StringStringMap.contains(addr_of(g_type_mappings), result) {
        return StringStringMap.get(addr_of(g_type_mappings), result);
    }
    
    // Check model names
    if StringStringMap.contains(addr_of(g_model_names), result) {
        return StringStringMap.get(addr_of(g_model_names), result);
    }
    
    return result;
}

/// Sanitize a C element type string to be used as part of a generated list type name
def sanitize_list_element_name(c_elem: string): string {
    mut n: string = c_elem;
    mut out: string = str("");
    mut i: i32 = 0;
    loop {
        if i >= str_len(n) {
            break;
        }
        val ch: char = get_char(n, i);
        if ch == '*' {
            out = concat(out, str("_ptr"));
        } elif ch == ' ' {
            out = concat(out, str("_"));
        } else {
            out = concat_chr(out, ch);
        }
        i = i + 1;
    }
    println "[DBG-ENUM] rewrite_enum_member_refs output:";
    println out;
    return out;
}

/// Add a list element type to tracking structures (map + ordered list)
def add_list_element(c_elem: string) {
    if str_len(c_elem) == 0 {
        return;
    }

    if StringBoolMap.contains(addr_of(g_list_element_types), c_elem) {
        return;
    }

    mut arena: Arena = Arena.create(256);
    StringBoolMap.set(addr_of(g_list_element_types), addr_of(arena), c_elem, true);

    if g_list_elements != nil {
        val listref: ref StringList = g_list_elements;
        mut i: i32 = 0;
        loop {
            if i >= listref*.len {
                break;
            }
            val it: string = StringList.get(listref, i);
            if compare(it, c_elem) == 0 {
                return;
            }
            i = i + 1;
        }
        StringList.push(g_list_elements, addr_of(arena), c_elem);
    }
}

/// Recursively scan AST for occurrences of list types (sugar: [999]) and register them
def scan_for_list_types(node: ref ASTNode) {
    if node == nil {
        return;
    }

    if equals_c(node.node_type, "Declaration") {
        val tname: string = node.data.declaration.type_name;
        if str_len(tname) > 0 {
            val br: i32 = find_char_from(tname, '[', 0);
            if br >= 0 {
                val suffix: string = substring_se(tname, br, str_len(tname));
                if equals_c(suffix, "[999]") {
                    mut element: string = strip(substring_se(tname, 0, br));
                    if has_prefix(element, str("ref ")) {
                        element = strip(substr(element, 4, str_len(element) - 4));
                    }
                    val mapped: string = map_axe_type_to_c(element);
                    add_list_element(mapped);
                }
            }
        }
    }

    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut idx: i32 = 0;
        loop {
            if idx >= len(deref(chs)) {
                break;
            }
            scan_for_list_types(addr_of(chs.data[idx]));
            idx = idx + 1;
        }
    }
}

/// Format model field type with proper struct prefix
def format_model_field_type(field_type: string): string {
    mut trimmed: string = strip(field_type);
    mut qualifiers: string = str("");
    
    loop {
        if !has_prefix(trimmed, str("const ")) {
            break;
        }
        qualifiers = concat(qualifiers, str("const "));
        trimmed = strip(substr(trimmed, 6, str_len(trimmed) - 6));
    }
    
    mut had_struct_prefix: bool = false;
    if has_prefix(trimmed, str("struct ")) {
        had_struct_prefix = true;
        trimmed = strip(substr(trimmed, 7, str_len(trimmed) - 7));
    }
    
    mut pointer_suffix: string = str("");
    loop {
        val len: i32 = str_len(trimmed);
        if len == 0 {
            break;
        }
        val last_char: char = get_char(trimmed, len - 1);
        if last_char != '*' {
            break;
        }
        pointer_suffix = concat(pointer_suffix, str("*"));
        trimmed = strip(substring_se(trimmed, 0, len - 1));
    }
    
    val model_name: string = canonical_model_c_name(trimmed);
    if str_len(model_name) > 0 {
        if StringBoolMap.contains(addr_of(g_enum_names), model_name) {
            trimmed = model_name;
        } else {
            trimmed = concat(str("struct "), model_name);
        }
    } else {
        if had_struct_prefix {
            trimmed = concat(str("struct "), trimmed);
        }
    }
    
    mut final_result: string = qualifiers;
    final_result = concat(final_result, trimmed);
    final_result = concat(final_result, pointer_suffix);
    return final_result;
}

/// Process parameter type (handle ref, mut, pointers, etc.)
def process_parameter_type(param_type: string): string {
    // Delegate to the comprehensive Axe->C mapper so that 'mut', repeated
    // 'ref' prefixes, list[999] sugar, and pointer suffixes are handled
    // consistently. Examples:
    //
    //   'char'          -> 'char'
    //   'ref char'      -> 'char*'
    //   'ref ref char'  -> 'char**'
    //   'ref MyModel*'  -> 'struct ...* *'

    mut result: string = strip(param_type);
    return map_axe_type_to_c(result);
}

/// Process an expression string for C interop and pointer sugar
def is_token_char(c: char): bool {
    if (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') {
        return true;
    }
    if c >= '0' and c <= '9' {
        return true;
    }
    if c == '_' or c == '.' {
        return true;
    }
    return false;
}

/// Check if a character can start an identifier (letter or underscore)
def is_ident_start(c: char): bool {
    if (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') {
        return true;
    }
    if c == '_' {
        return true;
    }
    return false;
}

def c_prefix_end_index(s: string): i32 {
    if str_len(s) < 2 {
        return -1;
    }

    if get_char(s, 0) != 'C' {
        return -1;
    }

    mut i: i32 = 1;
    loop {
        if i >= str_len(s) {
            return -1;
        }
        val ch: char = get_char(s, i);
        if ch != ' ' and ch != '\t' and ch != '\n' {
            break;
        }
        i = i + 1;
    }

    if get_char(s, i) != '.' {
        return -1;
    }

    i = i + 1;
    loop {
        if i >= str_len(s) {
            break;
        }
        val ch: char = get_char(s, i);
        if ch != ' ' and ch != '\t' and ch != '\n' {
            break;
        }
        i = i + 1;
    }

    return i;
}

/// Strip any C. prefixes (C, optional spaces, '.', optional spaces) that may
/// appear anywhere in a C expression string, not just at the beginning.
def strip_all_c_prefixes(s: string): string {
    mut cleaned: string = str("");
    mut i: i32 = 0;
    loop {
        if i >= str_len(s) {
            break;
        }

        val ch: char = get_char(s, i);

        if ch == 'C' {
            mut prev_idx: i32 = i - 1;
            mut prev_ch: char = '\0';
            loop {
                if prev_idx < 0 {
                    break;
                }
                val pc: char = get_char(s, prev_idx);
                if pc != ' ' and pc != '\t' and pc != '\n' {
                    prev_ch = pc;
                    break;
                }
                prev_idx = prev_idx - 1;
            }

            if prev_idx < 0 or !is_ident_start(prev_ch) {
                mut k: i32 = i + 1;
                loop {
                    if k >= str_len(s) {
                        break;
                    }
                    val ws: char = get_char(s, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(s) and get_char(s, k) == '.' {
                    k = k + 1;
                    loop {
                        if k >= str_len(s) {
                            break;
                        }
                        val ws2: char = get_char(s, k);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        k = k + 1;
                    }

                    i = k;
                    continue;
                }
            }
        }

        cleaned = concat_chr(cleaned, ch);
        i = i + 1;
    }

    return cleaned;
}

def rewrite_enum_member_refs(s: string): string {
    mut trimmed: string = strip(s);

    println "[DBG-ENUM] rewrite_enum_member_refs input:";
    println trimmed;

    if str_len(trimmed) == 0 {
        return s;
    }

    val dot_pos: i32 = find_char_from(trimmed, '.', 0);
    if dot_pos <= 0 or dot_pos + 1 >= str_len(trimmed) {
        println "[DBG-ENUM]   no dot pattern found";
        return s;
    }

    val left_raw: string = strip(substring_se(trimmed, 0, dot_pos));
    val right_raw: string = strip(substring_se(trimmed, dot_pos + 1, str_len(trimmed)));

    if str_len(left_raw) == 0 or str_len(right_raw) == 0 {
        println "[DBG-ENUM]   empty left/right after split";
        return s;
    }

    println "[DBG-ENUM]   candidate enum/member:";
    println left_raw;
    println right_raw;

    val enum_c_name: string = canonical_model_c_name(left_raw);
    if str_len(enum_c_name) == 0 {
        println "[DBG-ENUM]   canonical lookup failed";
        return s;
    }

    mut repl: string = enum_c_name;
    repl = concat(repl, str("_"));
    repl = concat(repl, right_raw);

    println "[DBG-ENUM]   rewritten to:";
    println repl;

    return repl;
}

def rewrite_function_calls(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i = i + 1;
            continue;
        }

        if !in_string and is_ident_start(ch) {
            mut ident: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                ident = concat_chr(ident, cj);
                j = j + 1;
            }

            mut k: i32 = j;
            loop {
                if k >= str_len(expr) {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }

            mut replaced_ident: string = ident;
            if k < str_len(expr) and get_char(expr, k) == '(' {
                if StringStringMap.contains(addr_of(g_function_prefixes), ident) {
                    replaced_ident = StringStringMap.get(addr_of(g_function_prefixes), ident);
                }
            }

            out = concat(out, replaced_ident);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i = i + 1;
    }

    return out;
}

def process_expression(expr: string): string {
    mut trimmed: string = strip(expr);
    mut has_pointer_sugar: bool = false;
    mut in_string: bool = false;
    mut i: i32 = 0;

    loop {
        if i >= str_len(trimmed) {
            break;
        }
        val ch: char = get_char(trimmed, i);
        if ch == '"' and (i == 0 or get_char(trimmed, i - 1) != '\\') {
            in_string = !in_string;
        } elif !in_string and ch == '*' {
            mut k: i32 = i + 1;
            loop {
                if k >= str_len(trimmed) {
                    break;
                }
                val ws: char = get_char(trimmed, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }
            if k < str_len(trimmed) and get_char(trimmed, k) == '.' {
                has_pointer_sugar = true;
                break;
            }
        }
        i = i + 1;
    }

    mut has_c_prefix: bool = false;
    mut c_prefix_end: i32 = c_prefix_end_index(trimmed);
    if c_prefix_end >= 0 {
        has_c_prefix = true;
    }

    if !has_pointer_sugar and !has_c_prefix {
        println "\n[DBG-EXPR] no-sugar/no-C expr raw:";
        println expr;
        println "[DBG-EXPR] no-sugar/no-C trimmed:";
        println trimmed;
        // Even when there is no pointer sugar or C. prefix, we still need to
        // normalize spurious internal spaces that may have been introduced
        // between pieces of what should be a single token. Examples that have
        // shown up in generated C include:
        //
        //   "0 . 0"         -> "0.0"
        //   "0 . 0000001"   -> "0.0000001"
        //   "reduce _angle" -> "reduce_angle"
        //
        // To fix these without disturbing normal inter-token spacing, run the
        // normalization pass below on the already-trimmed expression.

        mut normalized_only: string = trimmed;

        mut out_norm: string = str("");
        mut jn: i32 = 0;
        loop {
            if jn >= str_len(normalized_only) {
                break;
            }
            val chn: char = get_char(normalized_only, jn);

            if chn == ' ' or chn == '\t' or chn == '\n' {
                mut prev: char = '\0';
                mut next: char = '\0';

                mut kprev: i32 = jn - 1;
                loop {
                    if kprev < 0 {
                        break;
                    }
                    val cprev: char = get_char(normalized_only, kprev);
                    if cprev != ' ' and cprev != '\t' and cprev != '\n' {
                        prev = cprev;
                        break;
                    }
                    kprev = kprev - 1;
                }

                mut knext: i32 = jn + 1;
                mut next_pos: i32 = -1;
                loop {
                    if knext >= str_len(normalized_only) {
                        break;
                    }
                    val cnext: char = get_char(normalized_only, knext);
                    if cnext != ' ' and cnext != '\t' and cnext != '\n' {
                        next = cnext;
                        next_pos = knext;
                        break;
                    }
                    knext = knext + 1;
                }

                if is_token_char(prev) and is_token_char(next) {
                    if next == '_' {
                        // ok.
                    } elif (prev >= '0' and prev <= '9' and next == '.') or
                          (prev == '.' and next >= '0' and next <= '9') {
                        // Merge numeric fragments around the decimal point.
                    } elif (prev == '+' and next == '=') or (prev == '-' and next == '=') {
                        // Merge `+ =` or `- =` into `+=` / `-=` to avoid split operators in generated C.
                    } elif !is_ident_start(next) {
                        // Merge other token fragments such as `0 . 0`.
                    } else {
                        out_norm = concat(out_norm, str(" "));
                    }
                } else {
                    out_norm = concat(out_norm, str(" "));
                }
            } else {
                out_norm = concat_chr(out_norm, chn);
            }

            jn = jn + 1;
        }

        val norm_no_sugar: string = strip(out_norm);
        println "[DBG-EXPR] no-sugar final:";
        println norm_no_sugar;

        val calls_fixed_no_sugar: string = rewrite_function_calls(norm_no_sugar);
        val enum_fixed_no_sugar: string = rewrite_enum_member_refs(calls_fixed_no_sugar);
        return strip(enum_fixed_no_sugar);
    }

    mut result: string = trimmed;
    println "\n[DBG-EXPR] raw expr before sugar/C:";
    println expr;
    println "[DBG-EXPR] trimmed:";
    println trimmed;

    if has_pointer_sugar {
        mut out: string = str("");
        mut in_str2: bool = false;
        mut j: i32 = 0;
        loop {
            if j >= str_len(result) {
                break;
            }
            val ch2: char = get_char(result, j);
            if ch2 == '"' and (j == 0 or get_char(result, j - 1) != '\\') {
                in_str2 = !in_str2;
                out = concat_chr(out, ch2);
            } elif !in_str2 and ch2 == '*' {
                // Support both `s*.field` and `s * . field` forms. When we see
                // a `*` outside of strings, peek ahead past any whitespace; if
                // the next non-space character is `.`, treat this as pointer
                // member sugar and emit `->` instead.
                mut k: i32 = j + 1;
                loop {
                    if k >= str_len(result) {
                        break;
                    }
                    val ws: char = get_char(result, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(result) and get_char(result, k) == '.' {
                    out = concat(out, str("->"));
                    j = k; // skip over the '.'; loop increment will move past it
                } else {
                    out = concat_chr(out, ch2);
                }
            } else {
                out = concat_chr(out, ch2);
            }
            j = j + 1;
        }
        result = out;
    }

    if has_c_prefix {
        result = substring_se(result, c_prefix_end, str_len(result));
    }

    result = strip_all_c_prefixes(result);

    // After pointer-sugar and C. stripping, run the same normalization pass
    // used above to clean up spurious internal spaces within tokens such as
    // "0 . 0" or "reduce _angle" while preserving spaces between tokens.
    mut normalized: string = result;
    println "[DBG-EXPR] after sugar/C before normalize:";
    println normalized;
    mut out_final: string = str("");
    mut jf: i32 = 0;
    loop {
        if jf >= str_len(normalized) {
            break;
        }
        val chf: char = get_char(normalized, jf);

        if chf == ' ' or chf == '\t' or chf == '\n' {
            mut prev2: char = '\0';
            mut next2: char = '\0';

            mut kp: i32 = jf - 1;
            loop {
                if kp < 0 {
                    break;
                }
                val cp: char = get_char(normalized, kp);
                if cp != ' ' and cp != '\t' and cp != '\n' {
                    prev2 = cp;
                    break;
                }
                kp = kp - 1;
            }

            mut kn: i32 = jf + 1;
            mut next_pos2: i32 = -1;
            loop {
                if kn >= str_len(normalized) {
                    break;
                }
                val cn: char = get_char(normalized, kn);
                if cn != ' ' and cn != '\t' and cn != '\n' {
                    next2 = cn;
                    next_pos2 = kn;
                    break;
                }
                kn = kn + 1;
            }

            if is_token_char(prev2) and is_token_char(next2) {
                if next2 == '_' {
                    // Merge space before underscore into the identifier.
                } elif (prev2 >= '0' and prev2 <= '9' and next2 == '.') or
                      (prev2 == '.' and next2 >= '0' and next2 <= '9') {
                    // Merge numeric fragments around the decimal point.
                } elif (prev2 == '+' and next2 == '=') or (prev2 == '-' and next2 == '=') {
                    // Merge `+ =` or `- =` into `+=` / `-=`.
                } elif !is_ident_start(next2) {
                    // Drop the space between token characters (e.g. `0 . 0`).
                } else {
                    out_final = concat(out_final, str(" "));
                }
            } else {
                out_final = concat(out_final, str(" "));
            }
        } else {
            out_final = concat_chr(out_final, chf);
        }

        jf = jf + 1;
    }

    val first_pass: string = strip(out_final);
    println "\nFIRST PASS:";
    println first_pass;
    val fixed: string = replace_all(first_pass, str("(->"), str("->"));
    println "\nFIXED:";
    println fixed;

    val calls_fixed: string = rewrite_function_calls(fixed);
    val enum_fixed: string = rewrite_enum_member_refs(calls_fixed);
    return strip(enum_fixed);
}

/// Generate a C function prototype from a Function AST node
def generate_function_prototype(ast: ref ASTNode): string {
    mut result: string = str("");

    if ast == nil {
        return result;
    }

    val func_name_raw: string = ast.data.function.name;

    // Do not emit a prototype for main
    if equals_c(func_name_raw, "main") {
        return result;
    }

    mut func_name: string = func_name_raw;
    mut return_type: string = ast.data.function.return_type;

    if str_len(return_type) == 0 {
        return_type = str("void");
    }

    val mapped_return_type: string = map_axe_type_to_c(return_type);

    result = concat(result, mapped_return_type);
    result = concat(result, str(" "));
    result = concat(result, func_name);
    result = concat(result, str("("));

    val params: ref list(string) = ast.data.function.params;
    if params != nil {
        mut param_idx: i32 = 0;
        loop {
            if param_idx >= len(deref(params)) {
                break;
            }

            if param_idx > 0 {
                result = concat(result, str(", "));
            }

            val param: string = params.data[param_idx];
            val colon_pos: i32 = find_char_from(param, ':', 0);

            if colon_pos >= 0 {
                val param_name: string = strip(substring_se(param, 0, colon_pos));
                val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                val processed_type: string = process_parameter_type(param_type);

                result = concat(result, processed_type);
                result = concat(result, str(" "));
                result = concat(result, param_name);
            } else {
                result = concat(result, param);
            }

            param_idx = param_idx + 1;
        }
    }

    result = concat(result, str(");\n"));
    return result;
}

/// Generate C code from AST
pub def generate_c(ast: ref ASTNode): string {
    mut result: string = str("");
    
    if ast == nil {
        return result;
    }
    val node_type: string = ast.node_type;

    if equals_c(node_type, "Overload") {
        val name: string = ast.data.overload_node.name;
        mut param_name: string = ast.data.overload_node.param_name;
        mut call_expr: string = ast.data.overload_node.call_expr;

        if str_len(param_name) == 0 {
            param_name = str("x");
        }
        if str_len(call_expr) == 0 {
            call_expr = param_name;
        }

        val type_names_ref: ref list(string) = ast.data.overload_node.type_names;
        val targets_ref: ref list(string) = ast.data.overload_node.target_functions;

        if type_names_ref == nil or targets_ref == nil {
            return result;
        }

        val count: i32 = len(deref(type_names_ref));
        if count == 0 or count != len(deref(targets_ref)) {
            return result;
        }

        // Begin macro definition
        result = concat(result, str("#define "));
        result = concat(result, name);
        result = concat(result, str("("));
        result = concat(result, param_name);
        result = concat(result, str(") _Generic(("));
        result = concat(result, call_expr);
        result = concat(result, str("), \\\n"));

        mut i_ov: i32 = 0;
        loop {
            if i_ov >= count {
                break;
            }

            val axe_type: string = type_names_ref.data[i_ov];
            val target_name: string = targets_ref.data[i_ov];
            val mapped_type: string = map_axe_type_to_c(axe_type);

            result = concat(result, str("    "));
            result = concat(result, mapped_type);
            result = concat(result, str(": "));
            result = concat(result, target_name);

            if i_ov < count - 1 {
                result = concat(result, str(", \\\n"));
            } else {
                result = concat(result, str(" \\\n"));
            }

            i_ov = i_ov + 1;
        }

        result = concat(result, str("    )("));
        result = concat(result, call_expr);
        result = concat(result, str(")\n"));

        return result;
    }
    
    if equals_c(node_type, "Program") {
        result = concat(result, str("#define nil ((void*)0)\n"));
        result = concat(result, str("#include <stdio.h>\n"));
        result = concat(result, str("#include <stdbool.h>\n"));
        result = concat(result, str("#include <stdlib.h>\n"));
        result = concat(result, str("#include <string.h>\n"));
        result = concat(result, str("#include <stdint.h>\n"));
        result = concat(result, str("\n"));
        
        build_function_prefixes(ast);

        if ast.children != nil {
            val children_for_models: ref list(ASTNode) = ast.children;
            mut mi: i32 = 0;
            loop {
                if mi >= len(deref(children_for_models)) {
                    break;
                }
                val mchild: ref ASTNode = addr_of(children_for_models.data[mi]);
                if equals_c(mchild.node_type, "Model") or equals_c(mchild.node_type, "Enum") {
                    mut cname: string = str("");
                    if equals_c(mchild.node_type, "Model") {
                        cname = mchild.data.model_node.name;
                    } else {
                        cname = mchild.data.enum_node.name;
                    }

                    mut base: string = cname;
                    mut last_sep: i32 = -1;
                    mut bi: i32 = 0;
                    val nlen: i32 = str_len(cname);
                    loop {
                        if bi + 1 >= nlen {
                            break;
                        }
                        val c1: char = get_char(cname, bi);
                        val c2: char = get_char(cname, bi + 1);
                        if c1 == '_' and c2 == '_' {
                            last_sep = bi;
                        }
                        bi++;
                    }
                    if last_sep >= 0 and last_sep + 2 < nlen {
                        base = substring_se(cname, last_sep + 2, nlen);
                    }

                    mut arena_local: Arena = Arena.create(256);

                    if str_len(base) > 0 {
                        StringStringMap.set(addr_of(g_model_names), addr_of(arena_local), base, cname);
                    }
                    StringStringMap.set(addr_of(g_model_names), addr_of(arena_local), cname, cname);
                }
                mi++;
            }

            val children: ref list(ASTNode) = ast.children;

            StringBoolMap.clear(addr_of(g_list_element_types));

            mut i_scan: i32 = 0;
            loop {
                if i_scan >= len(deref(children)) {
                    break;
                }
                scan_for_list_types(addr_of(children.data[i_scan]));
                i_scan++;
            }

            mut i_more: i32 = 0;
            loop {
                if i_more >= len(deref(children)) {
                    break;
                }
                val cnode: ref ASTNode = addr_of(children.data[i_more]);
                if equals_c(cnode.node_type, "Function") {
                    val ret_type: string = cnode.data.function.return_type;
                    val br: i32 = find_char_from(ret_type, '[', 0);
                    if br >= 0 and find_char_from(ret_type, ']', br) >= 0 {
                        mut elementType: string = strip(substring_se(ret_type, 0, br));
                        if has_prefix(elementType, str("ref ")) {
                            elementType = strip(substr(elementType, 4, str_len(elementType) - 4));
                        }
                        val mappedC: string = map_axe_type_to_c(elementType);
                        add_list_element(mappedC);
                    }
                } elif equals_c(cnode.node_type, "Model") {
                    val field_names: ref list(string) = cnode.data.model_node.field_names;
                    val field_types: ref list(string) = cnode.data.model_node.field_types;
                    if field_names != nil and field_types != nil {
                        mut fidx: i32 = 0;
                        loop {
                            if fidx >= len(deref(field_types)) or fidx >= len(deref(field_names)) {
                                break;
                            }
                            val ftype: string = field_types.data[fidx];
                            val br2: i32 = find_char_from(ftype, '[', 0);
                            if br2 >= 0 and find_char_from(ftype, ']', br2) >= 0 {
                                mut elemCandidate: string = strip(substring_se(ftype, 0, br2));
                                if has_prefix(elemCandidate, str("ref ")) {
                                    elemCandidate = strip(substr(elemCandidate, 4, str_len(elemCandidate) - 4));
                                }
                                val mappedElem: string = map_axe_type_to_c(elemCandidate);
                                add_list_element(mappedElem);
                            }
                            fidx++;
                        }
                    }
                }
                i_more++;
            }

            mut i_models2: i32 = 0;
            loop {
                if i_models2 >= len(deref(children)) {
                    break;
                }
                val m_child: ref ASTNode = addr_of(children.data[i_models2]);
                if equals_c(m_child.node_type, "Model") {
                    mut name: string = str("");
                    name = m_child.data.model_node.name;
                    if !StringBoolMap.contains(addr_of(g_generated_typedefs), name) {
                        result = concat(result, str("struct "));
                        result = concat(result, name);
                        result = concat(result, str(";\n"));
                    }
                }
                i_models2 = i_models2 + 1;
            }

            mut i_models3: i32 = 0;
            loop {
                if i_models3 >= len(deref(children)) {
                    break;
                }
                val m_child: ref ASTNode = addr_of(children.data[i_models3]);
                if equals_c(m_child.node_type, "Model") {
                    mut name2: string = str("");
                    name2 = m_child.data.model_node.name;
                    if !StringBoolMap.contains(addr_of(g_generated_typedefs), name2) {
                        result = concat(result, str("typedef struct "));
                        result = concat(result, name2);
                        result = concat(result, str(" "));
                        result = concat(result, name2);
                        result = concat(result, str(";\n"));
                    }
                }
                i_models3 = i_models3 + 1;
            }

            if g_list_elements != nil {
                val lst_ref: ref StringList = g_list_elements;
                mut li: i32 = 0;
                loop {
                    if li >= lst_ref*.len {
                        break;
                    }
                    val elemTypeStr: string = StringList.get(lst_ref, li);
                    val san: string = sanitize_list_element_name(elemTypeStr);
                    result = concat(result, str("typedef struct __list_"));
                    result = concat(result, san);
                    result = concat(result, str("_t __list_"));
                    result = concat(result, san);
                    result = concat(result, str("_t;\n"));
                    li = li + 1;
                }
            }

            mut i_models_fd: i32 = 0;
            loop {
                if i_models_fd >= len(deref(children)) {
                    break;
                }
                val m_child_fd: ref ASTNode = addr_of(children.data[i_models_fd]);
                if equals_c(m_child_fd.node_type, "Model") or equals_c(m_child_fd.node_type, "Enum") {
                    val m_code: string = generate_c(m_child_fd);
                    result = concat(result, m_code);
                }
                i_models_fd = i_models_fd + 1;
            }

            if g_list_elements != nil {
                val lst_ref2: ref StringList = g_list_elements;
                mut jj: i32 = 0;
                loop {
                    if jj >= lst_ref2*.len {
                        break;
                    }
                    val elementType: string = StringList.get(lst_ref2, jj);
                    val elemSan: string = sanitize_list_element_name(elementType);

                    result = concat(result, str("typedef struct __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t {\n"));
                    result = concat(result, str("    "));
                    result = concat(result, elementType);
                    result = concat(result, str("* data;\n"));
                    result = concat(result, str("    int len;\n"));
                    result = concat(result, str("    int capacity;\n"));
                    result = concat(result, str("} __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t;\n\n"));

                    result = concat(result, str("static inline __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_init(void) {\n"));
                    result = concat(result, str("    __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t list;\n"));
                    result = concat(result, str("    list.data = NULL;\n"));
                    result = concat(result, str("    list.len = 0;\n"));
                    result = concat(result, str("    list.capacity = 0;\n"));
                    result = concat(result, str("    return list;\n"));
                    result = concat(result, str("}\n\n"));

                    result = concat(result, str("static inline void __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_push(__list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t* list, "));
                    result = concat(result, elementType);
                    result = concat(result, str(" item) {\n"));
                    result = concat(result, str("    if (list->len >= list->capacity) {\n"));
                    result = concat(result, str("        int new_capacity = list->capacity == 0 ? 8 : list->capacity * 2;\n"));
                    result = concat(result, str("        "));
                    result = concat(result, elementType);
                    result = concat(result, str("* new_data = (") );
                    result = concat(result, elementType);
                    result = concat(result, str("*)realloc(list->data, new_capacity * sizeof("));
                    result = concat(result, elementType);
                    result = concat(result, str("));\n"));
                    result = concat(result, str("        if (new_data == NULL) { fprintf(stderr, \"Out of memory\\n\"); exit(1); }\n"));
                    result = concat(result, str("        list->data = new_data;\n"));
                    result = concat(result, str("        list->capacity = new_capacity;\n"));
                    result = concat(result, str("    }\n"));
                    result = concat(result, str("    list->data[list->len++] = item;\n"));
                    result = concat(result, str("}\n\n"));

                    jj = jj + 1;
                }
            }

            mut i_globals: i32 = 0;
            loop {
                if i_globals >= len(deref(children)) {
                    break;
                }
                val g_child: ref ASTNode = addr_of(children.data[i_globals]);
                if equals_c(g_child.node_type, "Declaration") {
                    val g_code: string = generate_c(g_child);
                    if str_len(g_code) > 0 {
                        result = concat(result, g_code);
                    }
                }
                i_globals = i_globals + 1;
            }

            mut i_proto: i32 = 0;
            loop {
                if i_proto >= len(deref(children)) {
                    break;
                }
                val proto_child: ref ASTNode = addr_of(children.data[i_proto]);
                if equals_c(proto_child.node_type, "Function") {
                    val proto_code: string = generate_function_prototype(proto_child);
                    if str_len(proto_code) > 0 {
                        result = concat(result, proto_code);
                    }
                }
                i_proto = i_proto + 1;
            }
            result = concat(result, str("\n"));

            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child: ref ASTNode = addr_of(children.data[i]);
                if equals_c(child.node_type, "Overload") {
                    val ov_code: string = generate_c(child);
                    result = concat(result, ov_code);
                    result = concat(result, str("\n"));
                }
                i = i + 1;
            }

            i = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val fn_child: ref ASTNode = addr_of(children.data[i]);
                if equals_c(fn_child.node_type, "Function") {
                    val fn_name: string = fn_child.data.function.name;
                    if !equals_c(fn_name, "main") {
                        val fn_code: string = generate_c(fn_child);
                        result = concat(result, fn_code);
                    }
                }
                i = i + 1;
            }

            mut i_main_idx: i32 = 0;
            loop {
                if i_main_idx >= len(deref(children)) {
                    break;
                }
                val fnn: ref ASTNode = addr_of(children.data[i_main_idx]);
                if equals_c(fnn.node_type, "Function") {
                    val namecheck: string = fnn.data.function.name;
                    if equals_c(namecheck, "main") {
                        val main_code: string = generate_c(fnn);
                        result = concat(result, main_code);
                        break;
                    }
                }
                i_main_idx++;
            }

            i = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child2: ref ASTNode = addr_of(children.data[i]);
                if !equals_c(child2.node_type, "Overload") and !equals_c(child2.node_type, "Function") and !equals_c(child2.node_type, "Model") and !equals_c(child2.node_type, "Enum") and !equals_c(child2.node_type, "Declaration") {
                    val child_code: string = generate_c(child2);
                    result = concat(result, child_code);
                }
                i = i + 1;
            }
        }
        result = replace_all(result, str("(->"), str("->"));

        mut fixed_result: string = str("");
        mut start_idx: i32 = 0;
        mut idx_line: i32 = 0;
        loop {
            if idx_line >= str_len(result) {
                if start_idx < idx_line {
                    val last_line: string = substring_se(result, start_idx, idx_line);
                    mut line_fixed: string = last_line;

                    val trimmed_last: string = strip(last_line);
                    if has_suffix(trimmed_last, str(");")) {
                        val eq_pos: i32 = find_char_from(last_line, '=', 0);
                        if eq_pos >= 0 {
                            mut open_p: i32 = 0;
                            mut close_p: i32 = 0;
                            mut pi: i32 = eq_pos + 1;
                            loop {
                                if pi >= str_len(last_line) {
                                    break;
                                }
                                val c: char = get_char(last_line, pi);
                                if c == '(' {
                                    open_p = open_p + 1;
                                } elif c == ')' {
                                    close_p = close_p + 1;
                                } elif c == ';' {
                                    break;
                                }
                                pi = pi + 1;
                            }

                            if close_p > open_p {
                                mut semi_idx: i32 = -1;
                                mut sj: i32 = str_len(last_line) - 1;
                                loop {
                                    if sj < 0 {
                                        break;
                                    }
                                    if get_char(last_line, sj) == ';' {
                                        semi_idx = sj;
                                        break;
                                    }
                                    sj = sj - 1;
                                }

                                if semi_idx > 0 {
                                    mut close_idx: i32 = semi_idx - 1;
                                    loop {
                                        if close_idx < 0 {
                                            break;
                                        }
                                        val cc: char = get_char(last_line, close_idx);
                                        if cc == ' ' or cc == '\t' or cc == '\n' {
                                            close_idx = close_idx - 1;
                                            continue;
                                        }
                                        break;
                                    }

                                    if close_idx >= 0 and get_char(last_line, close_idx) == ')' {
                                        mut tmp: string = str("");
                                        tmp = concat(tmp, substring_se(last_line, 0, close_idx));
                                        tmp = concat(tmp, substring_se(last_line, close_idx + 1, str_len(last_line)));
                                        line_fixed = tmp;
                                    }
                                }
                            }
                        }
                    }

                    fixed_result = concat(fixed_result, line_fixed);
                }
                break;
            }

            val ch: char = get_char(result, idx_line);
            if ch == '\n' {
                val line: string = substring_se(result, start_idx, idx_line + 1);
                mut line_fixed2: string = line;

                val trimmed: string = strip(line);
                if has_suffix(trimmed, str(");")) {
                    val eq_pos2: i32 = find_char_from(line, '=', 0);
                    if eq_pos2 >= 0 {
                        mut open_p2: i32 = 0;
                        mut close_p2: i32 = 0;
                        mut pi2: i32 = eq_pos2 + 1;
                        loop {
                            if pi2 >= str_len(line) {
                                break;
                            }
                            val c2: char = get_char(line, pi2);
                            if c2 == '(' {
                                open_p2 = open_p2 + 1;
                            } elif c2 == ')' {
                                close_p2 = close_p2 + 1;
                            } elif c2 == ';' {
                                break;
                            }
                            pi2 = pi2 + 1;
                        }

                        if close_p2 > open_p2 {
                            mut semi_idx2: i32 = -1;
                            mut sj2: i32 = str_len(line) - 1;
                            loop {
                                if sj2 < 0 {
                                    break;
                                }
                                if get_char(line, sj2) == ';' {
                                    semi_idx2 = sj2;
                                    break;
                                }
                                sj2 = sj2 - 1;
                            }

                            if semi_idx2 > 0 {
                                mut close_idx2: i32 = semi_idx2 - 1;
                                loop {
                                    if close_idx2 < 0 {
                                        break;
                                    }
                                    val cc2: char = get_char(line, close_idx2);
                                    if cc2 == ' ' or cc2 == '\t' or cc2 == '\n' {
                                        close_idx2 = close_idx2 - 1;
                                        continue;
                                    }
                                    break;
                                }

                                if close_idx2 >= 0 and get_char(line, close_idx2) == ')' {
                                    mut tmp2: string = str("");
                                    tmp2 = concat(tmp2, substring_se(line, 0, close_idx2));
                                    tmp2 = concat(tmp2, substring_se(line, close_idx2 + 1, str_len(line)));
                                    line_fixed2 = tmp2;
                                }
                            }
                        }
                    }
                }

                fixed_result = concat(fixed_result, line_fixed2);
                start_idx = idx_line + 1;
            }

            idx_line = idx_line + 1;
        }

        if str_len(fixed_result) > 0 {
            result = fixed_result;
        }
    }

    if equals_c(node_type, "Program") {
        result = strip_all_c_prefixes(result);
        result = replace_all(result, str("C . "), str(""));
        result = replace_all(result, str("C."), str(""));
    }

    if equals_c(node_type, "Test") {
        result = concat(result, str("int main(int argc, char** argv) {\n"));
        result = concat(result, str("    int passed = 0;\n"));
        result = concat(result, str("    int failed = 0;\n\n"));

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_test: i32 = 0;
            loop {
                if i_test >= len(deref(children)) {
                    break;
                }

                val child: ref ASTNode = addr_of(children.data[i_test]);

                if equals_c(child.node_type, "Assert") {
                    val cond_raw: string = strip(child.data.assert_node.condition);
                    val cond_norm: string = process_expression(cond_raw);
                    val msg: string = child.data.assert_node.message;

                    result = concat(result, str("    if ("));
                    result = concat(result, cond_norm);
                    result = concat(result, str(") {\n"));
                    result = concat(result, str("        printf(\"PASSED: "));
                    result = concat(result, msg);
                    result = concat(result, str("\\n\");\n"));
                    result = concat(result, str("        passed++;\n"));
                    result = concat(result, str("    } else {\n"));
                    result = concat(result, str("        printf(\"FAILED: "));
                    result = concat(result, msg);
                    result = concat(result, str("\\n\");\n"));
                    result = concat(result, str("        failed++;\n"));
                    result = concat(result, str("    }\n\n"));
                } elif equals_c(child.node_type, "Declaration") {
                    val var_name: string = child.data.declaration.name;
                    val type_name: string = child.data.declaration.type_name;
                    val is_mutable: bool = child.data.declaration.is_mutable;
                    val initializer: string = child.data.declaration.initializer;

                    mut mapped_type: string = map_type(type_name);
                    mut line: string = str("");

                    if is_mutable {
                        line = concat(line, mapped_type);
                        line = concat(line, str(" "));
                        line = concat(line, var_name);
                    } else {
                        line = concat(line, str("const "));
                        line = concat(line, mapped_type);
                        line = concat(line, str(" "));
                        line = concat(line, var_name);
                    }

                    mut trimmed_init: string = strip(initializer);
                    if str_len(trimmed_init) > 0 {
                        val init_norm: string = process_expression(trimmed_init);
                        line = concat(line, str(" = "));
                        line = concat(line, init_norm);
                    }

                    line = concat(line, str(";"));
                    result = concat(result, str("    "));
                    result = concat(result, line);
                    result = concat(result, str("\n"));
                } else {
                    val stmt_code: string = generate_c(child);
                    if str_len(stmt_code) > 0 {
                        mut line: string = str("");
                        mut buf: string = stmt_code;
                        mut idx: i32 = 0;

                        loop {
                            if idx >= str_len(buf) {
                                break;
                            }
                            val ch: char = get_char(buf, idx);
                            if ch == '\n' {
                                if str_len(line) > 0 {
                                    result = concat(result, str("    "));
                                    result = concat(result, line);
                                    result = concat(result, str("\n"));
                                    line = str("");
                                }
                            } else {
                                line = concat_chr(line, ch);
                            }
                            idx = idx + 1;
                        }

                        if str_len(line) > 0 {
                            result = concat(result, str("    "));
                            result = concat(result, line);
                            result = concat(result, str("\n"));
                        }
                    }
                }

                i_test = i_test + 1;
            }
        }

        result = concat(result, str("    printf(\"\\n\");\n"));
        result = concat(result, str("    if (failed == 0) {\n"));
        result = concat(result, str("        printf(\"All tests passed. (%d/%d)\\n\", passed, passed + failed);\n"));
        result = concat(result, str("    } else {\n"));
        result = concat(result, str("        printf(\"%d test(s) failed, %d passed\\n\", failed, passed);\n"));
        result = concat(result, str("    }\n"));
        result = concat(result, str("    return failed > 0 ? 1 : 0;\n"));
        result = concat(result, str("}\n"));

        return result;
    }
    
    if equals_c(node_type, "Function") {
        mut func_name: string = ast.data.function.name;
        mut return_type: string = ast.data.function.return_type;
        val is_public: bool = ast.data.function.is_public;
        
        if !equals_c(func_name, "main") {
            if StringStringMap.contains(addr_of(g_function_prefixes), func_name) {
                func_name = StringStringMap.get(addr_of(g_function_prefixes), func_name);
            }
        }
        
        if StringBoolMap.contains(addr_of(g_generated_functions), func_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_functions), addr_of(arena), func_name, true);
        
        if equals_c(func_name, "main") {
            result = concat(result, str("int main(int argc, char** argv) {\n"));
            
            if ast.children != nil {
                val children: ref list(ASTNode) = ast.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_code: string = generate_c(addr_of(children.data[i]));
                    result = concat(result, child_code);
                    i++;
                }
            }
            
            result = concat(result, str("return 0;\n"));
            result = concat(result, str("}\n\n"));
            return result;
        }
        
        if str_len(return_type) == 0 {
            return_type = str("void");
        }
        
        val mapped_return_type: string = map_type(return_type);
        
        result = concat(result, mapped_return_type);
        result = concat(result, str(" "));
        result = concat(result, func_name);
        result = concat(result, str("("));
        
        val params: ref list(string) = ast.data.function.params;
        if params != nil {
            mut param_idx: i32 = 0;
            loop {
                if param_idx >= len(deref(params)) {
                    break;
                }
                
                if param_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                val param: string = params.data[param_idx];
                val colon_pos: i32 = find_char_from(param, ':', 0);

                if colon_pos >= 0 {
                    val param_name: string = strip(substring_se(param, 0, colon_pos));
                    val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                    val processed_type: string = process_parameter_type(param_type);
                    
                    result = concat(result, processed_type);
                    result = concat(result, str(" "));
                    result = concat(result, param_name);
                } else {
                    result = concat(result, param);
                }
                
                param_idx++;
            }
        }
        
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n\n"));
        return result;
    }
    
    if equals_c(node_type, "Return") {
        result = concat(result, str("return "));
        mut expr: string = ast.data.return_node.expression;
        println "\n[DEBUG] RENDERER raw return expr:";
        println expr;

        mut trimmed_ret: string = strip(expr);
        val paren_pos_ret: i32 = find_char_from(trimmed_ret, '(', 0);
        if paren_pos_ret > 0 {
            val call_name_ret: string = strip(substring_se(trimmed_ret, 0, paren_pos_ret));
            if StringStringMap.contains(addr_of(g_function_prefixes), call_name_ret) {
                val full_name_ret: string = StringStringMap.get(addr_of(g_function_prefixes), call_name_ret);
                val rest_ret: string = substring_se(trimmed_ret, paren_pos_ret, str_len(trimmed_ret));
                trimmed_ret = concat(full_name_ret, rest_ret);
                expr = trimmed_ret;
            }
        }

        println "\n[DBG-CALL] process_expression from Return:";
        println expr;
        val processed: string = process_expression(expr);
        println "\n[DEBUG] RENDERER processed return expr:";
        println processed;
        result = concat(result, processed);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Break") {
        result = concat(result, str("break;\n"));
        return result;
    }
    
    if equals_c(node_type, "Continue") {
        result = concat(result, str("continue;\n"));
        return result;
    }
    
    if equals_c(node_type, "Declaration") {
        val var_name: string = ast.data.declaration.name;
        mut type_name: string = ast.data.declaration.type_name;
        val is_mutable: bool = ast.data.declaration.is_mutable;
        val initializer: string = ast.data.declaration.initializer;
        
        mut mapped_type: string = map_type(type_name);

        if str_len(type_name) == 0 {
            mut trimmed_init: string = strip(initializer);
            if has_prefix(trimmed_init, str("new ")) {
                trimmed_init = substring_se(trimmed_init, 4, str_len(trimmed_init));
                trimmed_init = strip(trimmed_init);

                mut end_pos: i32 = -1;
                mut i: i32 = 0;
                loop {
                    if i >= str_len(trimmed_init) {
                        break;
                    }
                    val ch: char = get_char(trimmed_init, i);
                    if ch == '(' or ch == ' ' or ch == '\t' {
                        end_pos = i;
                        break;
                    }
                    i = i + 1;
                }
                if end_pos < 0 {
                    end_pos = str_len(trimmed_init);
                }
                val inferred_name: string = strip(substring_se(trimmed_init, 0, end_pos));
                if str_len(inferred_name) > 0 {
                    type_name = inferred_name;
                    mapped_type = map_type(type_name);
                }
            }
        }

        val enum_model_name: string = canonical_model_c_name(type_name);
        if str_len(enum_model_name) > 0 and StringBoolMap.contains(addr_of(g_enum_names), enum_model_name) {
            mapped_type = enum_model_name;
        }

        if is_mutable {
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        } else {
            result = concat(result, str("const "));
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        }
        
        if str_len(initializer) > 0 {
            mut trimmed: string = strip(initializer);
            if has_prefix(trimmed, str("new ")) {
                trimmed = substring_se(trimmed, 4, str_len(trimmed));
                trimmed = strip(trimmed);

                val first_paren: i32 = find_char_from(trimmed, '(', 0);
                if first_paren < 0 {
                    result = concat(result, str(" = {0}"));
                } else {
                    mut last_paren: i32 = -1;
                    mut idx: i32 = str_len(trimmed) - 1;
                    loop {
                        if idx < 0 {
                            break;
                        }
                        val ch_end: char = get_char(trimmed, idx);
                        if ch_end == ')' {
                            last_paren = idx;
                            break;
                        }
                        idx = idx - 1;
                    }

                    if last_paren <= first_paren + 1 {
                        // No arguments
                        result = concat(result, str(" = {0}"));
                    } else {
                        val args_str: string = substring_se(trimmed, first_paren + 1, last_paren);
                        mut init_code: string = str(" = {");

                        mut current: string = str("");
                        mut depth: i32 = 0;
                        mut first_field: bool = true;
                        mut i2: i32 = 0;

                        loop {
                            if i2 >= str_len(args_str) {
                                break;
                            }
                            val ch: char = get_char(args_str, i2);
                            if ch == '(' {
                                depth = depth + 1;
                                current = concat_chr(current, ch);
                            } elif ch == ')' {
                                if depth > 0 {
                                    depth = depth - 1;
                                }
                                current = concat_chr(current, ch);
                            } elif ch == ',' and depth == 0 {
                                mut part: string = strip(current);
                                if str_len(part) > 0 {
                                    val colon_pos: i32 = find_char_from(part, ':', 0);
                                    if colon_pos >= 0 {
                                        val field_name: string = strip(substring_se(part, 0, colon_pos));
                                        val value_expr: string = strip(substr(part, colon_pos + 1, str_len(part) - colon_pos - 1));
                                        if str_len(field_name) > 0 and str_len(value_expr) > 0 {
                                            if !first_field {
                                                init_code = concat(init_code, str(", "));
                                            }
                                            init_code = concat(init_code, str("."));
                                            init_code = concat(init_code, field_name);
                                            init_code = concat(init_code, str(" = "));
                                            init_code = concat(init_code, value_expr);
                                            first_field = false;
                                        }
                                    }
                                }
                                current = str("");
                            } else {
                                current = concat_chr(current, ch);
                            }
                            i2++;
                        }

                        mut part_last: string = strip(current);
                        if str_len(part_last) > 0 {
                            val colon_pos_last: i32 = find_char_from(part_last, ':', 0);
                            if colon_pos_last >= 0 {
                                val field_name_last: string = strip(substring_se(part_last, 0, colon_pos_last));
                                val value_expr_last: string = strip(substr(part_last, colon_pos_last + 1, str_len(part_last) - colon_pos_last - 1));
                                if str_len(field_name_last) > 0 and str_len(value_expr_last) > 0 {
                                    if !first_field {
                                        init_code = concat(init_code, str(", "));
                                    }
                                    init_code = concat(init_code, str("."));
                                    init_code = concat(init_code, field_name_last);
                                    init_code = concat(init_code, str(" = "));
                                    init_code = concat(init_code, value_expr_last);
                                    first_field = false;
                                }
                            }
                        }

                        if first_field {
                            result = concat(result, str(" = {0}"));
                        } else {
                            init_code = concat(init_code, str("}"));
                            result = concat(result, init_code);
                        }
                    }
                }
            } else {
                // If the initializer is a plain function call IDENT(...),
                // rewrite IDENT using g_function_prefixes so that short names
                // like `str` get expanded to their fully-prefixed C names
                // (e.g., std__string__str) even inside methods/models.
                val paren_pos: i32 = find_char_from(trimmed, '(', 0);
                if paren_pos > 0 {
                    val call_name_raw: string = strip(substring_se(trimmed, 0, paren_pos));
                    if StringStringMap.contains(addr_of(g_function_prefixes), call_name_raw) {
                        val full_name: string = StringStringMap.get(addr_of(g_function_prefixes), call_name_raw);
                        val rest: string = substring_se(trimmed, paren_pos, str_len(trimmed));
                        trimmed = concat(full_name, rest);
                    }
                }

                val processed_init: string = process_expression(trimmed);
                result = concat(result, str(" = "));
                result = concat(result, processed_init);
            }
        }
        
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Assignment") {
        val variable: string = ast.data.assignment.variable;
        val expression: string = ast.data.assignment.expression;
        
        println "\n[DBG-ASSIGN] Assignment node";
        println "\n[DBG-ASSIGN]   raw variable:";
        println variable;
        println "\n[DBG-ASSIGN]   raw expression:";
        println expression;

        println "\n[DBG-CALL] process_expression from Assignment.variable:";
        println variable;
        val processed_var: string = process_expression(variable);
        println "\n[DBG-CALL] process_expression from Assignment.expression:";
        println expression;
        val processed_expr: string = process_expression(expression);

        println "\n[DBG-ASSIGN]   processed variable:";
        println processed_var;
        println "\n[DBG-ASSIGN]   processed expression:";
        println processed_expr;
        
        val pv: string = processed_var;
        println "\n[DBG-ASSIGN]   pv before fix:";
        println pv;
        mut fixed_var: string = str("");
        mut idx_av: i32 = 0;
        loop {
            if idx_av >= str_len(pv) {
                break;
            }
            val chx: char = get_char(pv, idx_av);

            if chx == '(' and idx_av > 0 {
                val prev_ch: char = get_char(pv, idx_av - 1);
                if (prev_ch >= 'a' and prev_ch <= 'z') or
                   (prev_ch >= 'A' and prev_ch <= 'Z') or
                   (prev_ch >= '0' and prev_ch <= '9') or
                   prev_ch == '_' {

                    mut k2: i32 = idx_av + 1;
                    loop {
                        if k2 >= str_len(pv) {
                            break;
                        }
                        val ws2: char = get_char(pv, k2);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        k2 = k2 + 1;
                    }

                    if k2 + 1 < str_len(pv) and
                       get_char(pv, k2) == '-' and
                       get_char(pv, k2 + 1) == '>' {
                        idx_av = k2;
                        continue;
                    }
                }
            }

            fixed_var = concat_chr(fixed_var, chx);
            idx_av = idx_av + 1;
        }

        mut out_lhs: string = fixed_var;
        mut out_rhs: string = processed_expr;
        mut ri: i32 = 0;

        loop {
            if ri >= str_len(processed_expr) {
                break;
            }
            val ws0: char = get_char(processed_expr, ri);
            if ws0 != ' ' and ws0 != '\t' and ws0 != '\n' {
                break;
            }
            ri = ri + 1;
        }

        if ri < str_len(processed_expr) and is_ident_start(get_char(processed_expr, ri)) {
            mut istart: i32 = ri;
            mut j: i32 = ri + 1;
            loop {
                if j >= str_len(processed_expr) {
                    break;
                }
                val cj: char = get_char(processed_expr, j);
                if !((cj >= 'a' and cj <= 'z') or (cj >= 'A' and cj <= 'Z') or (cj >= '0' and cj <= '9') or cj == '_') {
                    break;
                }
                j = j + 1;
            }

            val enum_ident: string = substring_se(processed_expr, istart, j);

            mut k: i32 = j;
            loop {
                if k >= str_len(processed_expr) {
                    break;
                }
                val ws1: char = get_char(processed_expr, k);
                if ws1 != ' ' and ws1 != '\t' and ws1 != '\n' {
                    break;
                }
                k = k + 1;
            }

            if k < str_len(processed_expr) and get_char(processed_expr, k) == '.' {
                k = k + 1;
                loop {
                    if k >= str_len(processed_expr) {
                        break;
                    }
                    val ws2: char = get_char(processed_expr, k);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(processed_expr) and is_ident_start(get_char(processed_expr, k)) {
                    mut mstart: i32 = k;
                    mut m: i32 = k + 1;
                    loop {
                        if m >= str_len(processed_expr) {
                            break;
                        }
                        val cm: char = get_char(processed_expr, m);
                        if !((cm >= 'a' and cm <= 'z') or (cm >= 'A' and cm <= 'Z') or (cm >= '0' and cm <= '9') or cm == '_') {
                            break;
                        }
                        m = m + 1;
                    }

                    val member: string = substring_se(processed_expr, mstart, m);
                    val enum_c_name2: string = canonical_model_c_name(enum_ident);

                    if str_len(enum_c_name2) > 0 {
                        mut rebuilt: string = str("");
                        if ri > 0 {
                            rebuilt = substring_se(processed_expr, 0, ri);
                        }
                        rebuilt = concat(rebuilt, enum_c_name2);
                        rebuilt = concat(rebuilt, str("_"));
                        rebuilt = concat(rebuilt, member);
                        if m < str_len(processed_expr) {
                            val suffix: string = substring_se(processed_expr, m, str_len(processed_expr));
                            rebuilt = concat(rebuilt, suffix);
                        }
                        out_rhs = rebuilt;
                    }
                }
            }
        }

        if has_prefix(processed_expr, str("->")) {
            val eq_pos: i32 = find_char_from(processed_expr, '=', 0);
            if eq_pos > 0 {
                val lhs_suffix: string = substring_se(processed_expr, 0, eq_pos);
                val rhs_suffix: string = substring_se(processed_expr, eq_pos + 1, str_len(processed_expr));

                out_lhs = concat(fixed_var, lhs_suffix);
                out_rhs = strip(rhs_suffix);

                println "\n[DBG-ASSIGN]   reconstructed LHS (arrow sugar):";
                println out_lhs;
                println "\n[DBG-ASSIGN]   reconstructed RHS (arrow sugar):";
                println out_rhs;
            }
        }

        result = concat(result, out_lhs);
        result = concat(result, str(" = "));
        result = concat(result, out_rhs);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "MemberAccess") {
        val object_name: string = ast.data.member_access.object_name;
        val member_name: string = ast.data.member_access.member_name;
        val value: string = ast.data.member_access.value;
        
        println "\n[DBG-MEM] MemberAccess node";
        println "\n[DBG-MEM]   object_name:";
        println object_name;
        println "\n[DBG-MEM]   member_name:";
        println member_name;
        println "\n[DBG-MEM]   raw value:";
        println value;

        mut lhs: string = object_name;

        lhs = concat(lhs, str("."));
        lhs = concat(lhs, member_name);

        val processed_lhs: string = process_expression(lhs);

        mut final_lhs: string = processed_lhs;
        if has_prefix(final_lhs, str("->")) and str_len(object_name) > 0 {
            mut base: string = strip(object_name);
            if str_len(base) > 0 and get_char(base, str_len(base) - 1) == '*' {
                base = strip(substring_se(base, 0, str_len(base) - 1));
            }
            final_lhs = concat(base, final_lhs);
        }

        result = concat(result, final_lhs);

        if str_len(strip(value)) > 0 {
            val processed_value: string = strip(value);
            println "\n[DEBUG]   processed value:";
            println processed_value;
            result = concat(result, str(" = "));
            result = concat(result, processed_value);
        }

        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "FunctionCall") {
        val func_name: string = ast.data.func_call.function_name;

        mut emitted_name: string = func_name;
        if StringStringMap.contains(addr_of(g_function_prefixes), func_name) {
            emitted_name = StringStringMap.get(addr_of(g_function_prefixes), func_name);
        }

        result = concat(result, emitted_name);
        result = concat(result, str("("));
        
        val args: ref list(string) = ast.data.func_call.args;
        if args != nil {
            mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= len(deref(args)) {
                    break;
                }
                
                if arg_idx > 0 {
                    result = concat(result, str(", "));
                }
                val raw_arg: string = args.data[arg_idx];
                val processed_arg: string = process_expression(raw_arg);
                result = concat(result, processed_arg);
                arg_idx++;
            }
        }
        
        result = concat(result, str(");\n"));
        return result;
    }
    
    if equals_c(node_type, "Print") {
        val messages_ref: ref list(string) = ast.data.print.messages;
        val flags_ref: ref list(bool) = ast.data.print.is_expressions;

        if messages_ref == nil or flags_ref == nil {
            return result;
        }

        val messages: list(string) = deref(messages_ref);
        val flags: list(bool) = deref(flags_ref);

        if len(messages) == 0 {
            return result;
        }

        if len(messages) == 1 and len(flags) == 1 and !flags.data[0] {
            result = concat(result, str("printf(\""));
            result = concat(result, messages.data[0]);
            result = concat(result, str("\");\n"));
            return result;
        }

        result = strip_all_c_prefixes(result);
        return result;
    }
    
    if equals_c(node_type, "Loop") {
        result = concat(result, str("while (1) {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "For") {
        val init_raw: string = ast.data.for_loop.initialization;
        val cond_raw: string = ast.data.for_loop.condition;
        val incr_raw: string = ast.data.for_loop.increment;

        mut init: string = strip(init_raw);
        mut cond: string = strip(cond_raw);
        mut incr: string = strip(incr_raw);

        if has_prefix(init, str("mut ")) {
            init = strip(substr(init, 4, str_len(init) - 4));
        }

        mut header: string = str("int32_t ");
        header = concat(header, init);
        header = concat(header, str("; "));
        header = concat(header, cond);
        header = concat(header, str("; "));
        header = concat(header, incr);

        header = replace_all(header, str("+ ="), str("+="));
        header = replace_all(header, str("- ="), str("-="));
        header = replace_all(header, str("+  ="), str("+="));
        header = replace_all(header, str("-  ="), str("-="));

        val header_norm: string = process_expression(header);

        result = concat(result, str("for ("));
        result = concat(result, header_norm);
        result = concat(result, str(") {\n"));

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_for: i32 = 0;
            loop {
                if i_for >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i_for]));
                result = concat(result, child_code);
                i_for = i_for + 1;
            }
        }

        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "If") {
        val condition: string = ast.data.if_node.condition;
        mut trimmed_cond: string = strip(condition);

        trimmed_cond = process_expression(trimmed_cond);

        result = concat(result, str("if ("));
        result = concat(result, trimmed_cond);
        result = concat(result, str(") {\n"));

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_ref: ref ASTNode = addr_of(children.data[i]);
                if equals_c(child_ref.node_type, "ElseMarker") {
                    break;
                }
                val child_code: string = generate_c(child_ref);
                result = concat(result, child_code);
                i = i + 1;
            }

            result = concat(result, str("}\n"));

            if i < len(deref(children)) and equals_c(children.data[i].node_type, "ElseMarker") {
                i = i + 1;
                if i < len(deref(children)) {
                    result = concat(result, str("else {\n"));
                    loop {
                        if i >= len(deref(children)) {
                            break;
                        }
                        val else_child: ref ASTNode = addr_of(children.data[i]);
                        val else_code: string = generate_c(else_child);
                        result = concat(result, else_code);
                        i = i + 1;
                    }
                    result = concat(result, str("}\n"));
                }
                return result;
            }

            return result;
        }

        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "Unsafe") {
        val body: ref list(ASTNode) = ast.data.unsafe_node.body;
        if body != nil {
            mut i_unsafe: i32 = 0;
            loop {
                if i_unsafe >= len(deref(body)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(body.data[i_unsafe]));
                result = concat(result, child_code);
                i_unsafe = i_unsafe + 1;
            }
        }
        return result;
    }

    if equals_c(node_type, "RawC") {
        val raw_code: string = ast.data.raw_c.code;
        println "\n[DBG-RAWC] RawC node emitting:";
        println raw_code;
        result = concat(result, raw_code);
        result = concat(result, str("\n"));
        return result;
    }
    
    if equals_c(node_type, "Model") {
        val model_name: string = ast.data.model_node.name;
        val is_public: bool = ast.data.model_node.is_public;
        val field_names: ref list(string) = ast.data.model_node.field_names;
        val field_types: ref list(string) = ast.data.model_node.field_types;
        val union_parents: ref list(string) = ast.data.model_node.union_member_parents;
        val union_names: ref list(string) = ast.data.model_node.union_member_names;
        val union_types: ref list(string) = ast.data.model_node.union_member_types;

        if StringBoolMap.contains(addr_of(g_generated_typedefs), model_name) {
            return str("");
        }

        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_typedefs), addr_of(arena), model_name, true);

        result = concat(result, str("typedef struct "));
        result = concat(result, model_name);
        result = concat(result, str(" {\n"));

        if field_names != nil and field_types != nil {
            mut field_idx: i32 = 0;
            loop {
                if field_idx >= len(deref(field_names)) {
                    break;
                }

                val field_name: string = field_names.data[field_idx];
                val field_type: string = field_types.data[field_idx];

                mut field_key: string = model_name;
                field_key = concat(field_key, str("."));
                field_key = concat(field_key, field_name);
                StringStringMap.set(addr_of(g_field_types), addr_of(arena), field_key, field_type);

                if str_len(field_type) == 5 and equals_c(field_type, "union") and union_parents != nil and union_names != nil and union_types != nil {
                    result = concat(result, str("    union {\n"));

                    val up: list(string) = deref(union_parents);
                    val un: list(string) = deref(union_names);
                    val ut: list(string) = deref(union_types);

                    mut uidx: i32 = 0;
                    loop {
                        if uidx >= len(up) or uidx >= len(un) or uidx >= len(ut) {
                            break;
                        }

                        val parent_name: string = up.data[uidx];
                        if compare(parent_name, field_name) == 0 {
                            val member_name: string = un.data[uidx];
                            val member_type_raw: string = ut.data[uidx];

                            if str_len(member_type_raw) == 5 and equals_c(member_type_raw, "model") {
                                result = concat(result, str("        struct {\n"));

                                mut nidx: i32 = 0;
                                loop {
                                    if nidx >= len(up) or nidx >= len(un) or nidx >= len(ut) {
                                        break;
                                    }

                                    val nested_parent: string = up.data[nidx];
                                    if compare(nested_parent, member_name) == 0 {
                                        val nested_name: string = un.data[nidx];
                                        val nested_type_raw: string = ut.data[nidx];

                                        mut mapped_nested_type: string = map_axe_type_to_c(nested_type_raw);
                                        mut nested_array_part: string = str("");

                                        val n_bracket_pos: i32 = find_char_from(mapped_nested_type, '[', 0);
                                        if n_bracket_pos >= 0 {
                                            nested_array_part = substring_se(mapped_nested_type, n_bracket_pos, str_len(mapped_nested_type));
                                            mapped_nested_type = substring_se(mapped_nested_type, 0, n_bracket_pos);
                                        }

                                        if has_prefix(mapped_nested_type, str("ref ")) {
                                            mapped_nested_type = concat(strip(substring_se(mapped_nested_type, 4, str_len(mapped_nested_type))), str("*"));
                                        }

                                        val c_nested_model_name: string = canonical_model_c_name(mapped_nested_type);
                                        if str_len(c_nested_model_name) > 0 {
                                            if StringBoolMap.contains(addr_of(g_enum_names), c_nested_model_name) {
                                                mapped_nested_type = c_nested_model_name;
                                            } else {
                                                mapped_nested_type = concat(str("struct "), c_nested_model_name);
                                            }
                                        }

                                        result = concat(result, str("            "));
                                        result = concat(result, mapped_nested_type);
                                        result = concat(result, str(" "));
                                        result = concat(result, nested_name);
                                        result = concat(result, nested_array_part);
                                        result = concat(result, str(";\n"));
                                    }

                                    nidx = nidx + 1;
                                }

                                result = concat(result, str("        } "));
                                result = concat(result, member_name);
                                result = concat(result, str(";\n"));
                            } else {
                                mut mapped_member_type: string = map_axe_type_to_c(member_type_raw);
                                mut member_array_part: string = str("");

                                val m_bracket_pos: i32 = find_char_from(mapped_member_type, '[', 0);
                                if m_bracket_pos >= 0 {
                                    member_array_part = substring_se(mapped_member_type, m_bracket_pos, str_len(mapped_member_type));
                                    mapped_member_type = substring_se(mapped_member_type, 0, m_bracket_pos);
                                }

                                if has_prefix(mapped_member_type, str("ref ")) {
                                    mapped_member_type = concat(strip(substring_se(mapped_member_type, 4, str_len(mapped_member_type))), str("*"));
                                }

                                val c_member_model_name: string = canonical_model_c_name(mapped_member_type);
                                if str_len(c_member_model_name) > 0 {
                                    if StringBoolMap.contains(addr_of(g_enum_names), c_member_model_name) {
                                        mapped_member_type = c_member_model_name;
                                    } else {
                                        mapped_member_type = concat(str("struct "), c_member_model_name);
                                    }
                                }

                                result = concat(result, str("        "));
                                result = concat(result, mapped_member_type);
                                result = concat(result, str(" "));
                                result = concat(result, member_name);
                                result = concat(result, member_array_part);
                                result = concat(result, str(";\n"));
                            }
                        }

                        uidx = uidx + 1;
                    }

                    result = concat(result, str("    } "));
                    result = concat(result, field_name);
                    result = concat(result, str(";\n"));
                } else {
                    mut mapped_type: string = map_axe_type_to_c(field_type);
                    mut array_part: string = str("");

                    val bracket_pos: i32 = find_char_from(mapped_type, '[', 0);
                    if bracket_pos >= 0 {
                        array_part = substring_se(mapped_type, bracket_pos, str_len(mapped_type));
                        mapped_type = substring_se(mapped_type, 0, bracket_pos);
                    }

                    if has_prefix(mapped_type, str("ref ")) {
                        mapped_type = concat(strip(substring_se(mapped_type, 4, str_len(mapped_type))), str("*"));
                    }

                    val c_model_name: string = canonical_model_c_name(mapped_type);
                    if str_len(c_model_name) > 0 {
                        if StringBoolMap.contains(addr_of(g_enum_names), c_model_name) {
                            mapped_type = c_model_name;
                        } else {
                            mapped_type = concat(str("struct "), c_model_name);
                        }
                    }

                    result = concat(result, str("    "));
                    result = concat(result, mapped_type);
                    result = concat(result, str(" "));
                    result = concat(result, field_name);
                    result = concat(result, array_part);
                    result = concat(result, str(";\n"));
                }

                field_idx++;
            }
        }

        result = concat(result, str("} "));
        result = concat(result, model_name);
        result = concat(result, str(";\n\n"));
        return result;
    }

    if equals_c(node_type, "Enum") {
        val enum_name: string = ast.data.enum_node.name;
        val enum_values: ref list(string) = ast.data.enum_node.values;
        
        if StringBoolMap.contains(addr_of(g_generated_typedefs), enum_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_typedefs), addr_of(arena), enum_name, true);
        StringBoolMap.set(addr_of(g_enum_names), addr_of(arena), enum_name, true);
        
        result = concat(result, str("typedef enum {\n"));
        
        if enum_values != nil {
            mut value_idx: i32 = 0;
            val num_values: i32 = len(deref(enum_values));
            
            loop {
                if value_idx >= num_values {
                    break;
                }
                
                val enum_value: string = enum_values.data[value_idx];
                
                result = concat(result, str("    "));
                result = concat(result, enum_name);
                result = concat(result, str("_"));
                result = concat(result, enum_value);
                
                if value_idx < num_values - 1 {
                    result = concat(result, str(","));
                }
                result = concat(result, str("\n"));
                
                value_idx++;
            }
        }
        
        result = concat(result, str("} "));
        result = concat(result, enum_name);
        result = concat(result, str(";\n\n"));
        
        return result;
    }
    
    return result;
}

test {
    initialize_renderer();
    
    println "\nTest 1: Initialize renderer";
    assert StringStringMap.contains(addr_of(g_type_mappings), str("i32")), "Expected i32 type mapping";
    assert equals_c(map_type(str("i32")), "int32_t"), "Expected i32 to map to int32_t";
    
    println "\nTest 2: Map types";
    assert equals_c(map_type(str("i64")), "int64_t"), "Expected i64 to map to int64_t";
    assert equals_c(map_type(str("f32")), "float"), "Expected f32 to map to float";
    assert equals_c(map_type(str("bool")), "bool"), "Expected bool to map to bool";
    
    println "\nTest 3: Generate empty program";
    mut empty_ast: ASTNode;
    empty_ast.node_type = str("Program");
    empty_ast.children = nil;
    val code: string = generate_c(addr_of(empty_ast));
    assert str_contains_c(code, "#include <stdio.h>"), "Expected stdio.h include";
    assert str_contains_c(code, "#include <stdint.h>"), "Expected stdint.h include";
    
    println "\nTest 4: Generate main function";
    mut func_ast: ASTNode;
    func_ast.node_type = str("Function");
    func_ast.data.function.name = str("main");
    func_ast.data.function.return_type = str("i32");
    func_ast.data.function.is_public = false;
    func_ast.data.function.params = nil;
    func_ast.children = nil;
    val func_code: string = generate_c(addr_of(func_ast));
    assert str_contains_c(func_code, "int main"), "Expected int main function";
    assert str_contains_c(func_code, "return 0;"), "Expected return 0 in main";

    mut model_arena: Arena = Arena.create(4096);

    println "\nTest 5: Generate simple function";
    mut simple_func: ASTNode;
    simple_func.node_type = str("Function");
    simple_func.data.function.name = str("add");
    simple_func.data.function.return_type = str("i32");
    simple_func.data.function.is_public = false;
    simple_func.data.function.params = nil;
    simple_func.children = nil;
    val simple_code: string = generate_c(addr_of(simple_func));
    assert str_contains_c(simple_code, "int32_t add"), "Expected int32_t add function";
    
    println "\nTest 6: Process parameter types";
    assert equals_c(process_parameter_type(str("i32")), "int32_t"), "Expected i32 -> int32_t";
    assert equals_c(process_parameter_type(str("ref i32")), "int32_t*"), "Expected ref i32 -> int32_t*";
    assert equals_c(process_parameter_type(str("mut i32")), "int32_t"), "Expected mut i32 -> int32_t";
    assert equals_c(process_parameter_type(str("i32*")), "int32_t*"), "Expected i32* -> int32_t*";
    
    println "\nTest 7: Generate simple model";
    mut model_ast: ASTNode;
    model_ast.node_type = str("Model");
    model_ast.data.model_node.name = str("Point");
    model_ast.data.model_node.is_public = false;
    
    val field_names_list: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names_list, addr_of(model_arena), str("x"));
    StringList.push(field_names_list, addr_of(model_arena), str("y"));
    model_ast.data.model_node.field_names = field_names_list;
    
    val field_types_list: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types_list, addr_of(model_arena), str("i32"));
    StringList.push(field_types_list, addr_of(model_arena), str("i32"));
    model_ast.data.model_node.field_types = field_types_list;
    
    model_ast.children = nil;
    val model_code: string = generate_c(addr_of(model_ast));
    assert str_contains_c(model_code, "struct Point"), "Expected struct Point";
    assert str_contains_c(model_code, "int32_t x"), "Expected int32_t x field";
    assert str_contains_c(model_code, "int32_t y"), "Expected int32_t y field";
    
    println "\nTest 8: Generate model with different types";
    mut model2_ast: ASTNode;
    model2_ast.node_type = str("Model");
    model2_ast.data.model_node.name = str("Person");
    model2_ast.data.model_node.is_public = true;
    
    val field_names2: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names2, addr_of(model_arena), str("age"));
    StringList.push(field_names2, addr_of(model_arena), str("height"));
    StringList.push(field_names2, addr_of(model_arena), str("active"));
    model2_ast.data.model_node.field_names = field_names2;
    
    val field_types2: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types2, addr_of(model_arena), str("i32"));
    StringList.push(field_types2, addr_of(model_arena), str("f32"));
    StringList.push(field_types2, addr_of(model_arena), str("bool"));
    model2_ast.data.model_node.field_types = field_types2;
    
    model2_ast.children = nil;
    val model2_code: string = generate_c(addr_of(model2_ast));
    assert str_contains_c(model2_code, "struct Person"), "Expected struct Person";
    assert str_contains_c(model2_code, "int32_t age"), "Expected int32_t age field";
    assert str_contains_c(model2_code, "float height"), "Expected float height field";
    assert str_contains_c(model2_code, "bool active"), "Expected bool active field";
    
    println "\nTest 9: Model with array field";
    mut model3_ast: ASTNode;
    model3_ast.node_type = str("Model");
    model3_ast.data.model_node.name = str("Buffer");
    model3_ast.data.model_node.is_public = false;
    
    val field_names3: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names3, addr_of(model_arena), str("data"));
    model3_ast.data.model_node.field_names = field_names3;
    
    val field_types3: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types3, addr_of(model_arena), str("i32[100]"));
    model3_ast.data.model_node.field_types = field_types3;
    
    model3_ast.children = nil;
    val model3_code: string = generate_c(addr_of(model3_ast));
    assert str_contains_c(model3_code, "struct Buffer"), "Expected struct Buffer";
    assert str_contains_c(model3_code, "int32_t data[100]"), "Expected array field";
    
    println "\nTest 10: Model with pointer field";
    mut model4_ast: ASTNode;
    model4_ast.node_type = str("Model");
    model4_ast.data.model_node.name = str("Node");
    model4_ast.data.model_node.is_public = false;
    
    val field_names4: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names4, addr_of(model_arena), str("value"));
    StringList.push(field_names4, addr_of(model_arena), str("next"));
    model4_ast.data.model_node.field_names = field_names4;
    
    val field_types4: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types4, addr_of(model_arena), str("i32"));
    StringList.push(field_types4, addr_of(model_arena), str("ref Node"));
    model4_ast.data.model_node.field_types = field_types4;
    
    model4_ast.children = nil;
    val model4_code: string = generate_c(addr_of(model4_ast));
    assert str_contains_c(model4_code, "struct Node"), "Expected struct Node";
    assert str_contains_c(model4_code, "int32_t value"), "Expected value field";
    assert str_contains_c(model4_code, "Node* next"), "Expected pointer field";
    
    println "\nTest 11: Test helper functions";
    assert equals_c(map_axe_type_to_c(str("i32")), "int32_t"), "Expected i32 mapping";
    assert equals_c(map_axe_type_to_c(str("ref i64")), "int64_t*"), "Expected ref i64 mapping";
    assert equals_c(map_axe_type_to_c(str("mut f32")), "float"), "Expected mut f32 mapping";
    
    println "\nTest 12: Generate enum";
    mut enum_ast: ASTNode;
    enum_ast.node_type = str("Enum");
    enum_ast.data.enum_node.name = str("Color");
    
    val enum_values: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(enum_values, addr_of(model_arena), str("Red"));
    StringList.push(enum_values, addr_of(model_arena), str("Green"));
    StringList.push(enum_values, addr_of(model_arena), str("Blue"));
    enum_ast.data.enum_node.values = enum_values;
    
    enum_ast.children = nil;
    val enum_code: string = generate_c(addr_of(enum_ast));
    assert str_contains_c(enum_code, "typedef enum"), "Expected typedef enum";
    assert str_contains_c(enum_code, "Color_Red"), "Expected Color_Red value";
    assert str_contains_c(enum_code, "Color_Green"), "Expected Color_Green value";
    assert str_contains_c(enum_code, "Color_Blue"), "Expected Color_Blue value";
    assert str_contains_c(enum_code, "} Color;"), "Expected } Color;";

    println "\nTest 15: List types tracking and mapping";

    val list_map_val: string = map_axe_type_to_c(str("i32[999]"));
    assert str_contains_c(list_map_val, "__list_int32_t"), "Expected list(i32) mapping to a __list name";

    val list_map_ref: string = map_axe_type_to_c(str("ref i32[999]"));
    assert str_contains_c(list_map_ref, "__list_int32_t"), "Expected ref list(i32) mapping to a __list name";

    mut found_int32: bool = false;
    if g_list_elements != nil {
        val lstref: ref StringList = g_list_elements;
        mut k: i32 = 0;
        loop {
            if k >= lstref*.len {
                break;
            }
            val s: string = StringList.get(lstref, k);
            if equals_c(s, "int32_t") {
                found_int32 = true;
                break;
            }
            k = k + 1;
        }
    }

    assert found_int32, "Expected int32_t to be tracked as a list element type";

    println "\nTest 13: MemberAccess assignment";
    mut member_assign_ast: ASTNode;
    member_assign_ast.node_type = str("MemberAccess");
    member_assign_ast.data.member_access.object_name = str("obj");
    member_assign_ast.data.member_access.member_name = str("field");
    member_assign_ast.data.member_access.value = str("42");
    val member_assign_code: string = generate_c(addr_of(member_assign_ast));
    assert str_contains_c(member_assign_code, "obj.field = 42;"), "Expected obj.field = 42;";

    println "\nTest 14: MemberAccess read";
    mut member_read_ast: ASTNode;
    member_read_ast.node_type = str("MemberAccess");
    member_read_ast.data.member_access.object_name = str("obj");
    member_read_ast.data.member_access.member_name = str("field");
    member_read_ast.data.member_access.value = str("");
    val member_read_code: string = generate_c(addr_of(member_read_ast));
    assert str_contains_c(member_read_code, "obj.field;"), "Expected obj.field; for read";
}
