// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
// 
// Handles the rendering process.

use gstate;
use structs     (ASTNode);
use std.lists   (StringList, IntList);
use std.string;
use std.io;
use std.maps;
use std.errors;

/// Type mappings from Axe to C
mut g_type_mappings: StringStringMap;

/// Track reference depths for variables
mut g_ref_depths: StringIntMap;

/// Track mutability
mut g_is_mutable: StringBoolMap;

/// Function prefixes for imported modules
mut g_function_prefixes: StringStringMap;

/// Model name mappings
mut g_model_names: StringStringMap;

/// Enum names
mut g_enum_names: StringBoolMap;

/// Generated typedefs to avoid duplicates
mut g_generated_typedefs: StringBoolMap;

/// Generated functions to avoid duplicates
mut g_generated_functions: StringBoolMap;

/// Field types for models
mut g_field_types: StringStringMap;

/// Variable types
mut g_var_types: StringStringMap;

/// Track discovered list element types used in generated code (for C list helpers)
mut g_list_element_types: StringBoolMap;

/// Ordered list of discovered element type strings (for deterministic emission)
mut g_list_elements: ref StringList;

/// Global external headers (from use external statements)
mut g_global_external_headers: ref StringList;

/// Windows-specific external headers
mut g_windows_external_headers: ref StringList;

/// POSIX-specific external headers
mut g_posix_external_headers: ref StringList;

/// Initialize renderer globals.
///
/// This must be called before using the renderer at all.
pub def initialize_renderer() {
    mut arena: Arena = Arena.create(1024 * 1024 * 100);
    
    g_type_mappings = deref(StringStringMap.create(addr(arena), 128));
    g_ref_depths = deref(StringIntMap.create(addr(arena), 128));
    g_is_mutable = deref(StringBoolMap.create(addr(arena), 128));
    g_function_prefixes = deref(StringStringMap.create(addr(arena), 128));
    g_model_names = deref(StringStringMap.create(addr(arena), 128));
    g_enum_names = deref(StringBoolMap.create(addr(arena), 128));
    g_generated_typedefs = deref(StringBoolMap.create(addr(arena), 128));
    g_generated_functions = deref(StringBoolMap.create(addr(arena), 128));
    g_field_types = deref(StringStringMap.create(addr(arena), 128));
    g_var_types = deref(StringStringMap.create(addr(arena), 128));
    g_list_element_types = deref(StringBoolMap.create(addr(arena), 128));
    g_list_elements = StringList.create(addr(arena), 64);
    g_global_external_headers = StringList.create(addr(arena), 32);
    g_windows_external_headers = StringList.create(addr(arena), 32);
    g_posix_external_headers = StringList.create(addr(arena), 32);
    
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i8"), str("int8_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u8"), str("uint8_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i16"), str("int16_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u16"), str("uint16_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i32"), str("int32_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u32"), str("uint32_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i64"), str("int64_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u64"), str("uint64_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("isize"), str("intptr_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("usize"), str("uintptr_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("f32"), str("float"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("f64"), str("double"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("bool"), str("bool"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("char"), str("char"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("rchar"), str("char*"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("byte"), str("uint8_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("ptrdiff"), str("isize"));
}

/// Collect external imports from AST recursively.
/// current_platform is "" for global, "windows" or "posix" for platform-specific.
def collect_external_imports(node: ref ASTNode, current_platform: string, arena: ref Arena) {
    if node == nil {
        return;
    }
    
    if equals_c(node.node_type, "ExternalImport") {
        val header: string = node.data.external_import.header_file;
        
        if equals_c(current_platform, "") {
            // Global header
            if !StringList.contains(g_global_external_headers, header) {
                StringList.push(g_global_external_headers, arena, header);
            }
        } elif equals_c(current_platform, "windows") {
            if !StringList.contains(g_windows_external_headers, header) {
                StringList.push(g_windows_external_headers, arena, header);
            }
        } elif equals_c(current_platform, "posix") {
            if !StringList.contains(g_posix_external_headers, header) {
                StringList.push(g_posix_external_headers, arena, header);
            }
        }
        return;
    }
    
    if equals_c(node.node_type, "Platform") {
        val platform_name: string = node.data.platform_node.platform_name;
        // Recurse into platform children with platform context
        if node.children != nil {
            val children: ref list(ASTNode) = node.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                collect_external_imports(addr(children.data[i]), platform_name, arena);
                i = i + 1;
            }
        }
        return;
    }
    
    // Recurse into all children with current platform context
    if node.children != nil {
        val children: ref list(ASTNode) = node.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            collect_external_imports(addr(children.data[i]), current_platform, arena);
            i = i + 1;
        }
    }
}

/// Extract the base type name from a field type string.
/// For example: "ref string" -> "string", "i32*" -> "i32", "list(Token)" -> "Token"
def get_base_type_from_field(field_type: string): string {
    mut t: string = strip(field_type);
    
    if has_prefix(t, str("mut ")) {
        t = strip(substr(t, 4, str_len(t) - 4));
    }
    
    loop {
        if !has_prefix(t, str("ref ")) {
            break;
        }
        t = strip(substr(t, 4, str_len(t) - 4));
    }
    
    loop {
        if !has_prefix(t, str("& ")) {
            break;
        }
        t = strip(substr(t, 2, str_len(t) - 2));
    }
    
    if has_prefix(t, str("list(")) {
        mut paren_pos: i32 = 5;
        mut depth: i32 = 1;
        loop {
            if paren_pos >= str_len(t) {
                break;
            }
            val ch: char = get_char(t, paren_pos);
            if ch == '(' {
                depth = depth + 1;
            } elif ch == ')' {
                depth = depth - 1;
                if depth == 0 {
                    break;
                }
            }
            paren_pos = paren_pos + 1;
        }
        t = strip(substr(t, 5, paren_pos - 5));
    }
    
    mut bracket_pos: i32 = find_substr(t, str("["));
    if bracket_pos >= 0 {
        t = strip(substr(t, 0, bracket_pos));
    }
    
    loop {
        if str_len(t) == 0 {
            break;
        }
        if get_char(t, str_len(t) - 1) != '*' {
            break;
        }
        t = strip(substr(t, 0, str_len(t) - 1));
    }
    
    return t;
}

/// Remove stray spaces around '.' in numeric C literals.
def normalize_numeric_dots(s: string): string {
    mut out: string = str("");
    val n: i32 = str_len(s);
    mut i: i32 = 0;

    loop {
        if i >= n {
            break;
        }

        val ch: char = get_char(s, i);

        if ch >= '0' and ch <= '9' and i + 1 < n and get_char(s, i + 1) == '.' {
            out = concat_chr(out, ch);
            out = concat_chr(out, '.');

            mut j: i32 = i + 2;
            loop {
                if j >= n {
                    break;
                }
                val cj: char = get_char(s, j);
                if cj != ' ' and cj != '\t' and cj != '\n' {
                    break;
                }
                j++;
            }

            if j < n and get_char(s, j) >= '0' and get_char(s, j) <= '9' {
                out = concat_chr(out, get_char(s, j));
                i = j + 1;
                continue;
            } else {
                i = j;
                continue;
            }
        }

        out = concat_chr(out, ch);
        i++;
    }

    return out;
}

/// Rewrite member access on pointer-typed variables...
def rewrite_pointer_member_accesses(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i++;
            continue;
        }

        if !in_string and is_ident_start(ch) {
            mut base: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                base = concat_chr(base, cj);
                j++;
            }

            mut k: i32 = j;
            loop {
                if k >= str_len(expr) {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k++;
            }

            if k < str_len(expr) and get_char(expr, k) == '.' {
                val start_slice: i32 = i;

                mut p: i32 = k + 1;
                loop {
                    if p >= str_len(expr) {
                        break;
                    }
                    val ws2: char = get_char(expr, p);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    p++;
                }

                mut member: string = str("");
                mut m: i32 = p;
                if m < str_len(expr) and is_ident_start(get_char(expr, m)) {
                    loop {
                        if m >= str_len(expr) {
                            break;
                        }
                        val cm: char = get_char(expr, m);
                        if !is_token_char(cm) {
                            break;
                        }
                        member = concat_chr(member, cm);
                        m++;
                    }
                }

                if str_len(member) > 0 {
                    val trimmed_base: string = strip(base);
                    mut is_pointer: bool = false;

                    if StringStringMap.contains(addr(g_var_types), trimmed_base) {
                        val raw_type: string = StringStringMap.get(addr(g_var_types), trimmed_base);
                        mut t: string = strip(raw_type);

                        if has_prefix(t, str("mut ")) {
                            t = strip(substr(t, 4, str_len(t) - 4));
                        }

                        if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                            is_pointer = true;
                        }
                    }

                    if is_pointer {
                        out = concat(out, trimmed_base);
                        out = concat(out, str("->"));
                        out = concat(out, member);
                        i = m;
                        continue;
                    }

                    // Not a pointer: fall through and emit original slice
                    val original: string = substring_se(expr, start_slice, m);
                    out = concat(out, original);
                    i = m;
                    continue;
                }
            }

            // Not a member access; emit the identifier as-is
            out = concat(out, base);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i++;
    }

    return out;
}

/// Register a single function name in g_function_prefixes
def register_function_prefix(full_name: string) {
    mut last_sep: i32 = -1;
    mut j: i32 = 0;
    val n: i32 = str_len(full_name);
    loop {
        if j + 1 >= n {
            break;
        }
        val c1: char = get_char(full_name, j);
        val c2: char = get_char(full_name, j + 1);
        if c1 == '_' and c2 == '_' {
            last_sep = j;
        }
        j = j + 1;
    }

    if last_sep >= 0 and last_sep + 2 < n {
        val short_name: string = substring_se(full_name, last_sep + 2, n);

        if str_len(short_name) > 0 {
            if !StringStringMap.contains(addr(g_function_prefixes), short_name) {
                mut arena: Arena = Arena.create(1256);
                StringStringMap.set(addr(g_function_prefixes), addr(arena), short_name, full_name);
            }
        }
        
        mut second_last_sep: i32 = -1;
        mut k: i32 = 0;
        loop {
            if k >= last_sep {
                break;
            }
            val c1b: char = get_char(full_name, k);
            val c2b: char = get_char(full_name, k + 1);
            if c1b == '_' and c2b == '_' {
                second_last_sep = k;
            }
            k = k + 1;
        }
        
        if second_last_sep >= 0 and second_last_sep + 2 < n {
            val partial_name: string = substring_se(full_name, second_last_sep + 2, n);
            if str_len(partial_name) > 0 {
                if !StringStringMap.contains(addr(g_function_prefixes), partial_name) {
                    mut arena2: Arena = Arena.create(1256);
                    StringStringMap.set(addr(g_function_prefixes), addr(arena2), partial_name, full_name);
                }
            }
        }
    }
}

/// Recursively collect function prefixes from an AST node
def collect_function_prefixes(node: ref ASTNode) {
    if node == nil {
        return;
    }
    
    if equals_c(node.node_type, "Function") {
        register_function_prefix(node.data.function.name);
    }
    
    if node.children != nil {
        val children: ref list(ASTNode) = node.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            collect_function_prefixes(addr(children.data[i]));
            i = i + 1;
        }
    }
}

/// Build the g_function_prefixes map from the AST
def build_function_prefixes(ast: ref ASTNode) {
    StringStringMap.clear(addr(g_function_prefixes));
    collect_function_prefixes(ast);
}

/// Map Axe type to C type
def map_type(axe_type: string): string {
    if StringStringMap.contains(addr(g_type_mappings), axe_type) {
        return StringStringMap.get(addr(g_type_mappings), axe_type);
    }
    return axe_type;
}

/// Get canonical model C name from g_model_names
def canonical_model_c_name(name: string): string {
    if StringStringMap.contains(addr(g_model_names), name) {
        return StringStringMap.get(addr(g_model_names), name);
    }
    return str("");
}

/// Map Axe type to C type (comprehensive version for model fields)
def map_axe_type_to_c(axe_type: string): string {
    mut result: string = axe_type;
    
    if has_prefix(result, str("mut ")) {
        result = strip(substr(result, 4, str_len(result) - 4));
        return map_axe_type_to_c(result);
    }
    
    if has_suffix(result, str("[999]")) {
        val element_type: string = strip(substring_se(result, 0, str_len(result) - 5));
        if has_prefix(element_type, str("ref ")) {
            val base_elem: string = strip(substr(element_type, 4, str_len(element_type) - 4));
            val mapped_elem: string = map_axe_type_to_c(base_elem);
            add_list_element(mapped_elem);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t*"));
            return struct_name;
        } else {
            val mapped_elem: string = map_axe_type_to_c(element_type);
            add_list_element(mapped_elem);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t"));
            return struct_name;
        }
    }
    
    if has_prefix(result, str("ref ")) {
        val base_type: string = strip(substr(result, 4, str_len(result) - 4));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    if has_suffix(result, str("*")) {
        val base_type: string = strip(substring_se(result, 0, str_len(result) - 1));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    val br_idx: i32 = find_char_from(result, '[', 0);
    if br_idx >= 0 and find_char_from(result, ']', br_idx) >= 0 {
        val base_raw: string = strip(substring_se(result, 0, br_idx));
        val suffix: string = substring_se(result, br_idx, str_len(result));
        if str_len(base_raw) > 0 {
            val mapped_base2: string = map_axe_type_to_c(base_raw);
            return concat(mapped_base2, suffix);
        }
    }
    
    if StringStringMap.contains(addr(g_type_mappings), result) {
        return StringStringMap.get(addr(g_type_mappings), result);
    }
    
    if StringStringMap.contains(addr(g_model_names), result) {
        return StringStringMap.get(addr(g_model_names), result);
    }
    
    return result;
}

/// Sanitize a C element type string to be used as part of a generated list type name
def sanitize_list_element_name(c_elem: string): string {
    mut n: string = c_elem;
    mut out: string = str("");
    mut i: i32 = 0;
    loop {
        if i >= str_len(n) {
            break;
        }
        val ch: char = get_char(n, i);
        if ch == '*' {
            out = concat(out, str("_ptr"));
        } elif ch == ' ' {
            out = concat(out, str("_"));
        } else {
            out = concat_chr(out, ch);
        }
        i = i + 1;
    }
    return out;
}

/// Collapse all duplicate segments in the specified string expression.
def collapse_duplicate_segments(s: string): string {
    mut current: string = s;
    loop {
        val next: string = collapse_duplicate_segments_once(current);
        if compare(next, current) == 0 {
            return current;
        }
        current = next;
    }
}

/// Rewrite member access operators from `.` to `->` when the base identifier
/// is known to be a pointer type (ref or pointer) according to g_var_types.
/// For example, if `lst` has type `ref IntList`, then `lst.len` becomes `lst->len`.
def rewrite_ref_member_access(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i++;
            continue;
        }

        if !in_string and is_ident_start(ch) {
            mut ident: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                ident = concat_chr(ident, cj);
                j++;
            }

            mut k: i32 = j;
            loop {
                if k >= str_len(expr) {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k++;
            }

            if k < str_len(expr) and get_char(expr, k) == '.' {
                mut is_arrow: bool = false;
                if k + 1 < str_len(expr) and get_char(expr, k + 1) == '>' {
                    is_arrow = true;
                }

                if !is_arrow {
                    mut is_ptr_type: bool = false;
                    if StringStringMap.contains(addr(g_var_types), ident) {
                        val var_type: string = StringStringMap.get(addr(g_var_types), ident);
                        if has_prefix(var_type, str("ref ")) or has_suffix(var_type, str("*")) {
                            is_ptr_type = true;
                        }
                    }

                    if is_ptr_type {
                        out = concat(out, ident);
                        out = concat(out, str("->"));
                        i = k + 1;
                        continue;
                    }
                }
            }

            out = concat(out, ident);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i++;
    }

    return out;
}

/// Rewrite method-style calls of the form `Base.method(...)` into a single
/// C identifier using the canonical model name when available. 
/// 
/// For example:
///
///   Arena.alloc_array(arena, ...)
///
/// Becomes:
///
///   std__arena__Arena_Arena__alloc_array(arena, ...)
def rewrite_method_calls(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i = i + 1;
            continue;
        }

        if !in_string and is_ident_start(ch) {
            mut base: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                base = concat_chr(base, cj);
                j = j + 1;
            }

            mut k: i32 = j;
            loop {
                if k >= str_len(expr) {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }

            if k < str_len(expr) and get_char(expr, k) == '.' {
                k = k + 1;

                loop {
                    if k >= str_len(expr) {
                        break;
                    }
                    val ws2: char = get_char(expr, k);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                mut method: string = str("");
                mut m: i32 = k;
                if m < str_len(expr) and is_ident_start(get_char(expr, m)) {
                    loop {
                        if m >= str_len(expr) {
                            break;
                        }
                        val cm: char = get_char(expr, m);
                        if !is_token_char(cm) {
                            break;
                        }
                        method = concat_chr(method, cm);
                        m = m + 1;
                    }
                }

                mut p: i32 = m;
                loop {
                    if p >= str_len(expr) {
                        break;
                    }
                    val ws3: char = get_char(expr, p);
                    if ws3 != ' ' and ws3 != '\t' and ws3 != '\n' {
                        break;
                    }
                    p = p + 1;
                }

                if str_len(method) > 0 and p < str_len(expr) and get_char(expr, p) == '(' {
                    mut fixed_method: string = method;
                    mut inner_sep: i32 = -1;
                    mut mi: i32 = 0;
                    val mlen: i32 = str_len(method);
                    loop {
                        if mi + 1 >= mlen {
                            break;
                        }
                        val mc1: char = get_char(method, mi);
                        val mc2: char = get_char(method, mi + 1);
                        if mc1 == '_' and mc2 == '_' {
                            inner_sep = mi;
                            break;
                        }
                        mi++;
                    }

                    if inner_sep > 0 {
                        val inner_model: string = substring_se(method, 0, inner_sep);
                        mut base_tail: string = base;
                        mut bsep: i32 = -1;
                        mut bi: i32 = 0;
                        val blen: i32 = str_len(base);

                        loop {
                            if bi + 1 >= blen {
                                break;
                            }
                            val bc1: char = get_char(base, bi);
                            val bc2: char = get_char(base, bi + 1);
                            if bc1 == '_' and bc2 == '_' {
                                bsep = bi;
                            }
                            bi = bi + 1;
                        }
                        if bsep >= 0 and bsep + 2 < blen {
                            base_tail = substring_se(base, bsep + 2, blen);
                        }

                        if compare(inner_model, base) == 0 or compare(inner_model, base_tail) == 0 {
                            fixed_method = substring_se(method, inner_sep + 2, mlen);
                        }
                    }

                    val canon: string = canonical_model_c_name(base);
                    mut full_name: string = str("");
                    if str_len(canon) > 0 {
                        full_name = canon;
                    } else {
                        full_name = base;
                    }
                    full_name = concat(full_name, str("__"));
                    full_name = concat(full_name, fixed_method);
                    out = concat(out, full_name);
                    i = m;
                    continue;
                }
            }

            out = concat(out, base);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i = i + 1;
    }

    return out;
}

/// Rewrite function calls to use their full module-prefixed names.
/// For example, `Arena__alloc(...)` becomes `std__arena__Arena__alloc(...)`
/// using the g_function_prefixes map.
def rewrite_function_prefixes(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i++;
            continue;
        }

        val is_start: bool = is_ident_start(ch);

        if !in_string and is_start {
            mut func_name: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                func_name = concat_chr(func_name, cj);
                j++;
            }

            mut k: i32 = j;
            loop {
                if k >= str_len(expr) {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k++;
            }

            if k < str_len(expr) and get_char(expr, k) == '(' {
                if StringStringMap.contains(addr(g_function_prefixes), func_name) {
                    val full_name: string = StringStringMap.get(addr(g_function_prefixes), func_name);
                    out = concat(out, full_name);
                    i = j;
                    continue;
                }
            }

            out = concat(out, func_name);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i++;
    }

    return out;
}

/// Rewrite sizeof argument types so that constructs like `sizeof(IntList)`
/// or `sizeof ( i32 )` use the mapped C type (e.g. `sizeof(std__lists__IntList)`.
def rewrite_sizeof_types(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i = i + 1;
            continue;
        }

        if !in_string and is_ident_start(ch) {
            mut ident: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                ident = concat_chr(ident, cj);
                j++;
            }

            if str_len(ident) == 6 and get_char(ident, 0) == 's' and get_char(ident, 1) == 'i' 
                and get_char(ident, 2) == 'z' and get_char(ident, 3) == 'e' and get_char(ident, 4) == 'o' 
                and get_char(ident, 5) == 'f' {
                out = concat(out, ident);

                mut k: i32 = j;
                loop {
                    if k >= str_len(expr) {
                        break;
                    }
                    val ws: char = get_char(expr, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k++;
                }

                if k < str_len(expr) and get_char(expr, k) == '(' {
                    out = concat_chr(out, '(');
                    k++;

                    mut start_type: i32 = k;
                    loop {
                        if start_type >= str_len(expr) {
                            break;
                        }
                        val ws2: char = get_char(expr, start_type);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        start_type = start_type + 1;
                    }

                    mut end_type: i32 = start_type;
                    loop {
                        if end_type >= str_len(expr) {
                            break;
                        }
                        val ct: char = get_char(expr, end_type);
                        if ct == ')' {
                            break;
                        }
                        end_type = end_type + 1;
                    }

                    if end_type <= str_len(expr) {
                        val raw_type: string = strip(substring_se(expr, start_type, end_type));
                        if str_len(raw_type) > 0 {
                            val mapped: string = map_axe_type_to_c(raw_type);
                            out = concat(out, mapped);
                        }

                        if end_type < str_len(expr) and get_char(expr, end_type) == ')' {
                            out = concat(out, str(")"));
                            end_type = end_type + 1;
                        }

                        i = end_type;
                        continue;
                    }
                }

                i = j;
                continue;
            }

            out = concat(out, ident);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i++;
    }

    return out;
}

/// Rewrite Axe-style cast expressions of the form
///   `cast [ T ] ( expr )`
/// into  C-style casts using the mapped C type, e.g.:
///   `(int32_t)(expr)`
def rewrite_casts(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i = i + 1;
            continue;
        }

        if !in_string and is_ident_start(ch) {
            mut ident: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                ident = concat_chr(ident, cj);
                j = j + 1;
            }

            if str_len(ident) == 4 and get_char(ident, 0) == 'c' and get_char(ident, 1) == 'a' and get_char(ident, 2) == 's' and get_char(ident, 3) == 't' {
                mut k: i32 = j;
                loop {
                    if k >= str_len(expr) {
                        break;
                    }
                    val ws: char = get_char(expr, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(expr) and get_char(expr, k) == '[' {
                    mut t_start: i32 = k + 1;
                    mut t_end: i32 = -1;
                    mut in_str_type: bool = false;
                    mut p: i32 = t_start;
                    loop {
                        if p >= str_len(expr) {
                            break;
                        }
                        val ct: char = get_char(expr, p);
                        if ct == '"' and (p == 0 or get_char(expr, p - 1) != '\\') {
                            in_str_type = !in_str_type;
                        }
                        if !in_str_type and ct == ']' {
                            t_end = p;
                            break;
                        }
                        p = p + 1;
                    }

                    if t_end > t_start {
                        val type_raw: string = strip(substring_se(expr, t_start, t_end));

                        mut a: i32 = t_end + 1;
                        loop {
                            if a >= str_len(expr) {
                                break;
                            }
                            val wa: char = get_char(expr, a);
                            if wa != ' ' and wa != '\t' and wa != '\n' {
                                break;
                            }
                            a = a + 1;
                        }

                        if a < str_len(expr) and get_char(expr, a) == '(' {
                            mut depth: i32 = 0;
                            mut in_str_paren: bool = false;
                            mut q: i32 = a;
                            mut end_paren: i32 = -1;
                            loop {
                                if q >= str_len(expr) {
                                    break;
                                }
                                val cp: char = get_char(expr, q);
                                if cp == '"' and (q == 0 or get_char(expr, q - 1) != '\\') {
                                    in_str_paren = !in_str_paren;
                                }
                                if !in_str_paren {
                                    if cp == '(' {
                                        depth = depth + 1;
                                    } elif cp == ')' {
                                        depth = depth - 1;
                                        if depth == 0 {
                                            end_paren = q;
                                            break;
                                        }
                                    }
                                }
                                q = q + 1;
                            }

                            if end_paren >= 0 {
                                val mapped_type: string = map_axe_type_to_c(type_raw);
                                mut repl: string = str("(");

                                repl = concat(repl, mapped_type);
                                repl = concat(repl, str(")"));

                                val inner_full: string = substring_se(expr, a, end_paren + 1);
                                repl = concat(repl, inner_full);

                                out = concat(out, repl);
                                i = end_paren + 1;

                                continue;
                            }
                        }
                    }
                }

                out = concat(out, ident);
                i = j;
                continue;
            }

            out = concat(out, ident);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i = i + 1;
    }

    return out;
}

/// Add a list element type to tracking structures (map + ordered list)
def add_list_element(c_elem: string) {
    if str_len(c_elem) == 0 {
        return;
    }

    if StringBoolMap.contains(addr(g_list_element_types), c_elem) {
        return;
    }

    mut arena: Arena = Arena.create(256);
    StringBoolMap.set(addr(g_list_element_types), addr(arena), c_elem, true);

    if g_list_elements != nil {
        val listref: ref StringList = g_list_elements;
        mut i: i32 = 0;
        loop {
            if i >= listref*.len {
                break;
            }
            val it: string = StringList.get(listref, i);
            if compare(it, c_elem) == 0 {
                return;
            }
            i = i + 1;
        }
        StringList.push(g_list_elements, addr(arena), c_elem);
    }
}

/// Recursively scan AST for occurrences of list types (sugar: [999]) and register them
def scan_for_list_types(node: ref ASTNode) {
    if node == nil {
        return;
    }

    if equals_c(node.node_type, "Declaration") {
        val tname: string = node.data.declaration.type_name;
        if str_len(tname) > 0 {
            val br: i32 = find_char_from(tname, '[', 0);
            if br >= 0 {
                val suffix: string = substring_se(tname, br, str_len(tname));
                if equals_c(suffix, "[999]") {
                    mut element: string = strip(substring_se(tname, 0, br));
                    if has_prefix(element, str("ref ")) {
                        element = strip(substr(element, 4, str_len(element) - 4));
                    }
                    val mapped: string = map_axe_type_to_c(element);
                    add_list_element(mapped);
                }
            }
        }
    }

    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut idx: i32 = 0;
        loop {
            if idx >= len(deref(chs)) {
                break;
            }
            scan_for_list_types(addr(chs.data[idx]));
            idx = idx + 1;
        }
    }
}

/// Format model field type with proper struct prefix
def format_model_field_type(field_type: string): string {
    mut trimmed: string = strip(field_type);
    mut qualifiers: string = str("");
    
    loop {
        if !has_prefix(trimmed, str("const ")) {
            break;
        }
        qualifiers = concat(qualifiers, str("const "));
        trimmed = strip(substr(trimmed, 6, str_len(trimmed) - 6));
    }
    
    mut had_struct_prefix: bool = false;
    if has_prefix(trimmed, str("struct ")) {
        had_struct_prefix = true;
        trimmed = strip(substr(trimmed, 7, str_len(trimmed) - 7));
    }
    
    mut pointer_suffix: string = str("");
    loop {
        val len: i32 = str_len(trimmed);
        if len == 0 {
            break;
        }
        val last_char: char = get_char(trimmed, len - 1);
        if last_char != '*' {
            break;
        }
        pointer_suffix = concat(pointer_suffix, str("*"));
        trimmed = strip(substring_se(trimmed, 0, len - 1));
    }
    
    val model_name: string = canonical_model_c_name(trimmed);
    if str_len(model_name) > 0 {
        if StringBoolMap.contains(addr(g_enum_names), model_name) {
            trimmed = model_name;
        } else {
            trimmed = concat(str("struct "), model_name);
        }
    } else {
        if had_struct_prefix {
            trimmed = concat(str("struct "), trimmed);
        }
    }
    
    mut final_result: string = qualifiers;
    final_result = concat(final_result, trimmed);
    final_result = concat(final_result, pointer_suffix);
    return final_result;
}

/// Process parameter type (handle ref, mut, pointers, etc.)
def process_parameter_type(param_type: string): string {
    // Delegate to the comprehensive Axe->C mapper so that 'mut', repeated
    // 'ref' prefixes, list[999] sugar, and pointer suffixes are handled
    // consistently. Examples:
    //
    //   'char'          -> 'char'
    //   'ref char'      -> 'char*'
    //   'ref ref char'  -> 'char**'
    //   'ref MyModel*'  -> 'struct ...* *'

    mut result: string = strip(param_type);
    return map_axe_type_to_c(result);
}

def int_to_ascii(n: i32): string {
    if n == 0 {
        return str("0");
    }

    mut neg: bool = false;
    mut v: i32 = n;
    if v < 0 {
        neg = true;
        v = -v;
    }

    mut rev: string = str("");
    loop {
        if v == 0 {
            break;
        }
        val digit: i32 = v mod 10;
        rev = concat_chr(rev, cast[char]('0' + digit));
        v = v / 10;
    }

    mut out: string = str("");
    mut i: i32 = str_len(rev) - 1;
    loop {
        if i < 0 {
            break;
        }
        out = concat_chr(out, get_char(rev, i));
        i = i - 1;
    }

    if neg {
        out = concat(str("-"), out);
    }

    return out;
}

def get_type_format_specifier(var_type: string): string {
    mut t: string = strip(var_type);

    if equals_c(t, "int32_t") or has_suffix(t, str("int32_t")) {
        return str("%d");
    }
    if equals_c(t, "uint32_t") or has_suffix(t, str("uint32_t")) {
        return str("%u");
    }
    if equals_c(t, "int64_t") or has_suffix(t, str("int64_t")) {
        return str("%lld");
    }
    if equals_c(t, "uint64_t") or has_suffix(t, str("uint64_t")) {
        return str("%llu");
    }
    if equals_c(t, "float") or has_suffix(t, str("float")) {
        return str("%f");
    }
    if equals_c(t, "double") or has_suffix(t, str("double")) {
        return str("%f");
    }
    if equals_c(t, "char") or has_suffix(t, str("char")) {
        return str("%c");
    }

    return str("%d");
}

def lookup_expression_type(expr: string): string {
    mut e: string = strip(expr);

    if StringStringMap.contains(addr(g_var_types), e) {
        return StringStringMap.get(addr(g_var_types), e);
    }

    if str_len(e) >= 2 and get_char(e, 0) == '"' and get_char(e, str_len(e) - 1) == '"' {
        return str("string");
    }

    if str_len(e) >= 2 and get_char(e, 0) == '\'' and get_char(e, str_len(e) - 1) == '\'' {
        return str("char");
    }

    if str_len(e) > 0 {
        val c0: char = get_char(e, 0);
        if c0 >= '0' and c0 <= '9' {
            if find_char_from(e, '.', 0) >= 0 {
                return str("f64");
            }
            return str("i32");
        }
    }

    return str("i32");
}

def process_interpolated_string(interp_content: string, return_struct: bool): string {
    mut parts: list(string);
    mut expressions: list(string);

    mut pos: i32 = 0;
    mut current_part: string = str("");

    loop {
        if pos >= str_len(interp_content) {
            break;
        }

        val ch: char = get_char(interp_content, pos);

        if ch == '{' and (pos == 0 or get_char(interp_content, pos - 1) != '\\') {
            if pos > 0 and get_char(interp_content, pos - 1) == '$' and str_len(current_part) > 0 {
                current_part = substring_se(current_part, 0, str_len(current_part) - 1);
            }

            append(parts, current_part);
            current_part = str("");

            mut brace_start: i32 = pos + 1;
            mut brace_depth: i32 = 1;
            mut brace_end: i32 = brace_start;

            loop {
                if brace_end >= str_len(interp_content) or brace_depth == 0 {
                    break;
                }
                val cc: char = get_char(interp_content, brace_end);
                if cc == '{' {
                    brace_depth = brace_depth + 1;
                } elif cc == '}' {
                    brace_depth = brace_depth - 1;
                }
                brace_end = brace_end + 1;
            }

            if brace_depth != 0 {
                enforce_raw(false, "Unmatched braces in interpolated string");
            }

            val expr: string = strip(substring_se(interp_content, brace_start, brace_end - 1));
            append(expressions, expr);
            pos = brace_end;
            continue;
        }

        current_part = concat_chr(current_part, ch);
        pos = pos + 1;
    }

    append(parts, current_part);

    if len(parts) == 0 {
        return str("");
    }

    if len(expressions) == 0 {
        mut q: string = str("\"");
        q = concat(q, interp_content);
        q = concat(q, str("\""));
        return q;
    }

    mut code: string = str("({ size_t _axe_interp_len = 0");

    mut i_part_size: i32 = 0;
    loop {
        if i_part_size >= len(parts) {
            break;
        }

        val part_sz: string = parts.data[i_part_size];
        if str_len(part_sz) > 0 {
            mut escaped_sz: string = replace_all(part_sz, str("\\"), str("\\\\"));
            escaped_sz = replace_all(escaped_sz, str("\""), str("\\\""));
            escaped_sz = replace_all(escaped_sz, str("\n"), str("\\n"));
            escaped_sz = replace_all(escaped_sz, str("\t"), str("\\t"));

            code = concat(code, str(" + sizeof(\""));
            code = concat(code, escaped_sz);
            code = concat(code, str("\") - 1"));
        }

        if i_part_size < len(expressions) {
            code = concat(code, str(" + 32"));
        }

        i_part_size = i_part_size + 1;
    }

    code = concat(code, str("; char* _axe_interp = (char*)malloc(_axe_interp_len + 1); char* _axe_interp_p = _axe_interp; "));

    mut i_part: i32 = 0;
    loop {
        if i_part >= len(parts) {
            break;
        }

        val part: string = parts.data[i_part];
        if str_len(part) > 0 {
            mut escaped: string = replace_all(part, str("\\"), str("\\\\"));
            escaped = replace_all(escaped, str("\""), str("\\\""));
            escaped = replace_all(escaped, str("\n"), str("\\n"));
            escaped = replace_all(escaped, str("\t"), str("\\t"));

            code = concat(code, str("memcpy(_axe_interp_p, \""));
            code = concat(code, escaped);
            code = concat(code, str("\", sizeof(\""));
            code = concat(code, escaped);
            code = concat(code, str("\") - 1); _axe_interp_p += sizeof(\""));
            code = concat(code, escaped);
            code = concat(code, str("\") - 1; "));
        }

        if i_part < len(expressions) {
            val e: string = expressions.data[i_part];
            val etype: string = lookup_expression_type(e);
            val processed_e: string = process_expression(e);

            if str_len(etype) > 0 and (equals_c(etype, "string") or has_suffix(etype, str("_string")) or equals_c(etype, "std__string__string")) {
                code = concat(code, str("{ struct std__string__string _s = "));
                code = concat(code, processed_e);
                code = concat(code, str("; memcpy(_axe_interp_p, _s.data, _s.len); _axe_interp_p += _s.len; } "));
            } else {
                code = concat(code, str("{ int _len = snprintf(_axe_interp_p, 32, \""));
                code = concat(code, get_type_format_specifier(etype));
                code = concat(code, str("\", "));
                code = concat(code, processed_e);
                code = concat(code, str("); _axe_interp_p += _len; } "));
            }
        }

        i_part = i_part + 1;
    }

    code = concat(code, str("*_axe_interp_p = '\\0'; "));

    if return_struct {
        code = concat(code, str("struct std__string__string _sret = {0}; _sret.data = _axe_interp; _sret.len = _axe_interp_p - _axe_interp; _sret.cap = _axe_interp_len + 1; _sret; })"));
    } else {
        code = concat(code, str("_axe_interp; })"));
    }

    return code;
}

/// Process an expression string for C interop and pointer sugar
def is_token_char(c: char): bool {
    val c_code: i32 = cast[i32](c);
    // 'a' = 97, 'z' = 122, 'A' = 65, 'Z' = 90, '0' = 48, '9' = 57
    if c_code >= 97 and c_code <= 122 {
        return true;
    }
    if c_code >= 65 and c_code <= 90 {
        return true;
    }
    if c_code >= 48 and c_code <= 57 {
        return true;
    }
    if c == '_' {
        return true;
    }
    return false;
}

/// Check if a character can start an identifier (letter or underscore)
def is_ident_start(c: char): bool {
    val c_code: i32 = cast[i32](c);
    if c_code >= 97 and c_code <= 122 {
        return true;
    }
    if c_code >= 65 and c_code <= 90 {
        return true;
    }
    if c == '_' {
        return true;
    }
    return false;
}

def c_prefix_end_index(s: string): i32 {
    if str_len(s) < 2 {
        return -1;
    }

    if get_char(s, 0) != 'C' {
        return -1;
    }

    mut i: i32 = 1;
    loop {
        if i >= str_len(s) {
            return -1;
        }
        val ch: char = get_char(s, i);
        if ch != ' ' and ch != '\t' and ch != '\n' {
            break;
        }
        i = i + 1;
    }

    if get_char(s, i) != '.' {
        return -1;
    }

    i = i + 1;
    loop {
        if i >= str_len(s) {
            break;
        }
        val ch: char = get_char(s, i);
        if ch != ' ' and ch != '\t' and ch != '\n' {
            break;
        }
        i = i + 1;
    }

    return i;
}

/// Collapse duplicated '__segment__segment' patterns in identifiers.
/// For example, 'std__string__string__create' stays the same, but
/// 'std__string__string_string__create' becomes 'std__string__string__create'.
def collapse_duplicate_segments_once(s: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    val n: i32 = str_len(s);

    loop {
        if i >= n {
            break;
        }

        if i + 2 < n and get_char(s, i) == '_' and get_char(s, i + 1) == '_' {
            mut j: i32 = i + 2;
            mut seg1: string = str("");
            loop {
                if j >= n {
                    break;
                }
                val ch: char = get_char(s, j);
                if ch == '_' {
                    break;
                }
                seg1 = concat_chr(seg1, ch);
                j = j + 1;
            }

            if str_len(seg1) > 0 {
                if j + 2 < n and get_char(s, j) == '_' and get_char(s, j + 1) == '_' {
                    mut k: i32 = j + 2;
                    mut seg2: string = str("");
                    loop {
                        if k >= n {
                            break;
                        }
                        val ch2: char = get_char(s, k);
                        if ch2 == '_' {
                            break;
                        }
                        seg2 = concat_chr(seg2, ch2);
                        k = k + 1;
                    }

                    if compare(seg1, seg2) == 0 {
                        if (k < n and get_char(s, k) == '_' and (k + 1 >= n or get_char(s, k + 1) != '_')) {
                            out = concat(out, str("__"));
                            out = concat(out, seg1);
                            i = k;
                            continue;
                        }
                    }
                }

                if j + 3 < n and get_char(s, j) == '_' and get_char(s, j + 1) != '_' {
                    mut k2: i32 = j + 1;
                    mut seg2b: string = str("");
                    loop {
                        if k2 >= n {
                            break;
                        }
                        val ch3: char = get_char(s, k2);
                        if ch3 == '_' {
                            break;
                        }
                        seg2b = concat_chr(seg2b, ch3);
                        k2 = k2 + 1;
                    }

                    if k2 + 1 < n and get_char(s, k2) == '_' and get_char(s, k2 + 1) == '_' {
                        if compare(seg1, seg2b) == 0 {
                            out = concat(out, str("__"));
                            out = concat(out, seg1);
                            out = concat(out, str("__"));
                            i = k2 + 2;
                            continue;
                        }
                    }
                }
            }
        }

        out = concat_chr(out, get_char(s, i));
        i = i + 1;
    }

    return out;
}

/// Strip any C. prefixes (C, optional spaces, '.', optional spaces) that may
/// appear anywhere in a C expression string, not just at the beginning.
def strip_all_c_prefixes(s: string): string {
    mut cleaned: string = str("");
    mut i: i32 = 0;
    loop {
        if i >= str_len(s) {
            break;
        }

        val ch: char = get_char(s, i);

        if ch == 'C' {
            mut prev_idx: i32 = i - 1;
            mut prev_ch: char = '\0';
            loop {
                if prev_idx < 0 {
                    break;
                }
                val pc: char = get_char(s, prev_idx);
                if pc != ' ' and pc != '\t' and pc != '\n' {
                    prev_ch = pc;
                    break;
                }
                prev_idx = prev_idx - 1;
            }

            if prev_idx < 0 or !is_ident_start(prev_ch) {
                mut k: i32 = i + 1;
                loop {
                    if k >= str_len(s) {
                        break;
                    }
                    val ws: char = get_char(s, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(s) and get_char(s, k) == '.' {
                    k = k + 1;
                    loop {
                        if k >= str_len(s) {
                            break;
                        }
                        val ws2: char = get_char(s, k);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        k = k + 1;
                    }

                    i = k;
                    continue;
                }
            }
        }

        cleaned = concat_chr(cleaned, ch);
        i = i + 1;
    }

    return cleaned;
}

/// Rewrite all enum member references (EnumName.MEMBER) within a string to the
/// proper C prefixed form (EnumName_MEMBER). This scans the entire expression
/// and transforms all occurrences, not just simple standalone patterns.
def rewrite_enum_member_refs(s: string): string {
    mut result: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    debug_print_raw "\n[DBG-ENUM] rewrite_enum_member_refs input:";
    debug_print_str s;

    loop {
        if i >= str_len(s) {
            break;
        }

        val ch: char = get_char(s, i);

        // Track string literals to avoid modifying contents
        if ch == '"' and (i == 0 or get_char(s, i - 1) != '\\') {
            in_string = !in_string;
            result = concat_chr(result, ch);
            i = i + 1;
            continue;
        }

        if in_string {
            result = concat_chr(result, ch);
            i = i + 1;
            continue;
        }

        // Look for identifier followed by '.' and another identifier
        if is_ident_start(ch) {
            mut ident: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(s) {
                    break;
                }
                val cj: char = get_char(s, j);
                if !is_token_char(cj) {
                    break;
                }
                ident = concat_chr(ident, cj);
                j = j + 1;
            }

            // Skip any whitespace after identifier
            mut k: i32 = j;
            loop {
                if k >= str_len(s) {
                    break;
                }
                val ws: char = get_char(s, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }

            // Check for '.'
            if k < str_len(s) and get_char(s, k) == '.' {
                mut dot_pos: i32 = k;
                k = k + 1;

                // Skip whitespace after '.'
                loop {
                    if k >= str_len(s) {
                        break;
                    }
                    val ws2: char = get_char(s, k);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                // Parse member name
                if k < str_len(s) and is_ident_start(get_char(s, k)) {
                    mut member: string = str("");
                    mut m: i32 = k;
                    loop {
                        if m >= str_len(s) {
                            break;
                        }
                        val cm: char = get_char(s, m);
                        if !is_token_char(cm) {
                            break;
                        }
                        member = concat_chr(member, cm);
                        m = m + 1;
                    }

                    if str_len(member) > 0 {
                        // Check if this identifier is a known enum name
                        val enum_c_name: string = canonical_model_c_name(ident);
                        if str_len(enum_c_name) > 0 and StringBoolMap.contains(addr(g_enum_names), enum_c_name) {
                            // This is an enum member access - emit EnumName_Member
                            result = concat(result, enum_c_name);
                            result = concat(result, str("_"));
                            result = concat(result, member);
                            i = m;
                            continue;
                        }
                    }
                }
            }

            // Not an enum member access, emit the identifier as-is
            result = concat(result, ident);
            i = j;
            continue;
        }

        result = concat_chr(result, ch);
        i = i + 1;
    }

    debug_print_raw "\n[DBG-ENUM] rewrite_enum_member_refs output:";
    debug_print_str result;

    return result;
}

/// Rewrite addr(...) to &(...) or &var for C address-of operations
def rewrite_adr(expr: string): string {
    mut result: string = expr;
    
    loop {
        val start_idx: i32 = find_substr(result, str("addr"));
        if start_idx < 0 {
            break;
        }
        
        mut pos: i32 = start_idx + 4;
        loop {
            if pos >= str_len(result) {
                break;
            }
            val ws: char = get_char(result, pos);
            if ws != ' ' and ws != '\t' {
                break;
            }
            pos = pos + 1;
        }
        
        if pos >= str_len(result) or get_char(result, pos) != '(' {
            break;
        }
        
        val paren_start: i32 = pos + 1;
        mut depth: i32 = 1;
        mut paren_end: i32 = paren_start;
        
        loop {
            if paren_end >= str_len(result) or depth == 0 {
                break;
            }
            val ch: char = get_char(result, paren_end);
            if ch == '(' {
                depth = depth + 1;
            } elif ch == ')' {
                depth = depth - 1;
            }
            if depth > 0 {
                paren_end = paren_end + 1;
            }
        }
        
        if depth != 0 {
            break;
        }
        
        val var_name: string = strip(substring_se(result, paren_start, paren_end));
        val has_bracket: bool = find_char_from(var_name, '[', 0) >= 0;
        val has_dot: bool = find_char_from(var_name, '.', 0) >= 0;
        mut replacement: string = str("");

        if has_bracket or has_dot {
            replacement = concat(str("&("), var_name);
            replacement = concat(replacement, str(")"));
        } else {
            replacement = concat(str("&"), var_name);
        }
        
        val before: string = substring_se(result, 0, start_idx);
        val after: string = substring_se(result, paren_end + 1, str_len(result));
        result = concat(before, replacement);
        result = concat(result, after);
    }
    
    return result;
}

def rewrite_function_calls(expr: string): string {
    mut out: string = str("");
    mut i: i32 = 0;
    mut in_string: bool = false;

    loop {
        if i >= str_len(expr) {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            out = concat_chr(out, ch);
            i = i + 1;
            continue;
        }

        val is_id_start: bool = is_ident_start(ch);
        if !in_string and is_id_start {
            mut ident: string = str("");
            mut j: i32 = i;
            loop {
                if j >= str_len(expr) {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                ident = concat_chr(ident, cj);
                j = j + 1;
            }

            mut k: i32 = j;
            loop {
                if k >= str_len(expr) {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }

            mut replaced_ident: string = ident;
            if k < str_len(expr) and get_char(expr, k) == '(' {
                if StringStringMap.contains(addr(g_function_prefixes), ident) {
                    replaced_ident = StringStringMap.get(addr(g_function_prefixes), ident);
                }
            }

            out = concat(out, replaced_ident);
            i = j;
            continue;
        }

        out = concat_chr(out, ch);
        i = i + 1;
    }

    return out;
}

def process_expression(expr: string): string {
    mut trimmed: string = strip(expr);
    mut has_pointer_sugar: bool = false;
    mut in_string: bool = false;
    mut i: i32 = 0;

    if has_prefix(trimmed, str("__INTERPOLATED__")) and has_suffix(trimmed, str("__INTERPOLATED__")) {
        val inner_len: i32 = str_len(trimmed) - 32;
        if inner_len > 0 {
            val inner: string = substring_se(trimmed, 16, 16 + inner_len);
            return process_interpolated_string(inner, false);
        }
    }

    mut open_idx: i32 = find_char_from(trimmed, '(', 0);
    if open_idx > 0 {
        val func_name_raw: string = strip(substring_se(trimmed, 0, open_idx));
        if equals_c(func_name_raw, "str") or has_suffix(func_name_raw, str("__str")) {
            mut depth: i32 = 0;
            mut in_str_arg: bool = false;
            mut j: i32 = open_idx;
            loop {
                if j >= str_len(trimmed) {
                    break;
                }
                val chj: char = get_char(trimmed, j);
                if chj == '"' and (j == 0 or get_char(trimmed, j - 1) != '\\') {
                    in_str_arg = !in_str_arg;
                } elif !in_str_arg {
                    if chj == '(' {
                        depth = depth + 1;
                    } elif chj == ')' {
                        depth = depth - 1;
                        if depth == 0 {
                            break;
                        }
                    }
                }
                j = j + 1;
            }

            if depth == 0 and j > open_idx {
                val inner_raw: string = strip(substring_se(trimmed, open_idx + 1, j));
                if has_prefix(inner_raw, str("__INTERPOLATED__")) and has_suffix(inner_raw, str("__INTERPOLATED__")) {
                    val inner_len2: i32 = str_len(inner_raw) - 32;
                    if inner_len2 > 0 {
                        val inner2: string = substring_se(inner_raw, 16, 16 + inner_len2);
                        return process_interpolated_string(inner2, true);
                    }
                }
            }
        }
    }

    trimmed = rewrite_casts(trimmed);

    loop {
        if i >= str_len(trimmed) {
            break;
        }
        val ch: char = get_char(trimmed, i);
        if ch == '"' and (i == 0 or get_char(trimmed, i - 1) != '\\') {
            in_string = !in_string;
        } elif !in_string and ch == '*' {
            mut k: i32 = i + 1;
            loop {
                if k >= str_len(trimmed) {
                    break;
                }
                val ws: char = get_char(trimmed, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }
            if k < str_len(trimmed) and get_char(trimmed, k) == '.' {
                has_pointer_sugar = true;
                break;
            }
        }
        i = i + 1;
    }

    mut has_c_prefix: bool = false;
    mut c_prefix_end: i32 = c_prefix_end_index(trimmed);
    if c_prefix_end >= 0 {
        has_c_prefix = true;
    }

    if !has_pointer_sugar and !has_c_prefix {
        debug_print_raw "\n[DBG-EXPR] no-sugar/no-C expr raw:";
        debug_print_str expr;
        debug_print_raw "\n[DBG-EXPR] no-sugar/no-C trimmed:";
        debug_print_str trimmed;

        val single_quote_pos: i32 = find_char_from(trimmed, '\'', 0);
        if single_quote_pos >= 0 {
            val addr_fixed_chars: string = rewrite_adr(trimmed);
            val calls_fixed_chars: string = rewrite_function_calls(addr_fixed_chars);
            val enum_fixed_chars: string = rewrite_enum_member_refs(calls_fixed_chars);
            return strip(enum_fixed_chars);
        }

        // Even when there is no pointer sugar or C. prefix, we still need to
        // normalize spurious internal spaces that may have been introduced
        // between pieces of what should be a single token. Examples that have
        // shown up in generated C include:
        //
        //   "0 . 0"         -> "0.0"
        //   "0 . 0000001"   -> "0.0000001"
        //   "reduce _angle" -> "reduce_angle"
        //
        // To fix these without disturbing normal inter-token spacing, run the
        // normalization pass below on the already-trimmed expression.

        mut normalized_only: string = trimmed;
        mut out_norm: string = str("");
        mut jn: i32 = 0;
        
        loop {
            if jn >= str_len(normalized_only) {
                break;
            }
            val chn: char = get_char(normalized_only, jn);

            if chn == ' ' or chn == '\t' or chn == '\n' {
                mut prev: char = '\0';
                mut next: char = '\0';

                mut kprev: i32 = jn - 1;
                loop {
                    if kprev < 0 {
                        break;
                    }
                    val cprev: char = get_char(normalized_only, kprev);
                    if cprev != ' ' and cprev != '\t' and cprev != '\n' {
                        prev = cprev;
                        break;
                    }
                    kprev = kprev - 1;
                }

                mut knext: i32 = jn + 1;
                mut next_pos: i32 = -1;
                loop {
                    if knext >= str_len(normalized_only) {
                        break;
                    }
                    val cnext: char = get_char(normalized_only, knext);
                    if cnext != ' ' and cnext != '\t' and cnext != '\n' {
                        next = cnext;
                        next_pos = knext;
                        break;
                    }
                    knext = knext + 1;
                }

                if (prev >= '0' and prev <= '9' and next == '.') or
                   (prev == '.' and next >= '0' and next <= '9') {
                    // Merge numeric fragments around the decimal point.
                } elif is_token_char(prev) and is_token_char(next) {
                    if next == '_' {
                        // ok.
                    } elif (prev == '+' and next == '=') or (prev == '-' and next == '=') {
                        // Merge `+ =` or `- =` into `+=` / `-=` to avoid split operators in generated C.
                    } elif !is_ident_start(next) {
                        // Merge other token fragments such as `reduce _angle`.
                    } else {
                        out_norm = concat(out_norm, str(" "));
                    }
                } else {
                    out_norm = concat(out_norm, str(" "));
                }
            } else {
                out_norm = concat_chr(out_norm, chn);
            }

            jn = jn + 1;
        }

        val norm_no_sugar: string = strip(out_norm);
        debug_print_raw "\n[DBG-EXPR] no-sugar final:";
        debug_print_str norm_no_sugar;

        val addr_fixed: string = rewrite_adr(norm_no_sugar);
        val ptr_fixed: string = rewrite_ref_member_access(addr_fixed);
        val methods_fixed: string = rewrite_method_calls(ptr_fixed);
        val sizeof_fixed: string = rewrite_sizeof_types(methods_fixed);
        val calls_fixed_no_sugar: string = rewrite_function_calls(sizeof_fixed);
        val enum_fixed_no_sugar: string = rewrite_enum_member_refs(calls_fixed_no_sugar);
        return strip(enum_fixed_no_sugar);
    }

    mut result: string = trimmed;
    debug_print_raw "\n[DBG-EXPR] raw expr before sugar/C:";
    debug_print_str expr;
    debug_print_raw "\n[DBG-EXPR] trimmed:";
    debug_print_str trimmed;

    if has_pointer_sugar {
        mut out: string = str("");
        mut in_str2: bool = false;
        mut j: i32 = 0;
        loop {
            if j >= str_len(result) {
                break;
            }
            val ch2: char = get_char(result, j);
            if ch2 == '"' and (j == 0 or get_char(result, j - 1) != '\\') {
                in_str2 = !in_str2;
                out = concat_chr(out, ch2);
            } elif !in_str2 and ch2 == '*' {
                // Support both `s*.field` and `s * . field` forms. When we see
                // a `*` outside of strings, peek ahead past any whitespace; if
                // the next non-space character is `.`, treat this as pointer
                // member sugar and emit `->` instead.
                mut k: i32 = j + 1;
                loop {
                    if k >= str_len(result) {
                        break;
                    }
                    val ws: char = get_char(result, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(result) and get_char(result, k) == '.' {
                    out = concat(out, str("->"));
                    j = k; // skip over the '.'; loop increment will move past it
                } else {
                    out = concat_chr(out, ch2);
                }
            } else {
                out = concat_chr(out, ch2);
            }
            j = j + 1;
        }
        result = out;
    }

    if has_c_prefix {
        result = substring_se(result, c_prefix_end, str_len(result));
    }

    result = strip_all_c_prefixes(result);

    // After pointer-sugar and C. stripping, run the same normalization pass
    // used above to clean up spurious internal spaces within tokens such as
    // "0 . 0" or "reduce _angle" while preserving spaces between tokens.
    mut normalized: string = result;
    debug_print_raw "\n[DBG-EXPR] after sugar/C before normalize:";
    debug_print_str normalized;
    mut out_final: string = str("");
    mut jf: i32 = 0;
    loop {
        if jf >= str_len(normalized) {
            break;
        }
        val chf: char = get_char(normalized, jf);

        if chf == ' ' or chf == '\t' or chf == '\n' {
            mut prev2: char = '\0';
            mut next2: char = '\0';

            mut kp: i32 = jf - 1;
            loop {
                if kp < 0 {
                    break;
                }
                val cp: char = get_char(normalized, kp);
                if cp != ' ' and cp != '\t' and cp != '\n' {
                    prev2 = cp;
                    break;
                }
                kp = kp - 1;
            }

            mut kn: i32 = jf + 1;
            mut next_pos2: i32 = -1;
            loop {
                if kn >= str_len(normalized) {
                    break;
                }
                val cn: char = get_char(normalized, kn);
                if cn != ' ' and cn != '\t' and cn != '\n' {
                    next2 = cn;
                    next_pos2 = kn;
                    break;
                }
                kn = kn + 1;
            }

            if (prev2 >= '0' and prev2 <= '9' and next2 == '.') or
               (prev2 == '.' and next2 >= '0' and next2 <= '9') {
                // Merge numeric fragments around the decimal point.
            } elif is_token_char(prev2) and is_token_char(next2) {
                if next2 == '_' {
                    // Merge space before underscore into the identifier.
                } elif (prev2 == '+' and next2 == '=') or (prev2 == '-' and next2 == '=') {
                    // Merge `+ =` or `- =` into `+=` / `-=`.
                } elif !is_ident_start(next2) {
                    // Drop the space between token characters (e.g. `reduce _angle`).
                } else {
                    out_final = concat(out_final, str(" "));
                }
            } else {
                out_final = concat(out_final, str(" "));
            }
        } else {
            out_final = concat_chr(out_final, chf);
        }

        jf = jf + 1;
    }

    val first_pass: string = strip(out_final);
    debug_print_raw "\nFIRST PASS:";
    debug_print_str first_pass;
    val fixed: string = replace_all(first_pass, str("(->"), str("->"));
    debug_print_raw "\nFIXED:";
    debug_print_str fixed;

    val addr_fixed2: string = rewrite_adr(fixed);
    val ptr_fixed2: string = rewrite_ref_member_access(addr_fixed2);
    val methods_fixed2: string = rewrite_method_calls(ptr_fixed2);
    val sizeof_fixed2: string = rewrite_sizeof_types(methods_fixed2);
    val calls_fixed: string = rewrite_function_calls(sizeof_fixed2);
    val enum_fixed: string = rewrite_enum_member_refs(calls_fixed);
    return strip(enum_fixed);
}

/// Generate a C function prototype from a Function AST node
def generate_function_prototype(ast: ref ASTNode): string {
    mut result: string = str("");

    if ast == nil {
        return result;
    }

    val func_name_raw: string = ast.data.function.name;

    // Do not emit a prototype for main
    if equals_c(func_name_raw, "main") {
        return result;
    }

    mut func_name: string = func_name_raw;
    mut sep: i32 = -1;
    mut i: i32 = 0;
    val n: i32 = str_len(func_name);
    loop {
        if i + 1 >= n {
            break;
        }
        val c1: char = get_char(func_name, i);
        val c2: char = get_char(func_name, i + 1);
        if c1 == '_' and c2 == '_' {
            sep = i;
        }
        i = i + 1;
    }

    if sep >= 0 and sep + 2 < n {
        val model_part: string = substring_se(func_name, 0, sep);
        val method_part: string = substring_se(func_name, sep + 2, n);
        mut has_inner_sep: bool = false;
        mut j: i32 = 0;
        val mlen: i32 = str_len(model_part);
        loop {
            if j + 1 >= mlen {
                break;
            }
            val mc1: char = get_char(model_part, j);
            val mc2: char = get_char(model_part, j + 1);
            if mc1 == '_' and mc2 == '_' {
                has_inner_sep = true;
                break;
            }
            j = j + 1;
        }

        if !has_inner_sep {
            val canon_model: string = canonical_model_c_name(model_part);
            if str_len(canon_model) > 0 {
                mut full: string = canon_model;
                full = concat(full, str("__"));
                full = concat(full, method_part);
                func_name = full;
            }
        }
    }

    if sep >= 0 {
        if StringStringMap.contains(addr(g_function_prefixes), func_name) {
            func_name = StringStringMap.get(addr(g_function_prefixes), func_name);
        }
    }
    
    mut return_type: string = ast.data.function.return_type;

    if str_len(return_type) == 0 {
        return_type = str("void");
    }

    val mapped_return_type: string = map_axe_type_to_c(return_type);

    result = concat(result, mapped_return_type);
    result = concat(result, str(" "));
    result = concat(result, func_name);
    result = concat(result, str("("));

    val params: ref list(string) = ast.data.function.params;
    if params != nil {
        mut param_idx: i32 = 0;
        loop {
            if param_idx >= len(deref(params)) {
                break;
            }

            if param_idx > 0 {
                result = concat(result, str(", "));
            }

            val param: string = params.data[param_idx];
            val colon_pos: i32 = find_char_from(param, ':', 0);

            if colon_pos >= 0 {
                val param_name: string = strip(substring_se(param, 0, colon_pos));
                val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                val processed_type: string = process_parameter_type(param_type);

                result = concat(result, processed_type);
                result = concat(result, str(" "));
                result = concat(result, param_name);
            } else {
                result = concat(result, param);
            }

            param_idx = param_idx + 1;
        }
    }

    result = concat(result, str(");\n"));
    return result;
}

/// Generate C from AST.
pub def generate_c(ast: ref ASTNode): string {
    mut result: string = str("");

    if ast == nil {
        return result;
    }
    val node_type: string = ast.node_type;

    if equals_c(node_type, "Overload") {
        val name: string = ast.data.overload_node.name;
        mut param_name: string = ast.data.overload_node.param_name;
        mut call_expr: string = ast.data.overload_node.call_expr;

        if str_len(param_name) == 0 {
            param_name = str("x");
        }
        if str_len(call_expr) == 0 {
            call_expr = param_name;
        }

        val type_names_ref: ref list(string) = ast.data.overload_node.type_names;
        val targets_ref: ref list(string) = ast.data.overload_node.target_functions;

        if type_names_ref == nil or targets_ref == nil {
            return result;
        }

        val count: i32 = len(deref(type_names_ref));

        if count == 0 or count != len(deref(targets_ref)) {
            return result;
        }

        result = concat(result, str("#define "));
        result = concat(result, name);
        result = concat(result, str("("));
        result = concat(result, param_name);
        result = concat(result, str(") _Generic(("));
        result = concat(result, call_expr);
        result = concat(result, str("), \\\n"));

        mut i_ov: i32 = 0;
        loop {
            if i_ov >= count {
                break;
            }

            val axe_type: string = type_names_ref.data[i_ov];
            mut target_name: string = targets_ref.data[i_ov];
            val mapped_type: string = map_axe_type_to_c(axe_type);

            if StringStringMap.contains(addr(g_function_prefixes), target_name) {
                target_name = StringStringMap.get(addr(g_function_prefixes), target_name);
            }

            result = concat(result, str("    "));
            result = concat(result, mapped_type);
            result = concat(result, str(": "));
            result = concat(result, target_name);

            if i_ov < count - 1 {
                result = concat(result, str(", \\\n"));
            } else {
                result = concat(result, str(" \\\n"));
            }

            i_ov = i_ov + 1;
        }

        result = concat(result, str("    )("));
        result = concat(result, call_expr);
        result = concat(result, str(")\n"));

        return result;
    }
    
    if equals_c(node_type, "Program") {
        mut ext_arena: Arena = Arena.create(4096);
        StringList.clear(g_global_external_headers);
        StringList.clear(g_windows_external_headers);
        StringList.clear(g_posix_external_headers);
        collect_external_imports(ast, str(""), addr(ext_arena));
        
        result = concat(result, str("#define nil ((void*)0)\n"));
        result = concat(result, str("#include <stdio.h>\n"));
        result = concat(result, str("#include <stdbool.h>\n"));
        result = concat(result, str("#include <stdlib.h>\n"));
        result = concat(result, str("#include <string.h>\n"));
        result = concat(result, str("#include <stdint.h>\n"));

        platform windows {
            result = concat(result, str("#include <windows.h>\n"));
            result = concat(result, str("#define NOMINMAX\n"));
            result = concat(result, str("#define NOGDI\n"));
            result = concat(result, str("#define WIN32_LEAN_AND_MEAN\n"));
        }
        
        mut ghi: i32 = 0;
        loop {
            if ghi >= g_global_external_headers*.len {
                break;
            }
            val gh: string = StringList.get(g_global_external_headers, ghi);
            result = concat(result, str("#include <"));
            result = concat(result, gh);
            result = concat(result, str(">\n"));
            ghi = ghi + 1;
        }
        
        if g_windows_external_headers*.len > 0 {
            result = concat(result, str("#ifdef _WIN32\n"));
            mut whi: i32 = 0;
            loop {
                if whi >= g_windows_external_headers*.len {
                    break;
                }
                val wh: string = StringList.get(g_windows_external_headers, whi);
                result = concat(result, str("#include <"));
                result = concat(result, wh);
                result = concat(result, str(">\n"));
                whi = whi + 1;
            }
            result = concat(result, str("#endif\n"));
        }
        
        if g_posix_external_headers*.len > 0 {
            result = concat(result, str("#ifndef _WIN32\n"));
            mut phi: i32 = 0;
            loop {
                if phi >= g_posix_external_headers*.len {
                    break;
                }
                val ph: string = StringList.get(g_posix_external_headers, phi);
                result = concat(result, str("#include <"));
                result = concat(result, ph);
                result = concat(result, str(">\n"));
                phi = phi + 1;
            }
            result = concat(result, str("#endif\n"));
        }

        result = concat(result, str("\nint __axe_argc = 0;\n"));
        result = concat(result, str("char** __axe_argv = NULL;\n\n"));
        
        build_function_prefixes(ast);

        if ast.children != nil {
            val children_for_models: ref list(ASTNode) = ast.children;
            mut mi: i32 = 0;
            loop {
                if mi >= len(deref(children_for_models)) {
                    break;
                }
                val mchild: ref ASTNode = addr(children_for_models.data[mi]);
                if equals_c(mchild.node_type, "Model") or equals_c(mchild.node_type, "Enum") {
                    mut cname: string = str("");
                    if equals_c(mchild.node_type, "Model") {
                        cname = mchild.data.model_node.name;
                    } else {
                        cname = mchild.data.enum_node.name;
                    }

                    mut base: string = cname;
                    mut last_sep: i32 = -1;
                    mut bi: i32 = 0;
                    val nlen: i32 = str_len(cname);
                    loop {
                        if bi + 1 >= nlen {
                            break;
                        }
                        val c1: char = get_char(cname, bi);
                        val c2: char = get_char(cname, bi + 1);
                        if c1 == '_' and c2 == '_' {
                            last_sep = bi;
                        }
                        bi++;
                    }
                    if last_sep >= 0 and last_sep + 2 < nlen {
                        base = substring_se(cname, last_sep + 2, nlen);
                    }

                    mut arena_local: Arena = Arena.create(256);

                    if str_len(base) > 0 {
                        StringStringMap.set(addr(g_model_names), addr(arena_local), base, cname);
                    }
                    StringStringMap.set(addr(g_model_names), addr(arena_local), cname, cname);
                    
                    if equals_c(mchild.node_type, "Enum") {
                        StringBoolMap.set(addr(g_enum_names), addr(arena_local), cname, true);
                        if str_len(base) > 0 {
                            StringBoolMap.set(addr(g_enum_names), addr(arena_local), base, true);
                        }
                    }
                }
                mi++;
            }

            val children: ref list(ASTNode) = ast.children;

            StringBoolMap.clear(addr(g_list_element_types));

            mut i_scan: i32 = 0;
            loop {
                if i_scan >= len(deref(children)) {
                    break;
                }
                scan_for_list_types(addr(children.data[i_scan]));
                i_scan++;
            }

            mut i_more: i32 = 0;
            loop {
                if i_more >= len(deref(children)) {
                    break;
                }
                val cnode: ref ASTNode = addr(children.data[i_more]);
                if equals_c(cnode.node_type, "Function") {
                    val ret_type: string = cnode.data.function.return_type;
                    val br: i32 = find_char_from(ret_type, '[', 0);
                    if br >= 0 and find_char_from(ret_type, ']', br) >= 0 {
                        mut elementType: string = strip(substring_se(ret_type, 0, br));
                        if has_prefix(elementType, str("ref ")) {
                            elementType = strip(substr(elementType, 4, str_len(elementType) - 4));
                        }
                        val mappedC: string = map_axe_type_to_c(elementType);
                        add_list_element(mappedC);
                    }
                } elif equals_c(cnode.node_type, "Model") {
                    val field_names: ref list(string) = cnode.data.model_node.field_names;
                    val field_types: ref list(string) = cnode.data.model_node.field_types;
                    if field_names != nil and field_types != nil {
                        mut fidx: i32 = 0;
                        loop {
                            if fidx >= len(deref(field_types)) or fidx >= len(deref(field_names)) {
                                break;
                            }
                            val ftype: string = field_types.data[fidx];
                            val br2: i32 = find_char_from(ftype, '[', 0);
                            if br2 >= 0 and find_char_from(ftype, ']', br2) >= 0 {
                                mut elemCandidate: string = strip(substring_se(ftype, 0, br2));
                                if has_prefix(elemCandidate, str("ref ")) {
                                    elemCandidate = strip(substr(elemCandidate, 4, str_len(elemCandidate) - 4));
                                }
                                val mappedElem: string = map_axe_type_to_c(elemCandidate);
                                add_list_element(mappedElem);
                            }
                            fidx++;
                        }
                    }
                }
                i_more++;
            }

            mut i_models2: i32 = 0;
            loop {
                if i_models2 >= len(deref(children)) {
                    break;
                }
                val m_child: ref ASTNode = addr(children.data[i_models2]);
                if equals_c(m_child.node_type, "Model") {
                    mut name: string = str("");
                    name = m_child.data.model_node.name;
                    if !StringBoolMap.contains(addr(g_generated_typedefs), name) {
                        result = concat(result, str("struct "));
                        result = concat(result, name);
                        result = concat(result, str(";\n"));
                    }
                }
                i_models2++;
            }

            mut i_models3: i32 = 0;
            loop {
                if i_models3 >= len(deref(children)) {
                    break;
                }
                val m_child: ref ASTNode = addr(children.data[i_models3]);
                if equals_c(m_child.node_type, "Model") {
                    mut name2: string = str("");
                    name2 = m_child.data.model_node.name;
                    if !StringBoolMap.contains(addr(g_generated_typedefs), name2) {
                        result = concat(result, str("typedef struct "));
                        result = concat(result, name2);
                        result = concat(result, str(" "));
                        result = concat(result, name2);
                        result = concat(result, str(";\n"));
                    }
                }
                i_models3++;
            }

            if g_list_elements != nil {
                val lst_ref: ref StringList = g_list_elements;
                mut li: i32 = 0;
                loop {
                    if li >= lst_ref*.len {
                        break;
                    }
                    val elemTypeStr: string = StringList.get(lst_ref, li);
                    val san: string = sanitize_list_element_name(elemTypeStr);
                    result = concat(result, str("typedef struct __list_"));
                    result = concat(result, san);
                    result = concat(result, str("_t __list_"));
                    result = concat(result, san);
                    result = concat(result, str("_t;\n"));
                    li = li + 1;
                }
            }

            mut i_opaque_plat: i32 = 0;
            loop {
                if i_opaque_plat >= len(deref(children)) {
                    break;
                }
                val op_plat: ref ASTNode = addr(children.data[i_opaque_plat]);
                if equals_c(op_plat.node_type, "Platform") {
                    val platform_name: string = op_plat.data.platform_node.platform_name;
                    mut has_opaque: bool = false;
                    
                    if op_plat.children != nil {
                        val plat_children: ref list(ASTNode) = op_plat.children;
                        mut oc: i32 = 0;
                        loop {
                            if oc >= len(deref(plat_children)) {
                                break;
                            }
                            val oc_child: ref ASTNode = addr(plat_children.data[oc]);
                            if equals_c(oc_child.node_type, "Opaque") {
                                has_opaque = true;
                                break;
                            }
                            oc++;
                        }
                    }
                    
                    if has_opaque {
                        if equals_c(platform_name, "windows") {
                            result = concat(result, str("#ifdef _WIN32\n"));
                        } elif equals_c(platform_name, "posix") {
                            result = concat(result, str("#ifndef _WIN32\n"));
                        }
                        val plat_children2: ref list(ASTNode) = op_plat.children;
                        mut oc2: i32 = 0;
                        loop {
                            if oc2 >= len(deref(plat_children2)) {
                                break;
                            }
                            val oc_child2: ref ASTNode = addr(plat_children2.data[oc2]);
                            if equals_c(oc_child2.node_type, "Opaque") {
                                val opaque_code: string = generate_c(oc_child2);
                                result = concat(result, opaque_code);
                            }
                            oc2++;
                        }
                        result = concat(result, str("#endif\n"));
                    }
                }
                i_opaque_plat++;
            }

            mut i_enums: i32 = 0;
            loop {
                if i_enums >= len(deref(children)) {
                    break;
                }
                val enum_child: ref ASTNode = addr(children.data[i_enums]);
                if equals_c(enum_child.node_type, "Enum") {
                    val e_code: string = generate_c(enum_child);
                    result = concat(result, e_code);
                }
                i_enums = i_enums + 1;
            }

            // Topological sort of models to ensure dependencies come first
            // Step 1: Collect all model names and build model map
            mut model_arena: Arena = Arena.create(1024 * 64);
            mut model_names_list: ref StringList = StringList.create(addr(model_arena), 64);
            mut model_indices: StringIntMap = deref(StringIntMap.create(addr(model_arena), 128));
            
            mut collect_idx: i32 = 0;
            loop {
                if collect_idx >= len(deref(children)) {
                    break;
                }
                val collect_child: ref ASTNode = addr(children.data[collect_idx]);
                if equals_c(collect_child.node_type, "Model") {
                    val mname: string = collect_child.data.model_node.name;
                    StringList.push(model_names_list, addr(model_arena), mname);
                    StringIntMap.set(addr(model_indices), addr(model_arena), mname, model_names_list.len - 1);
                }
                collect_idx = collect_idx + 1;
            }
            
            // Step 2: Build dependency adjacency lists
            // deps[i] contains list of model indices that model i depends on
            val num_models: i32 = model_names_list.len;
            
            mut deps_lists: ref StringList = StringList.create(addr(model_arena), num_models + 1);
            mut dep_init: i32 = 0;
            loop {
                if dep_init >= num_models {
                    break;
                }
                StringList.push(deps_lists, addr(model_arena), str(""));
                dep_init = dep_init + 1;
            }
            
            mut build_deps_idx: i32 = 0;
            loop {
                if build_deps_idx >= len(deref(children)) {
                    break;
                }
                val bdep_child: ref ASTNode = addr(children.data[build_deps_idx]);
                if equals_c(bdep_child.node_type, "Model") {
                    val this_model_name: string = bdep_child.data.model_node.name;
                    val this_model_idx: i32 = StringIntMap.get(addr(model_indices), this_model_name);
                    val ftypes: ref list(string) = bdep_child.data.model_node.field_types;

                    if ftypes != nil {
                        mut ft_idx: i32 = 0;
                        loop {
                            if ft_idx >= len(deref(ftypes)) {
                                break;
                            }

                            val ftype: string = ftypes.data[ft_idx];
                            val base_type: string = get_base_type_from_field(ftype);
                            val mapped_type: string = map_axe_type_to_c(base_type);
                            
                            if StringIntMap.contains(addr(model_indices), mapped_type) {
                                if compare(mapped_type, this_model_name) != 0 {
                                    val dep_idx: i32 = StringIntMap.get(addr(model_indices), mapped_type);
                                    val current_deps: string = StringList.get(deps_lists, this_model_idx);
                                    if str_len(current_deps) == 0 {
                                        deps_lists.data[this_model_idx] = mapped_type;
                                    } else {
                                        if find_substr(current_deps, mapped_type) < 0 {
                                            deps_lists.data[this_model_idx] = concat(concat(current_deps, str(",")), mapped_type);
                                        }
                                    }
                                }
                            }
                            ft_idx = ft_idx + 1;
                        }
                    }
                    
                    val union_types: ref list(string) = bdep_child.data.model_node.union_member_types;
                    if union_types != nil {
                        mut ut_idx: i32 = 0;
                        loop {
                            if ut_idx >= len(deref(union_types)) {
                                break;
                            }
                            val utype: string = union_types.data[ut_idx];
                            val ubase_type: string = get_base_type_from_field(utype);
                            val umapped_type: string = map_axe_type_to_c(ubase_type);
                            
                            if StringIntMap.contains(addr(model_indices), umapped_type) {
                                if compare(umapped_type, this_model_name) != 0 {
                                    val current_deps: string = StringList.get(deps_lists, this_model_idx);
                                    if str_len(current_deps) == 0 {
                                        deps_lists.data[this_model_idx] = umapped_type;
                                    } else {
                                        if find_substr(current_deps, umapped_type) < 0 {
                                            deps_lists.data[this_model_idx] = concat(concat(current_deps, str(",")), umapped_type);
                                        }
                                    }
                                }
                            }
                            ut_idx = ut_idx + 1;
                        }
                    }
                }
                build_deps_idx = build_deps_idx + 1;
            }
            
            mut visit_state: ref IntList = IntList.create(addr(model_arena), num_models + 1);
            mut vs_init: i32 = 0;
            loop {
                if vs_init >= num_models {
                    break;
                }
                IntList.push(visit_state, addr(model_arena), 0);
                vs_init = vs_init + 1;
            }
            
            mut sorted_order: ref StringList = StringList.create(addr(model_arena), num_models + 1);
            
            mut start_node: i32 = 0;
            loop {
                if start_node >= num_models {
                    break;
                }
                
                if IntList.get(visit_state, start_node) == 2 {
                    start_node = start_node + 1;
                    continue;
                }
                
                // Manual DFS stack: pairs of (node_index, phase)
                // phase 0 = first visit (mark visiting, push deps)
                // phase 1 = done with deps (mark visited, add to sorted)
                mut stack_nodes: ref IntList = IntList.create(addr(model_arena), 256);
                mut stack_phases: ref IntList = IntList.create(addr(model_arena), 256);
                
                IntList.push(stack_nodes, addr(model_arena), start_node);
                IntList.push(stack_phases, addr(model_arena), 0);
                
                loop {
                    if stack_nodes.len == 0 {
                        break;
                    }
                    
                    val curr_node: i32 = IntList.get(stack_nodes, stack_nodes.len - 1);
                    val curr_phase: i32 = IntList.get(stack_phases, stack_phases.len - 1);
                    
                    stack_nodes.len = stack_nodes.len - 1;
                    stack_phases.len = stack_phases.len - 1;
                    
                    val curr_state: i32 = IntList.get(visit_state, curr_node);
                    
                    if curr_state == 2 {
                        continue;
                    }
                    
                    if curr_phase == 0 {
                        if curr_state == 1 {
                            continue;
                        }
                        
                        visit_state.data[curr_node] = 1;
                        
                        IntList.push(stack_nodes, addr(model_arena), curr_node);
                        IntList.push(stack_phases, addr(model_arena), 1);
                        
                        val deps_str: string = StringList.get(deps_lists, curr_node);
                        if str_len(deps_str) > 0 {
                            mut dep_start: i32 = 0;
                            mut dep_pos: i32 = 0;
                            loop {
                                if dep_pos > str_len(deps_str) {
                                    break;
                                }
                                
                                mut is_sep: bool = dep_pos == str_len(deps_str);
                                if !is_sep {
                                    is_sep = get_char(deps_str, dep_pos) == ',';
                                }
                                
                                if is_sep {
                                    if dep_pos > dep_start {
                                        val dep_name: string = substr(deps_str, dep_start, dep_pos - dep_start);
                                        if StringIntMap.contains(addr(model_indices), dep_name) {
                                            val dep_idx: i32 = StringIntMap.get(addr(model_indices), dep_name);
                                            if IntList.get(visit_state, dep_idx) != 2 {
                                                IntList.push(stack_nodes, addr(model_arena), dep_idx);
                                                IntList.push(stack_phases, addr(model_arena), 0);
                                            }
                                        }
                                    }
                                    dep_start = dep_pos + 1;
                                }
                                dep_pos++;
                            }
                        }
                    } else {
                        // Phase 1: mark visited and add to sorted order
                        visit_state.data[curr_node] = 2;
                        val model_name: string = StringList.get(model_names_list, curr_node);
                        StringList.push(sorted_order, addr(model_arena), model_name);
                    }
                }
                
                start_node = start_node + 1;
            }
            
            // Step 4: Generate models in sorted order (dependencies first)
            mut sorted_idx: i32 = 0;
            loop {
                if sorted_idx >= sorted_order.len {
                    break;
                }
                val sorted_name: string = StringList.get(sorted_order, sorted_idx);
                
                mut find_idx: i32 = 0;
                loop {
                    if find_idx >= len(deref(children)) {
                        break;
                    }
                    val find_child: ref ASTNode = addr(children.data[find_idx]);
                    if equals_c(find_child.node_type, "Model") {
                        if compare(find_child.data.model_node.name, sorted_name) == 0 {
                            val m_code: string = generate_c(find_child);
                            result = concat(result, m_code);
                            break;
                        }
                    }
                    find_idx++;
                }
                
                sorted_idx++;
            }

            if g_list_elements != nil {
                val lst_ref2: ref StringList = g_list_elements;
                mut jj: i32 = 0;
                loop {
                    if jj >= lst_ref2*.len {
                        break;
                    }
                    val elementType: string = StringList.get(lst_ref2, jj);
                    val elemSan: string = sanitize_list_element_name(elementType);

                    result = concat(result, str("typedef struct __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t {\n"));
                    result = concat(result, str("    "));
                    result = concat(result, elementType);
                    result = concat(result, str("* data;\n"));
                    result = concat(result, str("    int len;\n"));
                    result = concat(result, str("    int capacity;\n"));
                    result = concat(result, str("} __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t;\n\n"));

                    result = concat(result, str("static inline __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_init(void) {\n"));
                    result = concat(result, str("    __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t list;\n"));
                    result = concat(result, str("    list.data = NULL;\n"));
                    result = concat(result, str("    list.len = 0;\n"));
                    result = concat(result, str("    list.capacity = 0;\n"));
                    result = concat(result, str("    return list;\n"));
                    result = concat(result, str("}\n\n"));

                    result = concat(result, str("static inline void __list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_push(__list_"));
                    result = concat(result, elemSan);
                    result = concat(result, str("_t* list, "));
                    result = concat(result, elementType);
                    result = concat(result, str(" item) {\n"));
                    result = concat(result, str("    if (list->len >= list->capacity) {\n"));
                    result = concat(result, str("        int new_capacity = list->capacity == 0 ? 8 : list->capacity * 2;\n"));
                    result = concat(result, str("        "));
                    result = concat(result, elementType);
                    result = concat(result, str("* new_data = (") );
                    result = concat(result, elementType);
                    result = concat(result, str("*)realloc(list->data, new_capacity * sizeof("));
                    result = concat(result, elementType);
                    result = concat(result, str("));\n"));
                    result = concat(result, str("        if (new_data == NULL) { fprintf(stderr, \"Out of memory\\n\"); exit(1); }\n"));
                    result = concat(result, str("        list->data = new_data;\n"));
                    result = concat(result, str("        list->capacity = new_capacity;\n"));
                    result = concat(result, str("    }\n"));
                    result = concat(result, str("    list->data[list->len++] = item;\n"));
                    result = concat(result, str("}\n\n"));

                    jj++;
                }
            }

            mut i_globals: i32 = 0;
            loop {
                if i_globals >= len(deref(children)) {
                    break;
                }
                val g_child: ref ASTNode = addr(children.data[i_globals]);
                if equals_c(g_child.node_type, "Declaration") {
                    val g_code: string = generate_c(g_child);
                    if str_len(g_code) > 0 {
                        result = concat(result, g_code);
                    }
                }
                i_globals = i_globals + 1;
            }

            mut i_proto: i32 = 0;
            loop {
                if i_proto >= len(deref(children)) {
                    break;
                }
                val proto_child: ref ASTNode = addr(children.data[i_proto]);
                if equals_c(proto_child.node_type, "Function") {
                    val proto_code: string = generate_function_prototype(proto_child);
                    if str_len(proto_code) > 0 {
                        result = concat(result, proto_code);
                    }
                }
                if equals_c(proto_child.node_type, "Platform") {
                    val platform_name: string = proto_child.data.platform_node.platform_name;
                    if equals_c(platform_name, "windows") {
                        result = concat(result, str("#ifdef _WIN32\n"));
                    } elif equals_c(platform_name, "posix") {
                        result = concat(result, str("#ifndef _WIN32\n"));
                    }
                    if proto_child.children != nil {
                        val plat_children: ref list(ASTNode) = proto_child.children;
                        mut pi: i32 = 0;
                        loop {
                            if pi >= len(deref(plat_children)) {
                                break;
                            }
                            val plat_child: ref ASTNode = addr(plat_children.data[pi]);
                            if equals_c(plat_child.node_type, "Function") {
                                val plat_proto: string = generate_function_prototype(plat_child);
                                if str_len(plat_proto) > 0 {
                                    result = concat(result, plat_proto);
                                }
                            }
                            pi = pi + 1;
                        }
                    }
                    result = concat(result, str("#endif\n"));
                }
                i_proto = i_proto + 1;
            }
            result = concat(result, str("\n"));

            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child: ref ASTNode = addr(children.data[i]);
                if equals_c(child.node_type, "Overload") {
                    val ov_code: string = generate_c(child);
                    result = concat(result, ov_code);
                    result = concat(result, str("\n"));
                }
                i = i + 1;
            }

            i = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val fn_child: ref ASTNode = addr(children.data[i]);
                if equals_c(fn_child.node_type, "Function") {
                    val fn_name: string = fn_child.data.function.name;
                    if !equals_c(fn_name, "main") {
                        val fn_code: string = generate_c(fn_child);
                        result = concat(result, fn_code);
                    }
                }
                if equals_c(fn_child.node_type, "Platform") {
                    val platform_name: string = fn_child.data.platform_node.platform_name;
                    if equals_c(platform_name, "windows") {
                        result = concat(result, str("#ifdef _WIN32\n"));
                    } elif equals_c(platform_name, "posix") {
                        result = concat(result, str("#ifndef _WIN32\n"));
                    }
                    if fn_child.children != nil {
                        val plat_children: ref list(ASTNode) = fn_child.children;
                        mut pi: i32 = 0;
                        loop {
                            if pi >= len(deref(plat_children)) {
                                break;
                            }
                            val plat_child: ref ASTNode = addr(plat_children.data[pi]);
                            if equals_c(plat_child.node_type, "Function") {
                                val plat_fn_name: string = plat_child.data.function.name;
                                if !equals_c(plat_fn_name, "main") {
                                    val plat_fn_code: string = generate_c(plat_child);
                                    result = concat(result, plat_fn_code);
                                }
                            }
                            pi = pi + 1;
                        }
                    }
                    result = concat(result, str("#endif\n"));
                }
                i = i + 1;
            }

            mut i_main_idx: i32 = 0;
            loop {
                if i_main_idx >= len(deref(children)) {
                    break;
                }
                val fnn: ref ASTNode = addr(children.data[i_main_idx]);
                if equals_c(fnn.node_type, "Function") {
                    val namecheck: string = fnn.data.function.name;
                    if equals_c(namecheck, "main") {
                        val main_code: string = generate_c(fnn);
                        result = concat(result, main_code);
                        break;
                    }
                }
                i_main_idx++;
            }

            i = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child2: ref ASTNode = addr(children.data[i]);
                if !equals_c(child2.node_type, "Overload") and !equals_c(child2.node_type, "Function") 
                    and !equals_c(child2.node_type, "Model") and !equals_c(child2.node_type, "Enum") 
                    and !equals_c(child2.node_type, "Declaration") and !equals_c(child2.node_type, "Platform") {
                    val child_code: string = generate_c(child2);
                    result = concat(result, child_code);
                }
                i = i + 1;
            }
            
            i = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val plat_node: ref ASTNode = addr(children.data[i]);
                if equals_c(plat_node.node_type, "Platform") {
                    val platform_name: string = plat_node.data.platform_node.platform_name;
                    mut has_non_func_content: bool = false;
                    
                    if plat_node.children != nil {
                        val plat_children: ref list(ASTNode) = plat_node.children;
                        mut pc: i32 = 0;
                        loop {
                            if pc >= len(deref(plat_children)) {
                                break;
                            }
                            val pc_child: ref ASTNode = addr(plat_children.data[pc]);
                            if !equals_c(pc_child.node_type, "Function") {
                                has_non_func_content = true;
                                break;
                            }
                            pc++;
                        }
                    }
                    
                    if has_non_func_content {
                        if equals_c(platform_name, "windows") {
                            result = concat(result, str("#ifdef _WIN32\n"));
                        } elif equals_c(platform_name, "posix") {
                            result = concat(result, str("#ifndef _WIN32\n"));
                        }
                        if plat_node.children != nil {
                            val plat_children2: ref list(ASTNode) = plat_node.children;
                            mut pc2: i32 = 0;
                            loop {
                                if pc2 >= len(deref(plat_children2)) {
                                    break;
                                }
                                val pc_child2: ref ASTNode = addr(plat_children2.data[pc2]);
                                // Skip functions - they were already emitted
                                if !equals_c(pc_child2.node_type, "Function") {
                                    val pc_code: string = generate_c(pc_child2);
                                    result = concat(result, pc_code);
                                }
                                pc2 = pc2 + 1;
                            }
                        }
                        result = concat(result, str("#endif\n"));
                    }
                }
                i++;
            }
        }
        result = replace_all(result, str("(->"), str("->"));

        mut fixed_result: string = str("");
        mut start_idx: i32 = 0;
        mut idx_line: i32 = 0;
        loop {
            if idx_line >= str_len(result) {
                if start_idx < idx_line {
                    val last_line: string = substring_se(result, start_idx, idx_line);
                    mut line_fixed: string = last_line;

                    val trimmed_last: string = strip(last_line);
                    if has_suffix(trimmed_last, str(");")) {
                        mut eq_pos: i32 = -1;
                        mut in_string_eq: bool = false;
                        mut ei: i32 = 0;
                        loop {
                            if ei >= str_len(last_line) {
                                break;
                            }
                            val ec: char = get_char(last_line, ei);
                            if ec == '"' and (ei == 0 or get_char(last_line, ei - 1) != '\\') {
                                in_string_eq = !in_string_eq;
                            }
                            if ec == '=' and !in_string_eq {
                                eq_pos = ei;
                                break;
                            }
                            ei = ei + 1;
                        }

                        if eq_pos >= 0 {
                            mut open_p: i32 = 0;
                            mut close_p: i32 = 0;
                            mut pi: i32 = eq_pos + 1;
                            loop {
                                if pi >= str_len(last_line) {
                                    break;
                                }
                                val c: char = get_char(last_line, pi);
                                if c == '(' {
                                    open_p = open_p + 1;
                                } elif c == ')' {
                                    close_p = close_p + 1;
                                } elif c == ';' {
                                    break;
                                }
                                pi = pi + 1;
                            }

                            if close_p == open_p + 1 {
                                mut semi_idx: i32 = -1;
                                mut sj: i32 = str_len(last_line) - 1;
                                loop {
                                    if sj < 0 {
                                        break;
                                    }
                                    if get_char(last_line, sj) == ';' {
                                        semi_idx = sj;
                                        break;
                                    }
                                    sj = sj - 1;
                                }

                                if semi_idx > 0 {
                                    mut close_idx: i32 = semi_idx - 1;
                                    loop {
                                        if close_idx < 0 {
                                            break;
                                        }
                                        val cc: char = get_char(last_line, close_idx);
                                        if cc == ' ' or cc == '\t' or cc == '\n' {
                                            close_idx = close_idx - 1;
                                            continue;
                                        }
                                        break;
                                    }

                                    if close_idx >= 0 and get_char(last_line, close_idx) == ')' {
                                        mut tmp: string = str("");
                                        tmp = concat(tmp, substring_se(last_line, 0, close_idx));
                                        tmp = concat(tmp, substring_se(last_line, close_idx + 1, str_len(last_line)));
                                        line_fixed = tmp;
                                    }
                                }
                            }
                        }
                    }

                    fixed_result = concat(fixed_result, line_fixed);
                }
                break;
            }

            val ch: char = get_char(result, idx_line);
            if ch == '\n' {
                val line: string = substring_se(result, start_idx, idx_line + 1);
                mut line_fixed2: string = line;

                val trimmed: string = strip(line);
                if has_suffix(trimmed, str(");")) {
                    mut eq_pos2: i32 = -1;
                    mut in_string_eq2: bool = false;
                    mut ei2: i32 = 0;
                    loop {
                        if ei2 >= str_len(line) {
                            break;
                        }
                        val ec2: char = get_char(line, ei2);
                        if ec2 == '"' and (ei2 == 0 or get_char(line, ei2 - 1) != '\\') {
                            in_string_eq2 = !in_string_eq2;
                        }
                        if ec2 == '=' and !in_string_eq2 {
                            eq_pos2 = ei2;
                            break;
                        }
                        ei2 = ei2 + 1;
                    }

                    if eq_pos2 >= 0 {
                        mut open_p2: i32 = 0;
                        mut close_p2: i32 = 0;
                        mut pi2: i32 = eq_pos2 + 1;
                        loop {
                            if pi2 >= str_len(line) {
                                break;
                            }
                            val c2: char = get_char(line, pi2);
                            if c2 == '(' {
                                open_p2 = open_p2 + 1;
                            } elif c2 == ')' {
                                close_p2 = close_p2 + 1;
                            } elif c2 == ';' {
                                break;
                            }
                            pi2 = pi2 + 1;
                        }

                        if close_p2 == open_p2 + 1 {
                            mut semi_idx2: i32 = -1;
                            mut sj2: i32 = str_len(line) - 1;
                            loop {
                                if sj2 < 0 {
                                    break;
                                }
                                if get_char(line, sj2) == ';' {
                                    semi_idx2 = sj2;
                                    break;
                                }
                                sj2 = sj2 - 1;
                            }

                            if semi_idx2 > 0 {
                                mut close_idx2: i32 = semi_idx2 - 1;
                                loop {
                                    if close_idx2 < 0 {
                                        break;
                                    }
                                    val cc2: char = get_char(line, close_idx2);
                                    if cc2 == ' ' or cc2 == '\t' or cc2 == '\n' {
                                        close_idx2 = close_idx2 - 1;
                                        continue;
                                    }
                                    break;
                                }

                                if close_idx2 >= 0 and get_char(line, close_idx2) == ')' {
                                    mut tmp2: string = str("");
                                    tmp2 = concat(tmp2, substring_se(line, 0, close_idx2));
                                    tmp2 = concat(tmp2, substring_se(line, close_idx2 + 1, str_len(line)));
                                    line_fixed2 = tmp2;
                                }
                            }
                        }
                    }
                }

                fixed_result = concat(fixed_result, line_fixed2);
                start_idx = idx_line + 1;
            }

            idx_line = idx_line + 1;
        }

        if str_len(fixed_result) > 0 {
            result = fixed_result;
        }
    }

    if equals_c(node_type, "Program") {
        result = strip_all_c_prefixes(result);
        result = replace_all(result, str("C . "), str(""));
        result = replace_all(result, str("C."), str(""));
        result = replace_all(result, str("C__"), str(""));
        result = collapse_duplicate_segments(result);
        result = rewrite_method_calls(result);
        result = rewrite_function_prefixes(result);
        result = rewrite_sizeof_types(result);
        result = rewrite_pointer_member_accesses(result);
        result = normalize_numeric_dots(result);
    }

    if equals_c(node_type, "Test") {
        result = concat(result, str("int main(int argc, char** argv) {\n"));
        result = concat(result, str("__axe_argc = argc;\n"));
        result = concat(result, str("__axe_argv = argv;\n"));
        result = concat(result, str("    int passed = 0;\n"));
        result = concat(result, str("    int failed = 0;\n\n"));

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_test: i32 = 0;
            loop {
                if i_test >= len(deref(children)) {
                    break;
                }

                val child: ref ASTNode = addr(children.data[i_test]);

                if equals_c(child.node_type, "Assert") {
                    val cond_raw: string = strip(child.data.assert_node.condition);
                    val cond_norm: string = process_expression(cond_raw);
                    val msg: string = child.data.assert_node.message;

                    result = concat(result, str("    if ("));
                    result = concat(result, cond_norm);
                    result = concat(result, str(") {\n"));
                    result = concat(result, str("        printf(\"PASSED: "));
                    result = concat(result, msg);
                    result = concat(result, str("\\n\");\n"));
                    result = concat(result, str("        passed++;\n"));
                    result = concat(result, str("    } else {\n"));
                    result = concat(result, str("        printf(\"FAILED: "));
                    result = concat(result, msg);
                    result = concat(result, str("\\n\");\n"));
                    result = concat(result, str("        failed++;\n"));
                    result = concat(result, str("    }\n\n"));
                } elif equals_c(child.node_type, "Declaration") {
                    val var_name: string = child.data.declaration.name;
                    val type_name: string = child.data.declaration.type_name;
                    val is_mutable: bool = child.data.declaration.is_mutable;
                    val initializer: string = child.data.declaration.initializer;

                    if str_len(var_name) > 0 and str_len(type_name) > 0 {
                        mut arena_decl: Arena = Arena.create(256);
                        StringStringMap.set(addr(g_var_types), addr(arena_decl), var_name, type_name);
                    }

                    mut mapped_type: string = map_axe_type_to_c(type_name);
                    mut line: string = str("");
                    mut array_suffix: string = str("");
                    val br: i32 = find_char_from(type_name, '[', 0);

                    if br >= 0 {
                        val suffix: string = substring_se(type_name, br, str_len(type_name));
                        if !equals_c(suffix, "[999]") {
                            val base_raw: string = strip(substring_se(type_name, 0, br));
                            if str_len(base_raw) > 0 {
                                mapped_type = map_axe_type_to_c(base_raw);
                                array_suffix = suffix;
                            }
                        }
                    }

                    if is_mutable {
                        line = concat(line, mapped_type);
                        line = concat(line, str(" "));
                        line = concat(line, var_name);
                        if str_len(array_suffix) > 0 {
                            line = concat(line, array_suffix);
                        }
                    } else {
                        line = concat(line, str("const "));
                        line = concat(line, mapped_type);
                        line = concat(line, str(" "));
                        line = concat(line, var_name);
                        if str_len(array_suffix) > 0 {
                            line = concat(line, array_suffix);
                        }
                    }

                    mut trimmed_init: string = strip(initializer);
                    if str_len(trimmed_init) > 0 {
                        val init_norm: string = process_expression(trimmed_init);
                        line = concat(line, str(" = "));
                        line = concat(line, init_norm);
                    }

                    line = concat(line, str(";"));
                    result = concat(result, str("    "));
                    result = concat(result, line);
                    result = concat(result, str("\n"));
                } else {
                    val stmt_code: string = generate_c(child);
                    if str_len(stmt_code) > 0 {
                        mut line: string = str("");
                        mut buf: string = stmt_code;
                        mut idx: i32 = 0;

                        loop {
                            if idx >= str_len(buf) {
                                break;
                            }
                            val ch: char = get_char(buf, idx);
                            if ch == '\n' {
                                if str_len(line) > 0 {
                                    result = concat(result, str("    "));
                                    result = concat(result, line);
                                    result = concat(result, str("\n"));
                                    line = str("");
                                }
                            } else {
                                line = concat_chr(line, ch);
                            }
                            idx = idx + 1;
                        }

                        if str_len(line) > 0 {
                            result = concat(result, str("    "));
                            result = concat(result, line);
                            result = concat(result, str("\n"));
                        }
                    }
                }

                i_test = i_test + 1;
            }
        }

        result = concat(result, str("    printf(\"\\n\");\n"));
        result = concat(result, str("    if (failed == 0) {\n"));
        result = concat(result, str("        printf(\"All tests passed. (%d/%d)\\n\", passed, passed + failed);\n"));
        result = concat(result, str("    } else {\n"));
        result = concat(result, str("        printf(\"%d test(s) failed, %d passed\\n\", failed, passed);\n"));
        result = concat(result, str("    }\n"));
        result = concat(result, str("    return failed > 0 ? 1 : 0;\n"));
        result = concat(result, str("}\n"));

        return result;
    }
    
    if equals_c(node_type, "Function") {
        mut func_name: string = ast.data.function.name;
        mut return_type: string = ast.data.function.return_type;
        val is_public: bool = ast.data.function.is_public;
        
        if !equals_c(func_name, "main") {
            mut sep2: i32 = -1;
            mut i2: i32 = 0;
            val n2: i32 = str_len(func_name);
            loop {
                if i2 + 1 >= n2 {
                    break;
                }
                val c1b: char = get_char(func_name, i2);
                val c2b: char = get_char(func_name, i2 + 1);
                if c1b == '_' and c2b == '_' {
                    sep2 = i2;
                }
                i2 = i2 + 1;
            }

            if sep2 >= 0 and sep2 + 2 < n2 {
                val model_part2: string = substring_se(func_name, 0, sep2);
                val method_part2: string = substring_se(func_name, sep2 + 2, n2);

                mut has_inner_sep2: bool = false;
                mut j2: i32 = 0;
                val mlen2: i32 = str_len(model_part2);
                loop {
                    if j2 + 1 >= mlen2 {
                        break;
                    }
                    val mc1b: char = get_char(model_part2, j2);
                    val mc2b: char = get_char(model_part2, j2 + 1);
                    if mc1b == '_' and mc2b == '_' {
                        has_inner_sep2 = true;
                        break;
                    }
                    j2 = j2 + 1;
                }

                if !has_inner_sep2 {
                    val canon_model2: string = canonical_model_c_name(model_part2);
                    if str_len(canon_model2) > 0 {
                        mut full2: string = canon_model2;
                        full2 = concat(full2, str("__"));
                        full2 = concat(full2, method_part2);
                        func_name = full2;
                    }
                }
            }

            if StringStringMap.contains(addr(g_function_prefixes), func_name) {
                func_name = StringStringMap.get(addr(g_function_prefixes), func_name);
            }
        }
        
        if StringBoolMap.contains(addr(g_generated_functions), func_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr(g_generated_functions), addr(arena), func_name, true);
        StringStringMap.clear(addr(g_var_types));
        
        val fn_params: ref list(string) = ast.data.function.params;
        if fn_params != nil {
            mut pi: i32 = 0;
            loop {
                if pi >= len(deref(fn_params)) {
                    break;
                }
                val p: string = fn_params.data[pi];
                val cp: i32 = find_char_from(p, ':', 0);
                if cp >= 0 {
                    val pname: string = strip(substring_se(p, 0, cp));
                    val ptype: string = strip(substr(p, cp + 1, str_len(p) - cp - 1));
                    if str_len(pname) > 0 and str_len(ptype) > 0 {
                        StringStringMap.set(addr(g_var_types), addr(arena), pname, ptype);
                    }
                }
                pi = pi + 1;
            }
        }
        
        if equals_c(func_name, "main") {
            result = concat(result, str("int main(int argc, char** argv) {\n"));
            result = concat(result, str("__axe_argc = argc;\n"));
            result = concat(result, str("__axe_argv = argv;\n"));
            
            if ast.children != nil {
                val children: ref list(ASTNode) = ast.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_code: string = generate_c(addr(children.data[i]));
                    result = concat(result, child_code);
                    i++;
                }
            }
            
            result = concat(result, str("return 0;\n"));
            result = concat(result, str("}\n\n"));
            return result;
        }
        
        if str_len(return_type) == 0 {
            return_type = str("void");
        }
        
        val mapped_return_type: string = map_axe_type_to_c(return_type);
        
        result = concat(result, mapped_return_type);
        result = concat(result, str(" "));
        result = concat(result, func_name);
        result = concat(result, str("("));
        
        val params: ref list(string) = ast.data.function.params;
        if params != nil {
            mut param_idx: i32 = 0;
            loop {
                if param_idx >= len(deref(params)) {
                    break;
                }
                
                if param_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                val param: string = params.data[param_idx];
                val colon_pos: i32 = find_char_from(param, ':', 0);

                if colon_pos >= 0 {
                    val param_name: string = strip(substring_se(param, 0, colon_pos));
                    val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                    val processed_type: string = process_parameter_type(param_type);
                    
                    result = concat(result, processed_type);
                    result = concat(result, str(" "));
                    result = concat(result, param_name);
                } else {
                    result = concat(result, param);
                }
                
                param_idx++;
            }
        }
        
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n\n"));
        return result;
    }
    
    if equals_c(node_type, "Return") {
        result = concat(result, str("return "));
        mut expr: string = ast.data.return_node.expression;
        debug_print_raw "\n[DEBUG] RENDERER raw return expr:";
        debug_print_str expr;

        mut trimmed_ret: string = strip(expr);

        val paren_pos_ret: i32 = find_char_from(trimmed_ret, '(', 0);
        if paren_pos_ret > 0 {
            val call_name_ret: string = strip(substring_se(trimmed_ret, 0, paren_pos_ret));
            if StringStringMap.contains(addr(g_function_prefixes), call_name_ret) {
                val full_name_ret: string = StringStringMap.get(addr(g_function_prefixes), call_name_ret);
                val rest_ret: string = substring_se(trimmed_ret, paren_pos_ret, str_len(trimmed_ret));
                trimmed_ret = concat(full_name_ret, rest_ret);
                expr = trimmed_ret;
            }
        }

        mut processed: string = str("");

        val brace_pos_ret: i32 = find_char_from(trimmed_ret, '{', 0);
        if brace_pos_ret > 0 and get_char(trimmed_ret, str_len(trimmed_ret) - 1) == '}' {
            val prefix_ret: string = strip(substring_se(trimmed_ret, 0, brace_pos_ret));
            val inner_ret: string = substring_se(trimmed_ret, brace_pos_ret + 1, str_len(trimmed_ret) - 1);

            if str_len(prefix_ret) > 0 {
                val canon_ret: string = canonical_model_c_name(prefix_ret);
                mut c_type_ret: string = canon_ret;
                if str_len(c_type_ret) == 0 {
                    c_type_ret = map_axe_type_to_c(prefix_ret);
                }

                if str_len(c_type_ret) > 0 {
                    mut init_code_ret: string = str("(");
                    init_code_ret = concat(init_code_ret, c_type_ret);
                    init_code_ret = concat(init_code_ret, str("){"));

                    mut current_ret: string = str("");
                    mut depth_ret: i32 = 0;
                    mut first_field_ret: bool = true;
                    mut i_ret: i32 = 0;

                    loop {
                        if i_ret >= str_len(inner_ret) {
                            break;
                        }
                        val ch_ret: char = get_char(inner_ret, i_ret);
                        if ch_ret == '(' {
                            depth_ret = depth_ret + 1;
                            current_ret = concat_chr(current_ret, ch_ret);
                        } elif ch_ret == ')' {
                            if depth_ret > 0 {
                                depth_ret = depth_ret - 1;
                            }
                            current_ret = concat_chr(current_ret, ch_ret);
                        } elif ch_ret == ',' and depth_ret == 0 {
                            mut part_ret: string = strip(current_ret);
                            if str_len(part_ret) > 0 {
                                val colon_pos_ret2: i32 = find_char_from(part_ret, ':', 0);
                                if colon_pos_ret2 >= 0 {
                                    val field_name_ret: string = strip(substring_se(part_ret, 0, colon_pos_ret2));
                                    val value_expr_ret: string = strip(substr(part_ret, colon_pos_ret2 + 1, str_len(part_ret) - colon_pos_ret2 - 1));
                                    if str_len(field_name_ret) > 0 and str_len(value_expr_ret) > 0 {
                                        if !first_field_ret {
                                            init_code_ret = concat(init_code_ret, str(", "));
                                        }
                                        init_code_ret = concat(init_code_ret, str("."));
                                        init_code_ret = concat(init_code_ret, field_name_ret);
                                        init_code_ret = concat(init_code_ret, str(" = "));
                                        val processed_val_ret: string = process_expression(value_expr_ret);
                                        init_code_ret = concat(init_code_ret, processed_val_ret);
                                        first_field_ret = false;
                                    }
                                }
                            }
                            current_ret = str("");
                        } else {
                            current_ret = concat_chr(current_ret, ch_ret);
                        }
                        i_ret = i_ret + 1;
                    }

                    mut part_last_ret: string = strip(current_ret);
                    if str_len(part_last_ret) > 0 {
                        val colon_pos_last_ret: i32 = find_char_from(part_last_ret, ':', 0);
                        if colon_pos_last_ret >= 0 {
                            val field_name_last_ret: string = strip(substring_se(part_last_ret, 0, colon_pos_last_ret));
                            val value_expr_last_ret: string = strip(substr(part_last_ret, colon_pos_last_ret + 1, str_len(part_last_ret) - colon_pos_last_ret - 1));
                            if str_len(field_name_last_ret) > 0 and str_len(value_expr_last_ret) > 0 {
                                if !first_field_ret {
                                    init_code_ret = concat(init_code_ret, str(", "));
                                }
                                init_code_ret = concat(init_code_ret, str("."));
                                init_code_ret = concat(init_code_ret, field_name_last_ret);
                                init_code_ret = concat(init_code_ret, str(" = "));
                                val processed_last_ret: string = process_expression(value_expr_last_ret);
                                init_code_ret = concat(init_code_ret, processed_last_ret);
                                first_field_ret = false;
                            }
                        }
                    }

                    init_code_ret = concat(init_code_ret, str("}"));
                    processed = init_code_ret;
                }
            }
        }

        if str_len(processed) == 0 {
            debug_print_raw "\n[DBG-CALL] process_expression from Return:";
            debug_print_str expr;
            processed = process_expression(expr);
        }
        result = concat(result, processed);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Break") {
        result = concat(result, str("break;\n"));
        return result;
    }
    
    if equals_c(node_type, "Continue") {
        result = concat(result, str("continue;\n"));
        return result;
    }
    
    if equals_c(node_type, "Declaration") {
        val var_name: string = ast.data.declaration.name;
        mut type_name: string = ast.data.declaration.type_name;
        val is_mutable: bool = ast.data.declaration.is_mutable;
        val initializer: string = ast.data.declaration.initializer;
        mut mapped_type: string = map_axe_type_to_c(type_name);

        if str_len(type_name) == 0 {
            mut trimmed_init: string = strip(initializer);
            if has_prefix(trimmed_init, str("new ")) {
                trimmed_init = substring_se(trimmed_init, 4, str_len(trimmed_init));
                trimmed_init = strip(trimmed_init);

                mut end_pos: i32 = -1;
                mut i: i32 = 0;
                loop {
                    if i >= str_len(trimmed_init) {
                        break;
                    }
                    val ch: char = get_char(trimmed_init, i);
                    if ch == '(' or ch == ' ' or ch == '\t' {
                        end_pos = i;
                        break;
                    }
                    i = i + 1;
                }
                if end_pos < 0 {
                    end_pos = str_len(trimmed_init);
                }
                val inferred_name: string = strip(substring_se(trimmed_init, 0, end_pos));
                if str_len(inferred_name) > 0 {
                    type_name = inferred_name;
                    mapped_type = map_axe_type_to_c(type_name);
                }
            } else {
                val brace_pos: i32 = find_char_from(trimmed_init, '{', 0);
                if brace_pos > 0 {
                    val inferred_name2: string = strip(substring_se(trimmed_init, 0, brace_pos));
                    if str_len(inferred_name2) > 0 {
                        type_name = inferred_name2;
                        mapped_type = map_axe_type_to_c(type_name);
                    }
                }
            }
        }

        // Record the declared Axe type for this variable so that later
        // MemberAccess nodes can determine whether the base object should
        // use '.' or '->' in generated C.
        if str_len(var_name) > 0 and str_len(type_name) > 0 {
            mut arena: Arena = Arena.create(256);
            StringStringMap.set(addr(g_var_types), addr(arena), var_name, type_name);
        }

        val enum_model_name: string = canonical_model_c_name(type_name);
        if str_len(enum_model_name) > 0 and StringBoolMap.contains(addr(g_enum_names), enum_model_name) {
            mapped_type = enum_model_name;
        }

        mut array_suffix: string = str("");
        val br: i32 = find_char_from(type_name, '[', 0);
        if br >= 0 {
            val suffix: string = substring_se(type_name, br, str_len(type_name));
            if !equals_c(suffix, "[999]") {
                val base_raw: string = strip(substring_se(type_name, 0, br));
                if str_len(base_raw) > 0 {
                    mapped_type = map_axe_type_to_c(base_raw);
                    array_suffix = suffix;
                }
            }
        }

        if is_mutable {
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
            if str_len(array_suffix) > 0 {
                result = concat(result, array_suffix);
            }
        } else {
            result = concat(result, str("const "));
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
            if str_len(array_suffix) > 0 {
                result = concat(result, array_suffix);
            }
        }
        
        if str_len(initializer) > 0 {
            mut trimmed: string = strip(initializer);
            if has_prefix(trimmed, str("new ")) {
                trimmed = substring_se(trimmed, 4, str_len(trimmed));
                trimmed = strip(trimmed);

                val first_paren: i32 = find_char_from(trimmed, '(', 0);
                if first_paren < 0 {
                    result = concat(result, str(" = {0}"));
                } else {
                    mut last_paren: i32 = -1;
                    mut idx: i32 = str_len(trimmed) - 1;
                    loop {
                        if idx < 0 {
                            break;
                        }
                        val ch_end: char = get_char(trimmed, idx);
                        if ch_end == ')' {
                            last_paren = idx;
                            break;
                        }
                        idx = idx - 1;
                    }

                    if last_paren <= first_paren + 1 {
                        // No arguments
                        result = concat(result, str(" = {0}"));
                    } else {
                        val args_str: string = substring_se(trimmed, first_paren + 1, last_paren);
                        mut init_code: string = str(" = {");

                        mut current: string = str("");
                        mut depth: i32 = 0;
                        mut first_field: bool = true;
                        mut i2: i32 = 0;

                        loop {
                            if i2 >= str_len(args_str) {
                                break;
                            }
                            val ch: char = get_char(args_str, i2);
                            if ch == '(' {
                                depth = depth + 1;
                                current = concat_chr(current, ch);
                            } elif ch == ')' {
                                if depth > 0 {
                                    depth = depth - 1;
                                }
                                current = concat_chr(current, ch);
                            } elif ch == ',' and depth == 0 {
                                mut part: string = strip(current);
                                if str_len(part) > 0 {
                                    val colon_pos: i32 = find_char_from(part, ':', 0);
                                    if colon_pos >= 0 {
                                        val field_name: string = strip(substring_se(part, 0, colon_pos));
                                        val value_expr: string = strip(substr(part, colon_pos + 1, str_len(part) - colon_pos - 1));
                                        if str_len(field_name) > 0 and str_len(value_expr) > 0 {
                                            if !first_field {
                                                init_code = concat(init_code, str(", "));
                                            }
                                            init_code = concat(init_code, str("."));
                                            init_code = concat(init_code, field_name);
                                            init_code = concat(init_code, str(" = "));
                                            init_code = concat(init_code, value_expr);
                                            first_field = false;
                                        }
                                    }
                                }
                                current = str("");
                            } else {
                                current = concat_chr(current, ch);
                            }
                            i2++;
                        }

                        mut part_last: string = strip(current);
                        if str_len(part_last) > 0 {
                            val colon_pos_last: i32 = find_char_from(part_last, ':', 0);
                            if colon_pos_last >= 0 {
                                val field_name_last: string = strip(substring_se(part_last, 0, colon_pos_last));
                                val value_expr_last: string = strip(substr(part_last, colon_pos_last + 1, str_len(part_last) - colon_pos_last - 1));
                                if str_len(field_name_last) > 0 and str_len(value_expr_last) > 0 {
                                    if !first_field {
                                        init_code = concat(init_code, str(", "));
                                    }
                                    init_code = concat(init_code, str("."));
                                    init_code = concat(init_code, field_name_last);
                                    init_code = concat(init_code, str(" = "));
                                    init_code = concat(init_code, value_expr_last);
                                    first_field = false;
                                }
                            }
                        }

                        if first_field {
                            result = concat(result, str(" = {0}"));
                        } else {
                            init_code = concat(init_code, str("}"));
                            result = concat(result, init_code);
                        }
                    }
                }
            } else {
                val brace_pos: i32 = find_char_from(trimmed, '{', 0);
                if brace_pos > 0 and get_char(trimmed, str_len(trimmed) - 1) == '}' {
                    val prefix: string = strip(substring_se(trimmed, 0, brace_pos));
                    val inner: string = substring_se(trimmed, brace_pos + 1, str_len(trimmed) - 1);

                    if (str_len(type_name) == 0 or equals_c(prefix, type_name.data)) {
                        mut init_code2: string = str(" = {");

                        mut current2: string = str("");
                        mut depth2: i32 = 0;
                        mut first_field2: bool = true;
                        mut i3: i32 = 0;

                        loop {
                            if i3 >= str_len(inner) {
                                break;
                            }
                            val ch2: char = get_char(inner, i3);
                            if ch2 == '(' {
                                depth2 = depth2 + 1;
                                current2 = concat_chr(current2, ch2);
                            } elif ch2 == ')' {
                                if depth2 > 0 {
                                    depth2 = depth2 - 1;
                                }
                                current2 = concat_chr(current2, ch2);
                            } elif ch2 == ',' and depth2 == 0 {
                                mut part2: string = strip(current2);
                                if str_len(part2) > 0 {
                                    val colon_pos2: i32 = find_char_from(part2, ':', 0);
                                    if colon_pos2 >= 0 {
                                        val field_name2: string = strip(substring_se(part2, 0, colon_pos2));
                                        val value_expr2: string = strip(substr(part2, colon_pos2 + 1, str_len(part2) - colon_pos2 - 1));
                                        if str_len(field_name2) > 0 and str_len(value_expr2) > 0 {
                                            if !first_field2 {
                                                init_code2 = concat(init_code2, str(", "));
                                            }
                                            init_code2 = concat(init_code2, str("."));
                                            init_code2 = concat(init_code2, field_name2);
                                            init_code2 = concat(init_code2, str(" = "));
                                            init_code2 = concat(init_code2, value_expr2);
                                            first_field2 = false;
                                        }
                                    }
                                }
                                current2 = str("");
                            } else {
                                current2 = concat_chr(current2, ch2);
                            }
                            i3 = i3 + 1;
                        }

                        mut part_last2: string = strip(current2);
                        if str_len(part_last2) > 0 {
                            val colon_pos_last2: i32 = find_char_from(part_last2, ':', 0);
                            if colon_pos_last2 >= 0 {
                                val field_name_last2: string = strip(substring_se(part_last2, 0, colon_pos_last2));
                                val value_expr_last2: string = strip(substr(part_last2, colon_pos_last2 + 1, str_len(part_last2) - colon_pos_last2 - 1));
                                if str_len(field_name_last2) > 0 and str_len(value_expr_last2) > 0 {
                                    if !first_field2 {
                                        init_code2 = concat(init_code2, str(", "));
                                    }
                                    init_code2 = concat(init_code2, str("."));
                                    init_code2 = concat(init_code2, field_name_last2);
                                    init_code2 = concat(init_code2, str(" = "));
                                    init_code2 = concat(init_code2, value_expr_last2);
                                    first_field2 = false;
                                }
                            }
                        }

                        if first_field2 {
                            result = concat(result, str(" = {0}"));
                        } else {
                            init_code2 = concat(init_code2, str("}"));
                            result = concat(result, init_code2);
                        }
                    } else {
                        val processed_init2: string = process_expression(trimmed);
                        result = concat(result, str(" = "));
                        result = concat(result, processed_init2);
                    }
                } else {
                    val paren_pos: i32 = find_char_from(trimmed, '(', 0);
                    if paren_pos > 0 {
                        val call_name_raw: string = strip(substring_se(trimmed, 0, paren_pos));
                        if StringStringMap.contains(addr(g_function_prefixes), call_name_raw) {
                            val full_name: string = StringStringMap.get(addr(g_function_prefixes), call_name_raw);
                            val rest: string = substring_se(trimmed, paren_pos, str_len(trimmed));
                            trimmed = concat(full_name, rest);
                        }
                    }

                    val processed_init: string = process_expression(trimmed);
                    result = concat(result, str(" = "));
                    result = concat(result, processed_init);
                }
            }
        }
        
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Assignment") {
        val variable: string = ast.data.assignment.variable;
        val expression: string = ast.data.assignment.expression;
        
        debug_print_raw "\n[DBG-ASSIGN] Assignment node";
        debug_print_raw "\n[DBG-ASSIGN]   raw variable:";
        debug_print_str variable;
        debug_print_raw "\n[DBG-ASSIGN]   raw expression:";
        debug_print_str expression;

        debug_print_raw "\n[DBG-CALL] process_expression from Assignment.variable:";
        debug_print_str variable;
        val processed_var: string = process_expression(variable);
        debug_print_raw "\n[DBG-CALL] process_expression from Assignment.expression:";
        debug_print_str expression;
        val processed_expr: string = process_expression(expression);

        debug_print_raw "\n[DBG-ASSIGN]   processed variable:";
        debug_print_str processed_var;
        debug_print_raw "\n[DBG-ASSIGN]   processed expression:";
        debug_print_str processed_expr;
        
        val pv: string = processed_var;
        debug_print_raw "\n[DBG-ASSIGN]   pv before fix:";
        debug_print_str pv;

        mut fixed_var: string = str("");
        mut idx_av: i32 = 0;
        loop {
            if idx_av >= str_len(pv) {
                break;
            }
            val chx: char = get_char(pv, idx_av);

            if chx == '(' and idx_av > 0 {
                val prev_ch: char = get_char(pv, idx_av - 1);
                if (prev_ch >= 'a' and prev_ch <= 'z') or
                   (prev_ch >= 'A' and prev_ch <= 'Z') or
                   (prev_ch >= '0' and prev_ch <= '9') or
                   prev_ch == '_' {

                    mut k2: i32 = idx_av + 1;
                    loop {
                        if k2 >= str_len(pv) {
                            break;
                        }
                        val ws2: char = get_char(pv, k2);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        k2 = k2 + 1;
                    }

                    if k2 + 1 < str_len(pv) and
                       get_char(pv, k2) == '-' and
                       get_char(pv, k2 + 1) == '>' {
                        idx_av = k2;
                        continue;
                    }
                }
            }

            fixed_var = concat_chr(fixed_var, chx);
            idx_av = idx_av + 1;
        }

        mut out_lhs: string = fixed_var;
        mut out_rhs: string = processed_expr;
        mut ri: i32 = 0;

        loop {
            if ri >= str_len(processed_expr) {
                break;
            }
            val ws0: char = get_char(processed_expr, ri);
            if ws0 != ' ' and ws0 != '\t' and ws0 != '\n' {
                break;
            }
            ri = ri + 1;
        }

        if ri < str_len(processed_expr) and is_ident_start(get_char(processed_expr, ri)) {
            mut istart: i32 = ri;
            mut j: i32 = ri + 1;
            loop {
                if j >= str_len(processed_expr) {
                    break;
                }
                val cj: char = get_char(processed_expr, j);
                if !((cj >= 'a' and cj <= 'z') or (cj >= 'A' and cj <= 'Z') or (cj >= '0' and cj <= '9') or cj == '_') {
                    break;
                }
                j = j + 1;
            }

            val enum_ident: string = substring_se(processed_expr, istart, j);

            mut k: i32 = j;
            loop {
                if k >= str_len(processed_expr) {
                    break;
                }
                val ws1: char = get_char(processed_expr, k);
                if ws1 != ' ' and ws1 != '\t' and ws1 != '\n' {
                    break;
                }
                k = k + 1;
            }

            if k < str_len(processed_expr) and get_char(processed_expr, k) == '.' {
                k = k + 1;
                loop {
                    if k >= str_len(processed_expr) {
                        break;
                    }
                    val ws2: char = get_char(processed_expr, k);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(processed_expr) and is_ident_start(get_char(processed_expr, k)) {
                    mut mstart: i32 = k;
                    mut m: i32 = k + 1;
                    loop {
                        if m >= str_len(processed_expr) {
                            break;
                        }
                        val cm: char = get_char(processed_expr, m);
                        if !((cm >= 'a' and cm <= 'z') or (cm >= 'A' and cm <= 'Z') or (cm >= '0' and cm <= '9') or cm == '_') {
                            break;
                        }
                        m = m + 1;
                    }

                    val member: string = substring_se(processed_expr, mstart, m);
                    val enum_c_name2: string = canonical_model_c_name(enum_ident);

                    if str_len(enum_c_name2) > 0 {
                        mut rebuilt: string = str("");
                        if ri > 0 {
                            rebuilt = substring_se(processed_expr, 0, ri);
                        }
                        rebuilt = concat(rebuilt, enum_c_name2);
                        rebuilt = concat(rebuilt, str("_"));
                        rebuilt = concat(rebuilt, member);
                        if m < str_len(processed_expr) {
                            val suffix: string = substring_se(processed_expr, m, str_len(processed_expr));
                            rebuilt = concat(rebuilt, suffix);
                        }
                        out_rhs = rebuilt;
                    }
                }
            }
        }

        if has_prefix(processed_expr, str("->")) {
            val eq_pos: i32 = find_char_from(processed_expr, '=', 0);
            if eq_pos > 0 {
                val lhs_suffix: string = substring_se(processed_expr, 0, eq_pos);
                val rhs_suffix: string = substring_se(processed_expr, eq_pos + 1, str_len(processed_expr));

                out_lhs = concat(fixed_var, lhs_suffix);
                out_rhs = strip(rhs_suffix);

                debug_print_raw "\n[DBG-ASSIGN]   reconstructed LHS (arrow sugar):";
                debug_print_str out_lhs;
                debug_print_raw "\n[DBG-ASSIGN]   reconstructed RHS (arrow sugar):";
                debug_print_str out_rhs;
            }
        }

        result = concat(result, out_lhs);
        result = concat(result, str(" = "));
        result = concat(result, out_rhs);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "MemberAccess") {
        val object_name: string = ast.data.member_access.object_name;
        val member_name: string = ast.data.member_access.member_name;
        val value: string = ast.data.member_access.value;
        
        debug_print_raw "\n[DBG-MEM] MemberAccess node";
        debug_print_raw "\n[DBG-MEM]   object_name:";
        debug_print_str object_name;
        debug_print_raw "\n[DBG-MEM]   member_name:";
        debug_print_str member_name;
        debug_print_raw "\n[DBG-MEM]   raw value:";
        debug_print_str value;

        mut access_op: string = str(".");
        mut is_pointer: bool = false;
        val trimmed_obj: string = strip(object_name);
        val arrow_pos: i32 = find_char_from(trimmed_obj, '-', 0);
        if arrow_pos >= 0 and find_char_from(trimmed_obj, '>', arrow_pos) >= 0 {
            is_pointer = true;
        } else {
            if StringStringMap.contains(addr(g_var_types), trimmed_obj) {
                val raw_type: string = StringStringMap.get(addr(g_var_types), trimmed_obj);
                mut t: string = strip(raw_type);

                if has_prefix(t, str("mut ")) {
                    t = strip(substr(t, 4, str_len(t) - 4));
                }

                if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                    is_pointer = true;
                }
            }
        }

        if is_pointer {
            access_op = str("->");
        }

        mut lhs: string = trimmed_obj;
        lhs = concat(lhs, access_op);
        lhs = concat(lhs, member_name);

        result = concat(result, lhs);

        mut trimmed_value: string = strip(value);
        if str_len(trimmed_value) > 0 {
            val processed_value: string = process_expression(trimmed_value);
            debug_print_raw "\n[DEBUG]   processed value:";
            debug_print_str processed_value;
            result = concat(result, str(" = "));
            result = concat(result, processed_value);
        }

        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "ArrayAssign") {
        val array_name: string = ast.data.array_assign.array_name;
        val index_expr: string = ast.data.array_assign.index;
        val index2_expr: string = ast.data.array_assign.index2;
        val value_expr: string = ast.data.array_assign.value;
        
        debug_print_raw "\n[DBG-ARRAYASSIGN] ArrayAssign node";
        debug_print_raw "\n[DBG-ARRAYASSIGN]   array_name:";
        debug_print_str array_name;
        debug_print_raw "\n[DBG-ARRAYASSIGN]   index:";
        debug_print_str index_expr;
        debug_print_raw "\n[DBG-ARRAYASSIGN]   value:";
        debug_print_str value_expr;
        
        val processed_array: string = process_expression(array_name);
        val processed_index: string = process_expression(index_expr);
        val processed_value: string = process_expression(value_expr);
        
        result = concat(result, processed_array);
        result = concat(result, str("["));
        result = concat(result, processed_index);
        result = concat(result, str("]"));
        
        if str_len(index2_expr) > 0 {
            val processed_index2: string = process_expression(index2_expr);
            result = concat(result, str("["));
            result = concat(result, processed_index2);
            result = concat(result, str("]"));
        }
        
        result = concat(result, str(" = "));
        result = concat(result, processed_value);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "FunctionCall") {
        val func_name: string = ast.data.func_call.function_name;

        debug_print_raw "\n[DBG-FUNCCALL] Looking up function:";
        debug_print_str func_name;

        mut emitted_name: string = func_name;
        if StringStringMap.contains(addr(g_function_prefixes), func_name) {
            emitted_name = StringStringMap.get(addr(g_function_prefixes), func_name);
            debug_print_raw "\n[DBG-FUNCCALL]   Found prefix, emitting:";
            debug_print_str emitted_name;
        } else {
            debug_print_raw "\n[DBG-FUNCCALL]   No prefix found, emitting as-is";
        }

        result = concat(result, emitted_name);
        result = concat(result, str("("));
        
        val args: ref list(string) = ast.data.func_call.args;
        if args != nil {
            mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= len(deref(args)) {
                    break;
                }
                
                if arg_idx > 0 {
                    result = concat(result, str(", "));
                }
                val raw_arg: string = args.data[arg_idx];
                val processed_arg: string = process_expression(raw_arg);
                result = concat(result, processed_arg);
                arg_idx++;
            }
        }
        
        result = concat(result, str(");\n"));
        return result;
    }
    
    if equals_c(node_type, "Print") {
        val messages_ref: ref list(string) = ast.data.print.messages;
        val flags_ref: ref list(bool) = ast.data.print.is_expressions;

        if messages_ref == nil or flags_ref == nil {
            return result;
        }

        val messages: list(string) = deref(messages_ref);
        val flags: list(bool) = deref(flags_ref);

        if len(messages) == 0 {
            return result;
        }

        if len(messages) == 1 and len(flags) == 1 and !flags.data[0] {
            result = concat(result, str("printf(\""));
            result = concat(result, messages.data[0]);
            result = concat(result, str("\");\n"));
            return result;
        }

        result = strip_all_c_prefixes(result);
        return result;
    }
    
    if equals_c(node_type, "Loop") {
        result = concat(result, str("while (1) {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        result = concat(result, str("}\n"));
        return result;
    }

    if equals_c(node_type, "Platform") {
        val platform_name: string = ast.data.platform_node.platform_name;

        if equals_c(platform_name, "windows") {
            result = concat(result, str("#ifdef _WIN32\n"));
        } elif equals_c(platform_name, "posix") {
            result = concat(result, str("#ifndef _WIN32\n"));
        }

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }

        result = concat(result, str("#endif\n"));
        return result;
    }
    
    if equals_c(node_type, "For") {
        val init_raw: string = ast.data.for_loop.initialization;
        val cond_raw: string = ast.data.for_loop.condition;
        val incr_raw: string = ast.data.for_loop.increment;

        mut init: string = strip(init_raw);
        mut cond: string = strip(cond_raw);
        mut incr: string = strip(incr_raw);

        if has_prefix(init, str("mut ")) {
            init = strip(substr(init, 4, str_len(init) - 4));
        }

        mut header: string = str("int32_t ");
        header = concat(header, init);
        header = concat(header, str("; "));
        header = concat(header, cond);
        header = concat(header, str("; "));
        header = concat(header, incr);

        header = replace_all(header, str("+ ="), str("+="));
        header = replace_all(header, str("- ="), str("-="));
        header = replace_all(header, str("+  ="), str("+="));
        header = replace_all(header, str("-  ="), str("-="));

        val header_norm: string = process_expression(header);

        result = concat(result, str("for ("));
        result = concat(result, header_norm);
        result = concat(result, str(") {\n"));

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_for: i32 = 0;
            loop {
                if i_for >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_for]));
                result = concat(result, child_code);
                i_for = i_for + 1;
            }
        }

        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "ForIn") {
        // for item in collection { ... }
        // Generate: for (int32_t _i_item = 0; _i_item < collection->len; _i_item++) {
        //              typeof(collection->data[0]) item = collection->data[_i_item];
        //              ... body ...
        //          }
        val var_name: string = ast.data.for_in.var_name;
        val array_name_raw: string = ast.data.for_in.array_name;
        
        mut array_name: string = process_expression(array_name_raw);
        array_name = rewrite_method_calls(array_name);
        array_name = rewrite_function_prefixes(array_name);
        
        mut index_var: string = str("_i_");
        index_var = concat(index_var, var_name);
        
        mut accessor: string = str(".");
        val trimmed_coll: string = strip(array_name_raw);
        if StringStringMap.contains(addr(g_var_types), trimmed_coll) {
            val coll_type: string = StringStringMap.get(addr(g_var_types), trimmed_coll);
            mut t: string = strip(coll_type);
            if has_prefix(t, str("mut ")) {
                t = strip(substr(t, 4, str_len(t) - 4));
            }
            if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                accessor = str("->");
            }
        } else {
            accessor = str("->");
        }
        
        result = concat(result, str("for (int32_t "));
        result = concat(result, index_var);
        result = concat(result, str(" = 0; "));
        result = concat(result, index_var);
        result = concat(result, str(" < "));
        result = concat(result, array_name);
        result = concat(result, accessor);
        result = concat(result, str("len; "));
        result = concat(result, index_var);
        result = concat(result, str("++) {\n"));
        
        result = concat(result, str("typeof("));
        result = concat(result, array_name);
        result = concat(result, accessor);
        result = concat(result, str("data[0]) "));
        result = concat(result, var_name);
        result = concat(result, str(" = "));
        result = concat(result, array_name);
        result = concat(result, accessor);
        result = concat(result, str("data["));
        result = concat(result, index_var);
        result = concat(result, str("];\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_for_in: i32 = 0;
            loop {
                if i_for_in >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_for_in]));
                result = concat(result, child_code);
                i_for_in = i_for_in + 1;
            }
        }
        
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "If") {
        mut current_if: ref ASTNode = ast;
        mut is_first: bool = true;
        
        loop {
            if current_if == nil {
                break;
            }
            
            val condition: string = current_if.data.if_node.condition;
            mut trimmed_cond: string = strip(condition);
            trimmed_cond = process_expression(trimmed_cond);

            if is_first {
                result = concat(result, str("if ("));
            } else {
                result = concat(result, str("else if ("));
            }
            result = concat(result, trimmed_cond);
            result = concat(result, str(") {\n"));
            is_first = false;

            mut else_marker_idx: i32 = -1;
            if current_if.children != nil {
                val children: ref list(ASTNode) = current_if.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_ref: ref ASTNode = addr(children.data[i]);
                    if equals_c(child_ref.node_type, "ElseMarker") {
                        else_marker_idx = i;
                        break;
                    }
                    val child_code: string = generate_c(child_ref);
                    result = concat(result, child_code);
                    i = i + 1;
                }
            }

            result = concat(result, str("}\n"));

            if current_if.children != nil and else_marker_idx >= 0 {
                val children: ref list(ASTNode) = current_if.children;
                val child_count: i32 = len(deref(children));
                
                if else_marker_idx + 1 < child_count {
                    val first_else_child: ref ASTNode = addr(children.data[else_marker_idx + 1]);
                    
                    if equals_c(first_else_child.node_type, "If") and else_marker_idx + 2 == child_count {
                        current_if = first_else_child;
                        continue;
                    } else {
                        result = concat(result, str("else {\n"));
                        mut j: i32 = else_marker_idx + 1;
                        loop {
                            if j >= child_count {
                                break;
                            }
                            val else_child: ref ASTNode = addr(children.data[j]);
                            val else_code: string = generate_c(else_child);
                            result = concat(result, else_code);
                            j = j + 1;
                        }
                        result = concat(result, str("}\n"));
                        break;
                    }
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        return result;
    }
    
    if equals_c(node_type, "Unsafe") {
        val body: ref list(ASTNode) = ast.data.unsafe_node.body;
        if body != nil {
            mut i_unsafe: i32 = 0;
            loop {
                if i_unsafe >= len(deref(body)) {
                    break;
                }
                val child_code: string = generate_c(addr(body.data[i_unsafe]));
                debug_print_raw "\n[DBG-UNSAFE] Processing unsafe block child (index ";
                debug_print_str int_to_ascii(i_unsafe);
                debug_print_raw ")\n";
                debug_print_str child_code;
                result = concat(result, child_code);
                i_unsafe++;
            }
        }
        debug_print_raw "\n[DBG-UNSAFE] Before method call transformation:";
        debug_print_str result;
        result = rewrite_method_calls(result);
        debug_print_raw "\n[DBG-UNSAFE] After method call transformation:";
        debug_print_str result;
        result = rewrite_function_prefixes(result);
        debug_print_raw "\n[DBG-UNSAFE] After function prefix transformation:";
        debug_print_str result;
        return result;
    }

    if equals_c(node_type, "RawC") {
        val raw_code: string = ast.data.raw_c.code;
        debug_print_raw "\n[DBG-RAWC] RawC node emitting:";
        debug_print_str raw_code;
        result = concat(result, raw_code);
        result = concat(result, str("\n"));
        return result;
    }
    
    if equals_c(node_type, "Model") {
        val model_name: string = ast.data.model_node.name;
        val is_public: bool = ast.data.model_node.is_public;
        val field_names: ref list(string) = ast.data.model_node.field_names;
        val field_types: ref list(string) = ast.data.model_node.field_types;
        val union_parents: ref list(string) = ast.data.model_node.union_member_parents;
        val union_names: ref list(string) = ast.data.model_node.union_member_names;
        val union_types: ref list(string) = ast.data.model_node.union_member_types;

        if StringBoolMap.contains(addr(g_generated_typedefs), model_name) {
            return str("");
        }

        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr(g_generated_typedefs), addr(arena), model_name, true);

        result = concat(result, str("typedef struct "));
        result = concat(result, model_name);
        result = concat(result, str(" {\n"));

        if field_names != nil and field_types != nil {
            mut field_idx: i32 = 0;
            loop {
                if field_idx >= len(deref(field_names)) {
                    break;
                }

                val field_name: string = field_names.data[field_idx];
                val field_type: string = field_types.data[field_idx];
                mut field_key: string = model_name;

                field_key = concat(field_key, str("."));
                field_key = concat(field_key, field_name);

                StringStringMap.set(addr(g_field_types), addr(arena), field_key, field_type);

                if str_len(field_type) == 5 and equals_c(field_type, "union") and union_parents != nil and union_names != nil and union_types != nil {
                    result = concat(result, str("    union {\n"));

                    val up: list(string) = deref(union_parents);
                    val un: list(string) = deref(union_names);
                    val ut: list(string) = deref(union_types);

                    mut uidx: i32 = 0;
                    loop {
                        if uidx >= len(up) or uidx >= len(un) or uidx >= len(ut) {
                            break;
                        }

                        val parent_name: string = up.data[uidx];
                        if compare(parent_name, field_name) == 0 {
                            val member_name: string = un.data[uidx];
                            val member_type_raw: string = ut.data[uidx];

                            if str_len(member_type_raw) == 5 and equals_c(member_type_raw, "model") {
                                result = concat(result, str("        struct {\n"));

                                mut nidx: i32 = 0;
                                loop {
                                    if nidx >= len(up) or nidx >= len(un) or nidx >= len(ut) {
                                        break;
                                    }

                                    val nested_parent: string = up.data[nidx];
                                    if compare(nested_parent, member_name) == 0 {
                                        val nested_name: string = un.data[nidx];
                                        val nested_type_raw: string = ut.data[nidx];

                                        mut mapped_nested_type: string = map_axe_type_to_c(nested_type_raw);
                                        mut nested_array_part: string = str("");

                                        val n_bracket_pos: i32 = find_char_from(mapped_nested_type, '[', 0);
                                        if n_bracket_pos >= 0 {
                                            nested_array_part = substring_se(mapped_nested_type, n_bracket_pos, str_len(mapped_nested_type));
                                            mapped_nested_type = substring_se(mapped_nested_type, 0, n_bracket_pos);
                                        }

                                        if has_prefix(mapped_nested_type, str("ref ")) {
                                            mapped_nested_type = concat(strip(substring_se(mapped_nested_type, 4, str_len(mapped_nested_type))), str("*"));
                                        }

                                        val c_nested_model_name: string = canonical_model_c_name(mapped_nested_type);
                                        if str_len(c_nested_model_name) > 0 {
                                            if StringBoolMap.contains(addr(g_enum_names), c_nested_model_name) {
                                                mapped_nested_type = c_nested_model_name;
                                            } else {
                                                mapped_nested_type = concat(str("struct "), c_nested_model_name);
                                            }
                                        }

                                        result = concat(result, str("            "));
                                        result = concat(result, mapped_nested_type);
                                        result = concat(result, str(" "));
                                        result = concat(result, nested_name);
                                        result = concat(result, nested_array_part);
                                        result = concat(result, str(";\n"));
                                    }

                                    nidx = nidx + 1;
                                }

                                result = concat(result, str("        } "));
                                result = concat(result, member_name);
                                result = concat(result, str(";\n"));
                            } else {
                                mut mapped_member_type: string = map_axe_type_to_c(member_type_raw);
                                mut member_array_part: string = str("");

                                val m_bracket_pos: i32 = find_char_from(mapped_member_type, '[', 0);
                                if m_bracket_pos >= 0 {
                                    member_array_part = substring_se(mapped_member_type, m_bracket_pos, str_len(mapped_member_type));
                                    mapped_member_type = substring_se(mapped_member_type, 0, m_bracket_pos);
                                }

                                if has_prefix(mapped_member_type, str("ref ")) {
                                    mapped_member_type = concat(strip(substring_se(mapped_member_type, 4, str_len(mapped_member_type))), str("*"));
                                }

                                val c_member_model_name: string = canonical_model_c_name(mapped_member_type);
                                if str_len(c_member_model_name) > 0 {
                                    if StringBoolMap.contains(addr(g_enum_names), c_member_model_name) {
                                        mapped_member_type = c_member_model_name;
                                    } else {
                                        mapped_member_type = concat(str("struct "), c_member_model_name);
                                    }
                                }

                                result = concat(result, str("        "));
                                result = concat(result, mapped_member_type);
                                result = concat(result, str(" "));
                                result = concat(result, member_name);
                                result = concat(result, member_array_part);
                                result = concat(result, str(";\n"));
                            }
                        }

                        uidx = uidx + 1;
                    }

                    result = concat(result, str("    } "));
                    result = concat(result, field_name);
                    result = concat(result, str(";\n"));
                } else {
                    mut mapped_type: string = map_axe_type_to_c(field_type);
                    mut array_part: string = str("");

                    val bracket_pos: i32 = find_char_from(mapped_type, '[', 0);
                    if bracket_pos >= 0 {
                        array_part = substring_se(mapped_type, bracket_pos, str_len(mapped_type));
                        mapped_type = substring_se(mapped_type, 0, bracket_pos);
                    }

                    if has_prefix(mapped_type, str("ref ")) {
                        mapped_type = concat(strip(substring_se(mapped_type, 4, str_len(mapped_type))), str("*"));
                    }

                    val c_model_name: string = canonical_model_c_name(mapped_type);
                    if str_len(c_model_name) > 0 {
                        if StringBoolMap.contains(addr(g_enum_names), c_model_name) {
                            mapped_type = c_model_name;
                        } else {
                            mapped_type = concat(str("struct "), c_model_name);
                        }
                    }

                    result = concat(result, str("    "));
                    result = concat(result, mapped_type);
                    result = concat(result, str(" "));
                    result = concat(result, field_name);
                    result = concat(result, array_part);
                    result = concat(result, str(";\n"));
                }

                field_idx++;
            }
        }

        result = concat(result, str("} "));
        result = concat(result, model_name);
        result = concat(result, str(";\n\n"));
        return result;
    }

    if equals_c(node_type, "Enum") {
        val enum_name: string = ast.data.enum_node.name;
        val enum_values: ref list(string) = ast.data.enum_node.values;
        
        if StringBoolMap.contains(addr(g_generated_typedefs), enum_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr(g_generated_typedefs), addr(arena), enum_name, true);
        StringBoolMap.set(addr(g_enum_names), addr(arena), enum_name, true);
        
        mut base_enum_name: string = enum_name;
        mut last_sep_enum: i32 = -1;
        mut ei: i32 = 0;
        val elen: i32 = str_len(enum_name);
        loop {
            if ei + 1 >= elen {
                break;
            }
            val ec1: char = get_char(enum_name, ei);
            val ec2: char = get_char(enum_name, ei + 1);
            if ec1 == '_' and ec2 == '_' {
                last_sep_enum = ei;
            }
            ei = ei + 1;
        }

        if last_sep_enum >= 0 and last_sep_enum + 2 < elen {
            base_enum_name = substring_se(enum_name, last_sep_enum + 2, elen);
        }

        if str_len(base_enum_name) > 0 {
            StringStringMap.set(addr(g_model_names), addr(arena), base_enum_name, enum_name);
            StringBoolMap.set(addr(g_enum_names), addr(arena), base_enum_name, true);
        }
        
        result = concat(result, str("typedef enum {\n"));
        
        if enum_values != nil {
            mut value_idx: i32 = 0;
            val num_values: i32 = len(deref(enum_values));
            
            loop {
                if value_idx >= num_values {
                    break;
                }
                
                val enum_value: string = enum_values.data[value_idx];
                
                result = concat(result, str("    "));
                result = concat(result, enum_name);
                result = concat(result, str("_"));
                result = concat(result, enum_value);
                
                if value_idx < num_values - 1 {
                    result = concat(result, str(","));
                }
                result = concat(result, str("\n"));
                
                value_idx++;
            }
        }
        
        result = concat(result, str("} "));
        result = concat(result, enum_name);
        result = concat(result, str(";\n\n"));
        
        return result;
    }

    if equals_c(node_type, "Extern") {
        val func_name: string = ast.data.extern_node.function_name;
        mut arena: Arena = Arena.create(256);
        StringBoolMap.set(addr(g_generated_functions), addr(arena), func_name, true);
        return str("");
    }
    
    if equals_c(node_type, "Opaque") {
        mut onames: ref list(string) = ast.data.opaque_node.type_names;
        if onames != nil {
            mut oi: i32 = 0;
            loop {
                if oi >= len(deref(onames)) {
                    break;
                }
                val type_name: string = onames.data[oi];
                result = concat(result, str("typedef struct "));
                result = concat(result, type_name);
                result = concat(result, str(" "));
                result = concat(result, type_name);
                result = concat(result, str(";\n"));
                oi++;
            }
        }
        return result;
    }
    
    if equals_c(node_type, "IncDec") {
        val variable: string = ast.data.inc_dec.variable;
        val is_increment: bool = ast.data.inc_dec.is_increment;
        
        result = concat(result, variable);
        if is_increment {
            result = concat(result, str("++"));
        } else {
            result = concat(result, str("--"));
        }
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "MemberIncDec") {
        val object_name: string = ast.data.member_inc_dec.object_name;
        val member_name: string = ast.data.member_inc_dec.member_name;
        val is_increment: bool = ast.data.member_inc_dec.is_increment;
        mut access_op: string = str(".");
        val trimmed_obj: string = strip(object_name);

        if StringStringMap.contains(addr(g_var_types), trimmed_obj) {
            val raw_type: string = StringStringMap.get(addr(g_var_types), trimmed_obj);
            mut t: string = strip(raw_type);
            if has_prefix(t, str("mut ")) {
                t = strip(substr(t, 4, str_len(t) - 4));
            }
            if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                access_op = str("->");
            }
        }
        
        result = concat(result, trimmed_obj);
        result = concat(result, access_op);
        result = concat(result, member_name);
        if is_increment {
            result = concat(result, str("++"));
        } else {
            result = concat(result, str("--"));
        }
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "PtrMemberIncDec") {
        val ptr_object: string = ast.data.member_inc_dec.object_name;
        val ptr_member: string = ast.data.member_inc_dec.member_name;
        val ptr_is_inc: bool = ast.data.member_inc_dec.is_increment;
        
        result = concat(result, strip(ptr_object));
        result = concat(result, str("->"));
        result = concat(result, ptr_member);
        if ptr_is_inc {
            result = concat(result, str("++"));
        } else {
            result = concat(result, str("--"));
        }
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "PtrMemberAccess") {
        val ptr_obj: string = ast.data.member_access.object_name;
        val ptr_memb: string = ast.data.member_access.member_name;
        val ptr_val: string = ast.data.member_access.value;
        
        result = concat(result, strip(ptr_obj));
        result = concat(result, str("->"));
        result = concat(result, ptr_memb);
        
        if str_len(strip(ptr_val)) > 0 {
            result = concat(result, str(" = "));
            val processed_ptr_val: string = process_expression(ptr_val);
            result = concat(result, processed_ptr_val);
        }
        result = concat(result, str(";\n"));
        return result;
    }
    
    return result;
}

test {
    initialize_renderer();
    
    println "\nTest 1: Initialize renderer";
    assert StringStringMap.contains(addr(g_type_mappings), str("i32")), "Expected i32 type mapping";
    assert equals_c(map_type(str("i32")), "int32_t"), "Expected i32 to map to int32_t";
    
    println "\nTest 2: Map types";
    assert equals_c(map_type(str("i64")), "int64_t"), "Expected i64 to map to int64_t";
    assert equals_c(map_type(str("f32")), "float"), "Expected f32 to map to float";
    assert equals_c(map_type(str("bool")), "bool"), "Expected bool to map to bool";
    
    println "\nTest 3: Generate empty program";
    mut empty_ast: ASTNode;
    empty_ast.node_type = str("Program");
    empty_ast.children = nil;
    val code: string = generate_c(addr(empty_ast));
    assert str_contains_c(code, "#include <stdio.h>"), "Expected stdio.h include";
    assert str_contains_c(code, "#include <stdint.h>"), "Expected stdint.h include";
    
    println "\nTest 4: Generate main function";
    mut func_ast: ASTNode;
    func_ast.node_type = str("Function");
    func_ast.data.function.name = str("main");
    func_ast.data.function.return_type = str("i32");
    func_ast.data.function.is_public = false;
    func_ast.data.function.params = nil;
    func_ast.children = nil;
    val func_code: string = generate_c(addr(func_ast));
    assert str_contains_c(func_code, "int main"), "Expected int main function";
    assert str_contains_c(func_code, "return 0;"), "Expected return 0 in main";

    mut model_arena: Arena = Arena.create(4096);

    println "\nTest 5: Generate simple function";
    mut simple_func: ASTNode;
    simple_func.node_type = str("Function");
    simple_func.data.function.name = str("add");
    simple_func.data.function.return_type = str("i32");
    simple_func.data.function.is_public = false;
    simple_func.data.function.params = nil;
    simple_func.children = nil;
    val simple_code: string = generate_c(addr(simple_func));
    assert str_contains_c(simple_code, "int32_t add"), "Expected int32_t add function";
    
    println "\nTest 6: Process parameter types";
    assert equals_c(process_parameter_type(str("i32")), "int32_t"), "Expected i32 -> int32_t";
    assert equals_c(process_parameter_type(str("ref i32")), "int32_t*"), "Expected ref i32 -> int32_t*";
    assert equals_c(process_parameter_type(str("mut i32")), "int32_t"), "Expected mut i32 -> int32_t";
    assert equals_c(process_parameter_type(str("i32*")), "int32_t*"), "Expected i32* -> int32_t*";
    
    println "\nTest 7: Generate simple model";
    mut model_ast: ASTNode;
    model_ast.node_type = str("Model");
    model_ast.data.model_node.name = str("Point");
    model_ast.data.model_node.is_public = false;
    
    val field_names_list: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names_list, addr(model_arena), str("x"));
    StringList.push(field_names_list, addr(model_arena), str("y"));
    model_ast.data.model_node.field_names = field_names_list;
    
    val field_types_list: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types_list, addr(model_arena), str("i32"));
    StringList.push(field_types_list, addr(model_arena), str("i32"));
    model_ast.data.model_node.field_types = field_types_list;
    
    model_ast.children = nil;
    val model_code: string = generate_c(addr(model_ast));
    assert str_contains_c(model_code, "struct Point"), "Expected struct Point";
    assert str_contains_c(model_code, "int32_t x"), "Expected int32_t x field";
    assert str_contains_c(model_code, "int32_t y"), "Expected int32_t y field";
    
    println "\nTest 8: Generate model with different types";
    mut model2_ast: ASTNode;
    model2_ast.node_type = str("Model");
    model2_ast.data.model_node.name = str("Person");
    model2_ast.data.model_node.is_public = true;
    
    val field_names2: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names2, addr(model_arena), str("age"));
    StringList.push(field_names2, addr(model_arena), str("height"));
    StringList.push(field_names2, addr(model_arena), str("active"));
    model2_ast.data.model_node.field_names = field_names2;
    
    val field_types2: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types2, addr(model_arena), str("i32"));
    StringList.push(field_types2, addr(model_arena), str("f32"));
    StringList.push(field_types2, addr(model_arena), str("bool"));
    model2_ast.data.model_node.field_types = field_types2;
    
    model2_ast.children = nil;
    val model2_code: string = generate_c(addr(model2_ast));
    assert str_contains_c(model2_code, "struct Person"), "Expected struct Person";
    assert str_contains_c(model2_code, "int32_t age"), "Expected int32_t age field";
    assert str_contains_c(model2_code, "float height"), "Expected float height field";
    assert str_contains_c(model2_code, "bool active"), "Expected bool active field";
    
    println "\nTest 9: Model with array field";
    mut model3_ast: ASTNode;
    model3_ast.node_type = str("Model");
    model3_ast.data.model_node.name = str("Buffer");
    model3_ast.data.model_node.is_public = false;
    
    val field_names3: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names3, addr(model_arena), str("data"));
    model3_ast.data.model_node.field_names = field_names3;
    
    val field_types3: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types3, addr(model_arena), str("i32[100]"));
    model3_ast.data.model_node.field_types = field_types3;
    
    model3_ast.children = nil;
    val model3_code: string = generate_c(addr(model3_ast));
    assert str_contains_c(model3_code, "struct Buffer"), "Expected struct Buffer";
    assert str_contains_c(model3_code, "int32_t data[100]"), "Expected array field";
    
    println "\nTest 10: Model with pointer field";
    mut model4_ast: ASTNode;
    model4_ast.node_type = str("Model");
    model4_ast.data.model_node.name = str("Node");
    model4_ast.data.model_node.is_public = false;
    
    val field_names4: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names4, addr(model_arena), str("value"));
    StringList.push(field_names4, addr(model_arena), str("next"));
    model4_ast.data.model_node.field_names = field_names4;
    
    val field_types4: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types4, addr(model_arena), str("i32"));
    StringList.push(field_types4, addr(model_arena), str("ref Node"));
    model4_ast.data.model_node.field_types = field_types4;
    
    model4_ast.children = nil;
    val model4_code: string = generate_c(addr(model4_ast));
    assert str_contains_c(model4_code, "struct Node"), "Expected struct Node";
    assert str_contains_c(model4_code, "int32_t value"), "Expected value field";
    assert str_contains_c(model4_code, "Node* next"), "Expected pointer field";
    
    println "\nTest 11: Test helper functions";
    assert equals_c(map_axe_type_to_c(str("i32")), "int32_t"), "Expected i32 mapping";
    assert equals_c(map_axe_type_to_c(str("ref i64")), "int64_t*"), "Expected ref i64 mapping";
    assert equals_c(map_axe_type_to_c(str("mut f32")), "float"), "Expected mut f32 mapping";
    
    println "\nTest 12: Generate enum";
    mut enum_ast: ASTNode;
    enum_ast.node_type = str("Enum");
    enum_ast.data.enum_node.name = str("Color");
    
    val enum_values: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(enum_values, addr(model_arena), str("Red"));
    StringList.push(enum_values, addr(model_arena), str("Green"));
    StringList.push(enum_values, addr(model_arena), str("Blue"));
    enum_ast.data.enum_node.values = enum_values;
    
    enum_ast.children = nil;
    val enum_code: string = generate_c(addr(enum_ast));
    assert str_contains_c(enum_code, "typedef enum"), "Expected typedef enum";
    assert str_contains_c(enum_code, "Color_Red"), "Expected Color_Red value";
    assert str_contains_c(enum_code, "Color_Green"), "Expected Color_Green value";
    assert str_contains_c(enum_code, "Color_Blue"), "Expected Color_Blue value";
    assert str_contains_c(enum_code, "} Color;"), "Expected } Color;";

    println "\nTest 15: List types tracking and mapping";

    val list_map_val: string = map_axe_type_to_c(str("i32[999]"));
    assert str_contains_c(list_map_val, "__list_int32_t"), "Expected list(i32) mapping to a __list name";

    val list_map_ref: string = map_axe_type_to_c(str("ref i32[999]"));
    assert str_contains_c(list_map_ref, "__list_int32_t"), "Expected ref list(i32) mapping to a __list name";

    mut found_int32: bool = false;
    if g_list_elements != nil {
        val lstref: ref StringList = g_list_elements;
        mut k: i32 = 0;
        loop {
            if k >= lstref*.len {
                break;
            }
            val s: string = StringList.get(lstref, k);
            if equals_c(s, "int32_t") {
                found_int32 = true;
                break;
            }
            k = k + 1;
        }
    }

    assert found_int32, "Expected int32_t to be tracked as a list element type";

    println "\nTest 13: MemberAccess assignment";
    mut member_assign_ast: ASTNode;
    member_assign_ast.node_type = str("MemberAccess");
    member_assign_ast.data.member_access.object_name = str("obj");
    member_assign_ast.data.member_access.member_name = str("field");
    member_assign_ast.data.member_access.value = str("42");
    val member_assign_code: string = generate_c(addr(member_assign_ast));
    assert str_contains_c(member_assign_code, "obj.field = 42;"), "Expected obj.field = 42;";

    println "\nTest 14: MemberAccess read";
    mut member_read_ast: ASTNode;
    member_read_ast.node_type = str("MemberAccess");
    member_read_ast.data.member_access.object_name = str("obj");
    member_read_ast.data.member_access.member_name = str("field");
    member_read_ast.data.member_access.value = str("");
    val member_read_code: string = generate_c(addr(member_read_ast));
    assert str_contains_c(member_read_code, "obj.field;"), "Expected obj.field; for read";
}
