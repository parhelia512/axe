// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
// 
// Handles the rendering process.

use structs     (ASTNode);
use std.lists   (StringList);
use std.string;
use std.io;
use std.maps;

/// Type mappings from Axe to C
mut g_type_mappings: StringStringMap;

/// Track reference depths for variables
mut g_ref_depths: StringIntMap;

/// Track mutability
mut g_is_mutable: StringBoolMap;

/// Function prefixes for imported modules
mut g_function_prefixes: StringStringMap;

/// Model name mappings
mut g_model_names: StringStringMap;

/// Enum names
mut g_enum_names: StringBoolMap;

/// Generated typedefs to avoid duplicates
mut g_generated_typedefs: StringBoolMap;

/// Generated functions to avoid duplicates
mut g_generated_functions: StringBoolMap;

/// Field types for models
mut g_field_types: StringStringMap;

/// Variable types
mut g_var_types: StringStringMap;

/// Initialize renderer globals
pub def initialize_renderer() {
    mut arena: Arena = Arena.create(1024 * 1024);
    
    g_type_mappings = deref(StringStringMap.create(addr_of(arena), 128));
    g_ref_depths = deref(StringIntMap.create(addr_of(arena), 128));
    g_is_mutable = deref(StringBoolMap.create(addr_of(arena), 128));
    g_function_prefixes = deref(StringStringMap.create(addr_of(arena), 128));
    g_model_names = deref(StringStringMap.create(addr_of(arena), 128));
    g_enum_names = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_typedefs = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_functions = deref(StringBoolMap.create(addr_of(arena), 128));
    g_field_types = deref(StringStringMap.create(addr_of(arena), 128));
    g_var_types = deref(StringStringMap.create(addr_of(arena), 128));
    
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i8"), str("int8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u8"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i16"), str("int16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u16"), str("uint16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i32"), str("int32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u32"), str("uint32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i64"), str("int64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u64"), str("uint64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("isize"), str("intptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("usize"), str("uintptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f32"), str("float"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f64"), str("double"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("bool"), str("bool"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("char"), str("char"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("rchar"), str("char*"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("byte"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("ptrdiff"), str("isize"));
}

def build_function_prefixes(ast: ref ASTNode) {
    StringStringMap.clear(addr_of(g_function_prefixes));

    if ast == nil or ast.children == nil {
        return;
    }

    val children: ref list(ASTNode) = ast.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }

        val child: ref ASTNode = addr_of(children.data[i]);
        if equals_c(child.node_type, "Function") {
            val full_name: string = child.data.function.name;

            mut last_sep: i32 = -1;
            mut j: i32 = 0;
            val n: i32 = str_len(full_name);
            loop {
                if j + 1 >= n {
                    break;
                }
                val c1: char = get_char(full_name, j);
                val c2: char = get_char(full_name, j + 1);
                if c1 == '_' and c2 == '_' {
                    last_sep = j;
                }
                j = j + 1;
            }

            if last_sep >= 0 and last_sep + 2 < n {
                val short_name: string = substring_se(full_name, last_sep + 2, n);

                if str_len(short_name) > 0 {
                    if !StringStringMap.contains(addr_of(g_function_prefixes), short_name) {
                        mut arena: Arena = Arena.create(256);
                        StringStringMap.set(addr_of(g_function_prefixes), addr_of(arena), short_name, full_name);
                    }
                }
            }
        }

        i = i + 1;
    }
}

/// Map Axe type to C type
def map_type(axe_type: string): string {
    if StringStringMap.contains(addr_of(g_type_mappings), axe_type) {
        return StringStringMap.get(addr_of(g_type_mappings), axe_type);
    }
    return axe_type;
}

/// Get canonical model C name from g_model_names
def canonical_model_c_name(name: string): string {
    if StringStringMap.contains(addr_of(g_model_names), name) {
        return StringStringMap.get(addr_of(g_model_names), name);
    }
    return str("");
}

/// Map Axe type to C type (comprehensive version for model fields)
def map_axe_type_to_c(axe_type: string): string {
    mut result: string = axe_type;
    
    // Handle mut prefix
    if has_prefix(result, str("mut ")) {
        result = strip(substr(result, 4, str_len(result) - 4));
        return map_axe_type_to_c(result);
    }
    
    // Handle list types [999]
    if has_suffix(result, str("[999]")) {
        val element_type: string = strip(substring_se(result, 0, str_len(result) - 5));
        if has_prefix(element_type, str("ref ")) {
            val base_elem: string = strip(substr(element_type, 4, str_len(element_type) - 4));
            val mapped_elem: string = map_axe_type_to_c(base_elem);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t*"));
            return struct_name;
        } else {
            val mapped_elem: string = map_axe_type_to_c(element_type);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t"));
            return struct_name;
        }
    }
    
    // Handle ref prefix
    if has_prefix(result, str("ref ")) {
        val base_type: string = strip(substr(result, 4, str_len(result) - 4));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    // Handle pointer suffix
    if has_suffix(result, str("*")) {
        val base_type: string = strip(substring_se(result, 0, str_len(result) - 1));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    // Check type mappings
    if StringStringMap.contains(addr_of(g_type_mappings), result) {
        return StringStringMap.get(addr_of(g_type_mappings), result);
    }
    
    // Check model names
    if StringStringMap.contains(addr_of(g_model_names), result) {
        return StringStringMap.get(addr_of(g_model_names), result);
    }
    
    return result;
}

/// Format model field type with proper struct prefix
def format_model_field_type(field_type: string): string {
    mut trimmed: string = strip(field_type);
    mut qualifiers: string = str("");
    
    loop {
        if !has_prefix(trimmed, str("const ")) {
            break;
        }
        qualifiers = concat(qualifiers, str("const "));
        trimmed = strip(substr(trimmed, 6, str_len(trimmed) - 6));
    }
    
    mut had_struct_prefix: bool = false;
    if has_prefix(trimmed, str("struct ")) {
        had_struct_prefix = true;
        trimmed = strip(substr(trimmed, 7, str_len(trimmed) - 7));
    }
    
    mut pointer_suffix: string = str("");
    loop {
        val len: i32 = str_len(trimmed);
        if len == 0 {
            break;
        }
        val last_char: char = get_char(trimmed, len - 1);
        if last_char != '*' {
            break;
        }
        pointer_suffix = concat(pointer_suffix, str("*"));
        trimmed = strip(substring_se(trimmed, 0, len - 1));
    }
    
    val model_name: string = canonical_model_c_name(trimmed);
    if str_len(model_name) > 0 {
        if StringBoolMap.contains(addr_of(g_enum_names), model_name) {
            trimmed = model_name;
        } else {
            trimmed = concat(str("struct "), model_name);
        }
    } else {
        if had_struct_prefix {
            trimmed = concat(str("struct "), trimmed);
        }
    }
    
    mut final_result: string = qualifiers;
    final_result = concat(final_result, trimmed);
    final_result = concat(final_result, pointer_suffix);
    return final_result;
}

/// Process parameter type (handle ref, mut, pointers, etc.)
def process_parameter_type(param_type: string): string {
    // Delegate to the comprehensive Axe->C mapper so that 'mut', repeated
    // 'ref' prefixes, list[999] sugar, and pointer suffixes are handled
    // consistently. Examples:
    //
    //   'char'          -> 'char'
    //   'ref char'      -> 'char*'
    //   'ref ref char'  -> 'char**'
    //   'ref MyModel*'  -> 'struct ...* *'

    mut result: string = strip(param_type);
    return map_axe_type_to_c(result);
}

/// Process an expression string for C interop and pointer sugar
def process_expression(expr: string): string {
    mut trimmed: string = strip(expr);
    mut has_pointer_sugar: bool = false;
    mut in_string: bool = false;
    mut i: i32 = 0;

    loop {
        if i >= str_len(trimmed) {
            break;
        }
        val ch: char = get_char(trimmed, i);
        if ch == '"' and (i == 0 or get_char(trimmed, i - 1) != '\\') {
            in_string = !in_string;
        } elif !in_string and ch == '*' and i + 1 < str_len(trimmed) and get_char(trimmed, i + 1) == '.' {
            has_pointer_sugar = true;
            break;
        }
        i = i + 1;
    }

    mut has_c_prefix: bool = false;
    if str_len(trimmed) >= 2 {
        if get_char(trimmed, 0) == 'C' and get_char(trimmed, 1) == '.' {
            has_c_prefix = true;
        }
    }

    if !has_pointer_sugar and !has_c_prefix {
        return trimmed;
    }

    mut result: string = trimmed;

    if has_pointer_sugar {
        mut out: string = str("");
        mut in_str2: bool = false;
        mut j: i32 = 0;
        loop {
            if j >= str_len(result) {
                break;
            }
            val ch2: char = get_char(result, j);
            if ch2 == '"' and (j == 0 or get_char(result, j - 1) != '\\') {
                in_str2 = !in_str2;
                out = concat_chr(out, ch2);
            } elif !in_str2 and j + 1 < str_len(result) and ch2 == '*' and get_char(result, j + 1) == '.' {
                out = concat(out, str("->"));
                j = j + 1;
            } else {
                out = concat_chr(out, ch2);
            }
            j = j + 1;
        }
        result = out;
    }

    if has_c_prefix {
        result = substring_se(result, 2, str_len(result));
    }

    return result;
}

/// Generate a C function prototype from a Function AST node
def generate_function_prototype(ast: ref ASTNode): string {
    mut result: string = str("");

    if ast == nil {
        return result;
    }

    val func_name_raw: string = ast.data.function.name;

    // Do not emit a prototype for main
    if equals_c(func_name_raw, "main") {
        return result;
    }

    mut func_name: string = func_name_raw;
    mut return_type: string = ast.data.function.return_type;

    if str_len(return_type) == 0 {
        return_type = str("void");
    }

    val mapped_return_type: string = map_type(return_type);

    result = concat(result, mapped_return_type);
    result = concat(result, str(" "));
    result = concat(result, func_name);
    result = concat(result, str("("));

    val params: ref list(string) = ast.data.function.params;
    if params != nil {
        mut param_idx: i32 = 0;
        loop {
            if param_idx >= len(deref(params)) {
                break;
            }

            if param_idx > 0 {
                result = concat(result, str(", "));
            }

            val param: string = params.data[param_idx];
            val colon_pos: i32 = find_char_from(param, ':', 0);

            if colon_pos >= 0 {
                val param_name: string = strip(substring_se(param, 0, colon_pos));
                val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                val processed_type: string = process_parameter_type(param_type);

                result = concat(result, processed_type);
                result = concat(result, str(" "));
                result = concat(result, param_name);
            } else {
                result = concat(result, param);
            }

            param_idx = param_idx + 1;
        }
    }

    result = concat(result, str(");\n"));
    return result;
}

/// Generate C code from AST
pub def generate_c(ast: ref ASTNode): string {
    mut result: string = str("");
    
    if ast == nil {
        return result;
    }
    val node_type: string = ast.node_type;

    if equals_c(node_type, "Overload") {
        val name: string = ast.data.overload_node.name;
        mut param_name: string = ast.data.overload_node.param_name;
        mut call_expr: string = ast.data.overload_node.call_expr;

        if str_len(param_name) == 0 {
            param_name = str("x");
        }
        if str_len(call_expr) == 0 {
            call_expr = param_name;
        }

        val type_names_ref: ref list(string) = ast.data.overload_node.type_names;
        val targets_ref: ref list(string) = ast.data.overload_node.target_functions;

        if type_names_ref == nil or targets_ref == nil {
            return result;
        }

        val count: i32 = len(deref(type_names_ref));
        if count == 0 or count != len(deref(targets_ref)) {
            return result;
        }

        // Begin macro definition
        result = concat(result, str("#define "));
        result = concat(result, name);
        result = concat(result, str("("));
        result = concat(result, param_name);
        result = concat(result, str(") _Generic(("));
        result = concat(result, call_expr);
        result = concat(result, str("), \\\n"));

        mut i_ov: i32 = 0;
        loop {
            if i_ov >= count {
                break;
            }

            val axe_type: string = type_names_ref.data[i_ov];
            val target_name: string = targets_ref.data[i_ov];
            val mapped_type: string = map_axe_type_to_c(axe_type);

            result = concat(result, str("    "));
            result = concat(result, mapped_type);
            result = concat(result, str(": "));
            result = concat(result, target_name);

            if i_ov < count - 1 {
                result = concat(result, str(", \\\n"));
            } else {
                result = concat(result, str(" \\\n"));
            }

            i_ov = i_ov + 1;
        }

        result = concat(result, str("    )("));
        result = concat(result, call_expr);
        result = concat(result, str(")\n"));

        return result;
    }
    
    if equals_c(node_type, "Program") {
        result = concat(result, str("#define nil ((void*)0)\n"));
        result = concat(result, str("#include <stdio.h>\n"));
        result = concat(result, str("#include <stdbool.h>\n"));
        result = concat(result, str("#include <stdlib.h>\n"));
        result = concat(result, str("#include <string.h>\n"));
        result = concat(result, str("#include <stdint.h>\n"));
        result = concat(result, str("\n"));
        
        build_function_prefixes(ast);

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;

            // Emit function prototypes for hoisting so functions can be called
            // before their definitions, matching the D renderer behaviour.
            mut i_proto: i32 = 0;
            loop {
                if i_proto >= len(deref(children)) {
                    break;
                }
                val proto_child: ref ASTNode = addr_of(children.data[i_proto]);
                if equals_c(proto_child.node_type, "Function") {
                    val proto_code: string = generate_function_prototype(proto_child);
                    if str_len(proto_code) > 0 {
                        result = concat(result, proto_code);
                    }
                }
                i_proto = i_proto + 1;
            }
            result = concat(result, str("\n"));
            
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child: ref ASTNode = addr_of(children.data[i]);
                if equals_c(child.node_type, "Overload") {
                    val ov_code: string = generate_c(child);
                    result = concat(result, ov_code);
                    result = concat(result, str("\n"));
                }
                i = i + 1;
            }

            i = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val fn_child: ref ASTNode = addr_of(children.data[i]);
                if equals_c(fn_child.node_type, "Function") {
                    val fn_name: string = fn_child.data.function.name;
                    if !equals_c(fn_name, "main") {
                        val fn_code: string = generate_c(fn_child);
                        result = concat(result, fn_code);
                    }
                }
                i = i + 1;
            }

            i = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child2: ref ASTNode = addr_of(children.data[i]);
                if !equals_c(child2.node_type, "Overload") {
                    val child_code: string = generate_c(child2);
                    result = concat(result, child_code);
                }
                i = i + 1;
            }
        }
    }

    if equals_c(node_type, "Test") {
        result = concat(result, str("int main(int argc, char** argv) {\n"));
        result = concat(result, str("    int passed = 0;\n"));
        result = concat(result, str("    int failed = 0;\n\n"));

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_test: i32 = 0;
            loop {
                if i_test >= len(deref(children)) {
                    break;
                }

                val child: ref ASTNode = addr_of(children.data[i_test]);

                if equals_c(child.node_type, "Assert") {
                    val cond_raw: string = strip(child.data.assert_node.condition);
                    val msg: string = child.data.assert_node.message;

                    result = concat(result, str("    if ("));
                    result = concat(result, cond_raw);
                    result = concat(result, str(") {\n"));
                    result = concat(result, str("        printf(\"PASSED: "));
                    result = concat(result, msg);
                    result = concat(result, str("\\n\");\n"));
                    result = concat(result, str("        passed++;\n"));
                    result = concat(result, str("    } else {\n"));
                    result = concat(result, str("        printf(\"FAILED: "));
                    result = concat(result, msg);
                    result = concat(result, str("\\n\");\n"));
                    result = concat(result, str("        failed++;\n"));
                    result = concat(result, str("    }\n\n"));
                } elif equals_c(child.node_type, "Declaration") {
                    val var_name: string = child.data.declaration.name;
                    val type_name: string = child.data.declaration.type_name;
                    val is_mutable: bool = child.data.declaration.is_mutable;
                    val initializer: string = child.data.declaration.initializer;

                    mut mapped_type: string = map_type(type_name);
                    mut line: string = str("");

                    if is_mutable {
                        line = concat(line, mapped_type);
                        line = concat(line, str(" "));
                        line = concat(line, var_name);
                    } else {
                        line = concat(line, str("const "));
                        line = concat(line, mapped_type);
                        line = concat(line, str(" "));
                        line = concat(line, var_name);
                    }

                    mut trimmed_init: string = strip(initializer);
                    if str_len(trimmed_init) > 0 {
                        line = concat(line, str(" = "));
                        line = concat(line, trimmed_init);
                    }

                    line = concat(line, str(";"));
                    result = concat(result, str("    "));
                    result = concat(result, line);
                    result = concat(result, str("\n"));
                } else {
                    val stmt_code: string = generate_c(child);
                    if str_len(stmt_code) > 0 {
                        mut line: string = str("");
                        mut buf: string = stmt_code;
                        mut idx: i32 = 0;

                        loop {
                            if idx >= str_len(buf) {
                                break;
                            }
                            val ch: char = get_char(buf, idx);
                            if ch == '\n' {
                                if str_len(line) > 0 {
                                    result = concat(result, str("    "));
                                    result = concat(result, line);
                                    result = concat(result, str("\n"));
                                    line = str("");
                                }
                            } else {
                                line = concat_chr(line, ch);
                            }
                            idx = idx + 1;
                        }

                        if str_len(line) > 0 {
                            result = concat(result, str("    "));
                            result = concat(result, line);
                            result = concat(result, str("\n"));
                        }
                    }
                }

                i_test = i_test + 1;
            }
        }

        result = concat(result, str("    printf(\"\\n\");\n"));
        result = concat(result, str("    if (failed == 0) {\n"));
        result = concat(result, str("        printf(\"All tests passed. (%d/%d)\\n\", passed, passed + failed);\n"));
        result = concat(result, str("    } else {\n"));
        result = concat(result, str("        printf(\"%d test(s) failed, %d passed\\n\", failed, passed);\n"));
        result = concat(result, str("    }\n"));
        result = concat(result, str("    return failed > 0 ? 1 : 0;\n"));
        result = concat(result, str("}\n"));

        return result;
    }
    
    if equals_c(node_type, "Function") {
        mut func_name: string = ast.data.function.name;
        mut return_type: string = ast.data.function.return_type;
        val is_public: bool = ast.data.function.is_public;
        
        if !equals_c(func_name, "main") {
            if StringStringMap.contains(addr_of(g_function_prefixes), func_name) {
                func_name = StringStringMap.get(addr_of(g_function_prefixes), func_name);
            }
        }
        
        if StringBoolMap.contains(addr_of(g_generated_functions), func_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_functions), addr_of(arena), func_name, true);
        
        if equals_c(func_name, "main") {
            result = concat(result, str("int main(int argc, char** argv) {\n"));
            
            if ast.children != nil {
                val children: ref list(ASTNode) = ast.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_code: string = generate_c(addr_of(children.data[i]));
                    result = concat(result, child_code);
                    i++;
                }
            }
            
            result = concat(result, str("return 0;\n"));
            result = concat(result, str("}\n\n"));
            return result;
        }
        
        if str_len(return_type) == 0 {
            return_type = str("void");
        }
        
        val mapped_return_type: string = map_type(return_type);
        
        result = concat(result, mapped_return_type);
        result = concat(result, str(" "));
        result = concat(result, func_name);
        result = concat(result, str("("));
        
        val params: ref list(string) = ast.data.function.params;
        if params != nil {
            mut param_idx: i32 = 0;
            loop {
                if param_idx >= len(deref(params)) {
                    break;
                }
                
                if param_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                val param: string = params.data[param_idx];
                val colon_pos: i32 = find_char_from(param, ':', 0);

                if colon_pos >= 0 {
                    val param_name: string = strip(substring_se(param, 0, colon_pos));
                    val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                    val processed_type: string = process_parameter_type(param_type);
                    
                    result = concat(result, processed_type);
                    result = concat(result, str(" "));
                    result = concat(result, param_name);
                } else {
                    result = concat(result, param);
                }
                
                param_idx++;
            }
        }
        
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n\n"));
        return result;
    }
    
    if equals_c(node_type, "Return") {
        result = concat(result, str("return "));
        val expr: string = ast.data.return_node.expression;
        println "[DEBUG] RENDERER raw return expr:";
        println expr;
        val processed: string = process_expression(expr);
        println "[DEBUG] RENDERER processed return expr:";
        println processed;
        result = concat(result, processed);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Break") {
        result = concat(result, str("break;\n"));
        return result;
    }
    
    if equals_c(node_type, "Continue") {
        result = concat(result, str("continue;\n"));
        return result;
    }
    
    if equals_c(node_type, "Declaration") {
        val var_name: string = ast.data.declaration.name;
        mut type_name: string = ast.data.declaration.type_name;
        val is_mutable: bool = ast.data.declaration.is_mutable;
        val initializer: string = ast.data.declaration.initializer;
        
        mut mapped_type: string = map_type(type_name);

        if str_len(type_name) == 0 {
            mut trimmed_init: string = strip(initializer);
            if has_prefix(trimmed_init, str("new ")) {
                trimmed_init = substring_se(trimmed_init, 4, str_len(trimmed_init));
                trimmed_init = strip(trimmed_init);

                mut end_pos: i32 = -1;
                mut i: i32 = 0;
                loop {
                    if i >= str_len(trimmed_init) {
                        break;
                    }
                    val ch: char = get_char(trimmed_init, i);
                    if ch == '(' or ch == ' ' or ch == '\t' {
                        end_pos = i;
                        break;
                    }
                    i = i + 1;
                }
                if end_pos < 0 {
                    end_pos = str_len(trimmed_init);
                }
                val inferred_name: string = strip(substring_se(trimmed_init, 0, end_pos));
                if str_len(inferred_name) > 0 {
                    type_name = inferred_name;
                    mapped_type = map_type(type_name);
                }
            }
        }

        if is_mutable {
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        } else {
            result = concat(result, str("const "));
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        }
        
        if str_len(initializer) > 0 {
            mut trimmed: string = strip(initializer);
            if has_prefix(trimmed, str("new ")) {
                trimmed = substring_se(trimmed, 4, str_len(trimmed));
                trimmed = strip(trimmed);

                val first_paren: i32 = find_char_from(trimmed, '(', 0);
                if first_paren < 0 {
                    result = concat(result, str(" = {0}"));
                } else {
                    mut last_paren: i32 = -1;
                    mut idx: i32 = str_len(trimmed) - 1;
                    loop {
                        if idx < 0 {
                            break;
                        }
                        val ch_end: char = get_char(trimmed, idx);
                        if ch_end == ')' {
                            last_paren = idx;
                            break;
                        }
                        idx = idx - 1;
                    }

                    if last_paren <= first_paren + 1 {
                        // No arguments
                        result = concat(result, str(" = {0}"));
                    } else {
                        val args_str: string = substring_se(trimmed, first_paren + 1, last_paren);
                        mut init_code: string = str(" = {");

                        mut current: string = str("");
                        mut depth: i32 = 0;
                        mut first_field: bool = true;
                        mut i2: i32 = 0;

                        loop {
                            if i2 >= str_len(args_str) {
                                break;
                            }
                            val ch: char = get_char(args_str, i2);
                            if ch == '(' {
                                depth = depth + 1;
                                current = concat_chr(current, ch);
                            } elif ch == ')' {
                                if depth > 0 {
                                    depth = depth - 1;
                                }
                                current = concat_chr(current, ch);
                            } elif ch == ',' and depth == 0 {
                                mut part: string = strip(current);
                                if str_len(part) > 0 {
                                    val colon_pos: i32 = find_char_from(part, ':', 0);
                                    if colon_pos >= 0 {
                                        val field_name: string = strip(substring_se(part, 0, colon_pos));
                                        val value_expr: string = strip(substr(part, colon_pos + 1, str_len(part) - colon_pos - 1));
                                        if str_len(field_name) > 0 and str_len(value_expr) > 0 {
                                            if !first_field {
                                                init_code = concat(init_code, str(", "));
                                            }
                                            init_code = concat(init_code, str("."));
                                            init_code = concat(init_code, field_name);
                                            init_code = concat(init_code, str(" = "));
                                            init_code = concat(init_code, value_expr);
                                            first_field = false;
                                        }
                                    }
                                }
                                current = str("");
                            } else {
                                current = concat_chr(current, ch);
                            }
                            i2 = i2 + 1;
                        }

                        mut part_last: string = strip(current);
                        if str_len(part_last) > 0 {
                            val colon_pos_last: i32 = find_char_from(part_last, ':', 0);
                            if colon_pos_last >= 0 {
                                val field_name_last: string = strip(substring_se(part_last, 0, colon_pos_last));
                                val value_expr_last: string = strip(substr(part_last, colon_pos_last + 1, str_len(part_last) - colon_pos_last - 1));
                                if str_len(field_name_last) > 0 and str_len(value_expr_last) > 0 {
                                    if !first_field {
                                        init_code = concat(init_code, str(", "));
                                    }
                                    init_code = concat(init_code, str("."));
                                    init_code = concat(init_code, field_name_last);
                                    init_code = concat(init_code, str(" = "));
                                    init_code = concat(init_code, value_expr_last);
                                    first_field = false;
                                }
                            }
                        }

                        if first_field {
                            result = concat(result, str(" = {0}"));
                        } else {
                            init_code = concat(init_code, str("}"));
                            result = concat(result, init_code);
                        }
                    }
                }
            } else {
                val processed_init: string = process_expression(trimmed);
                result = concat(result, str(" = "));
                result = concat(result, processed_init);
            }
        }
        
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Assignment") {
        val variable: string = ast.data.assignment.variable;
        val expression: string = ast.data.assignment.expression;
        
        println "[DEBUG] renderer: Assignment node";
        println "[DEBUG]   raw variable:";
        println variable;
        println "[DEBUG]   raw expression:";
        println expression;

        val processed_var: string = process_expression(variable);
        val processed_expr: string = process_expression(expression);

        println "[DEBUG]   processed variable:";
        println processed_var;
        println "[DEBUG]   processed expression:";
        println processed_expr;
        
        result = concat(result, processed_var);
        result = concat(result, str(" = "));
        result = concat(result, processed_expr);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "MemberAccess") {
        val object_name: string = ast.data.member_access.object_name;
        val member_name: string = ast.data.member_access.member_name;
        val value: string = ast.data.member_access.value;
        
        println "[DEBUG] renderer: MemberAccess node";
        println "[DEBUG]   object_name:";
        println object_name;
        println "[DEBUG]   member_name:";
        println member_name;
        println "[DEBUG]   raw value:";
        println value;

        result = concat(result, object_name);
        result = concat(result, str("."));
        result = concat(result, member_name);

        if str_len(strip(value)) > 0 {
            // NOTE: 
            // For member assignments, the parser already builds a C-ready
            // expression string for the value, so just use the thing directly after
            // stripping, instead of running it through process_expression.

            val processed_value: string = strip(value);
            println "[DEBUG]   processed value:";
            println processed_value;
            result = concat(result, str(" = "));
            result = concat(result, processed_value);
        }

        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "FunctionCall") {
        val func_name: string = ast.data.func_call.function_name;

        mut emitted_name: string = func_name;
        if StringStringMap.contains(addr_of(g_function_prefixes), func_name) {
            emitted_name = StringStringMap.get(addr_of(g_function_prefixes), func_name);
        }

        result = concat(result, emitted_name);
        result = concat(result, str("("));
        
        val args: ref list(string) = ast.data.func_call.args;
        if args != nil {
            mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= len(deref(args)) {
                    break;
                }
                
                if arg_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                result = concat(result, args.data[arg_idx]);
                arg_idx++;
            }
        }
        
        result = concat(result, str(");\n"));
        return result;
    }
    
    if equals_c(node_type, "Print") {
        val messages_ref: ref list(string) = ast.data.print.messages;
        val flags_ref: ref list(bool) = ast.data.print.is_expressions;

        if messages_ref == nil or flags_ref == nil {
            return result;
        }

        val messages: list(string) = deref(messages_ref);
        val flags: list(bool) = deref(flags_ref);

        if len(messages) == 0 {
            return result;
        }

        if len(messages) == 1 and len(flags) == 1 and !flags.data[0] {
            result = concat(result, str("printf(\""));
            result = concat(result, messages.data[0]);
            result = concat(result, str("\");\n"));
            return result;
        }

        return result;
    }
    
    if equals_c(node_type, "Loop") {
        result = concat(result, str("while (1) {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "If") {
        val condition: string = ast.data.if_node.condition;
        mut trimmed_cond: string = strip(condition);

        result = concat(result, str("if ("));
        result = concat(result, trimmed_cond);
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "Unsafe") {
        val body: ref list(ASTNode) = ast.data.unsafe_node.body;
        if body != nil {
            mut i_unsafe: i32 = 0;
            loop {
                if i_unsafe >= len(deref(body)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(body.data[i_unsafe]));
                result = concat(result, child_code);
                i_unsafe = i_unsafe + 1;
            }
        }
        return result;
    }
    
    if equals_c(node_type, "Model") {
        val model_name: string = ast.data.model_node.name;
        val is_public: bool = ast.data.model_node.is_public;
        val field_names: ref list(string) = ast.data.model_node.field_names;
        val field_types: ref list(string) = ast.data.model_node.field_types;
        val union_parents: ref list(string) = ast.data.model_node.union_member_parents;
        val union_names: ref list(string) = ast.data.model_node.union_member_names;
        val union_types: ref list(string) = ast.data.model_node.union_member_types;
        
        if StringBoolMap.contains(addr_of(g_generated_typedefs), model_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_typedefs), addr_of(arena), model_name, true);
        
        result = concat(result, str("typedef struct "));
        result = concat(result, model_name);
        result = concat(result, str(" {\n"));
        
        if field_names != nil and field_types != nil {
            mut field_idx: i32 = 0;
            loop {
                if field_idx >= len(deref(field_names)) {
                    break;
                }

                val field_name: string = field_names.data[field_idx];
                val field_type: string = field_types.data[field_idx];

                // Store field type for later reference (e.g., member access)
                mut field_key: string = model_name;
                field_key = concat(field_key, str("."));
                field_key = concat(field_key, field_name);
                StringStringMap.set(addr_of(g_field_types), addr_of(arena), field_key, field_type);

                // Union field: emit nested union block
                if str_len(field_type) == 5 and equals_c(field_type, "union") and union_parents != nil and union_names != nil and union_types != nil {
                    result = concat(result, str("    union {\n"));

                    val up: list(string) = deref(union_parents);
                    val un: list(string) = deref(union_names);
                    val ut: list(string) = deref(union_types);

                    mut uidx: i32 = 0;
                    loop {
                        if uidx >= len(up) or uidx >= len(un) or uidx >= len(ut) {
                            break;
                        }

                        val parent_name: string = up.data[uidx];
                        if compare(parent_name, field_name) == 0 {
                            val member_name: string = un.data[uidx];
                            val member_type_raw: string = ut.data[uidx];

                            mut mapped_member_type: string = map_axe_type_to_c(member_type_raw);
                            mut member_array_part: string = str("");

                            val m_bracket_pos: i32 = find_char_from(mapped_member_type, '[', 0);
                            if m_bracket_pos >= 0 {
                                member_array_part = substring_se(mapped_member_type, m_bracket_pos, str_len(mapped_member_type));
                                mapped_member_type = substring_se(mapped_member_type, 0, m_bracket_pos);
                            }

                            if has_prefix(mapped_member_type, str("ref ")) {
                                mapped_member_type = concat(strip(substring_se(mapped_member_type, 4, str_len(mapped_member_type))), str("*"));
                            }

                            val c_member_model_name: string = canonical_model_c_name(mapped_member_type);
                            if str_len(c_member_model_name) > 0 {
                                if StringBoolMap.contains(addr_of(g_enum_names), c_member_model_name) {
                                    mapped_member_type = c_member_model_name;
                                } else {
                                    mapped_member_type = concat(str("struct "), c_member_model_name);
                                }
                            }

                            result = concat(result, str("        "));
                            result = concat(result, mapped_member_type);
                            result = concat(result, str(" "));
                            result = concat(result, member_name);
                            result = concat(result, member_array_part);
                            result = concat(result, str(";\n"));
                        }

                        uidx = uidx + 1;
                    }

                    result = concat(result, str("    } "));
                    result = concat(result, field_name);
                    result = concat(result, str(";\n"));
                } else {
                    // Normal field
                    mut mapped_type: string = map_axe_type_to_c(field_type);
                    mut array_part: string = str("");

                    val bracket_pos: i32 = find_char_from(mapped_type, '[', 0);
                    if bracket_pos >= 0 {
                        array_part = substring_se(mapped_type, bracket_pos, str_len(mapped_type));
                        mapped_type = substring_se(mapped_type, 0, bracket_pos);
                    }

                    // Handle ref types for fields
                    if has_prefix(mapped_type, str("ref ")) {
                        mapped_type = concat(strip(substring_se(mapped_type, 4, str_len(mapped_type))), str("*"));
                    }

                    // Handle model types
                    val c_model_name: string = canonical_model_c_name(mapped_type);
                    if str_len(c_model_name) > 0 {
                        if StringBoolMap.contains(addr_of(g_enum_names), c_model_name) {
                            mapped_type = c_model_name;
                        } else {
                            mapped_type = concat(str("struct "), c_model_name);
                        }
                    }

                    result = concat(result, str("    "));
                    result = concat(result, mapped_type);
                    result = concat(result, str(" "));
                    result = concat(result, field_name);
                    result = concat(result, array_part);
                    result = concat(result, str(";\n"));
                }

                field_idx = field_idx + 1;
            }
        }

        result = concat(result, str("} "));
        result = concat(result, model_name);
        result = concat(result, str(";\n\n"));
        return result;
    }

    if equals_c(node_type, "Enum") {
        val enum_name: string = ast.data.enum_node.name;
        val enum_values: ref list(string) = ast.data.enum_node.values;
        
        if StringBoolMap.contains(addr_of(g_generated_typedefs), enum_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_typedefs), addr_of(arena), enum_name, true);
        StringBoolMap.set(addr_of(g_enum_names), addr_of(arena), enum_name, true);
        
        result = concat(result, str("typedef enum {\n"));
        
        if enum_values != nil {
            mut value_idx: i32 = 0;
            val num_values: i32 = len(deref(enum_values));
            
            loop {
                if value_idx >= num_values {
                    break;
                }
                
                val enum_value: string = enum_values.data[value_idx];
                
                result = concat(result, str("    "));
                result = concat(result, enum_name);
                result = concat(result, str("_"));
                result = concat(result, enum_value);
                
                if value_idx < num_values - 1 {
                    result = concat(result, str(","));
                }
                result = concat(result, str("\n"));
                
                value_idx++;
            }
        }
        
        result = concat(result, str("} "));
        result = concat(result, enum_name);
        result = concat(result, str(";\n\n"));
        
        return result;
    }
    
    return result;
}

test {
    initialize_renderer();
    
    println "\nTest 1: Initialize renderer";
    assert StringStringMap.contains(addr_of(g_type_mappings), str("i32")), "Expected i32 type mapping";
    assert equals_c(map_type(str("i32")), "int32_t"), "Expected i32 to map to int32_t";
    
    println "\nTest 2: Map types";
    assert equals_c(map_type(str("i64")), "int64_t"), "Expected i64 to map to int64_t";
    assert equals_c(map_type(str("f32")), "float"), "Expected f32 to map to float";
    assert equals_c(map_type(str("bool")), "bool"), "Expected bool to map to bool";
    
    println "\nTest 3: Generate empty program";
    mut empty_ast: ASTNode;
    empty_ast.node_type = str("Program");
    empty_ast.children = nil;
    val code: string = generate_c(addr_of(empty_ast));
    assert str_contains_c(code, "#include <stdio.h>"), "Expected stdio.h include";
    assert str_contains_c(code, "#include <stdint.h>"), "Expected stdint.h include";
    
    println "\nTest 4: Generate main function";
    mut func_ast: ASTNode;
    func_ast.node_type = str("Function");
    func_ast.data.function.name = str("main");
    func_ast.data.function.return_type = str("i32");
    func_ast.data.function.is_public = false;
    func_ast.data.function.params = nil;
    func_ast.children = nil;
    val func_code: string = generate_c(addr_of(func_ast));
    assert str_contains_c(func_code, "int main"), "Expected int main function";
    assert str_contains_c(func_code, "return 0;"), "Expected return 0 in main";
    
    println "\nTest 5: Generate simple function";
    mut simple_func: ASTNode;
    simple_func.node_type = str("Function");
    simple_func.data.function.name = str("add");
    simple_func.data.function.return_type = str("i32");
    simple_func.data.function.is_public = false;
    simple_func.data.function.params = nil;
    simple_func.children = nil;
    val simple_code: string = generate_c(addr_of(simple_func));
    assert str_contains_c(simple_code, "int32_t add"), "Expected int32_t add function";
    
    println "\nTest 6: Process parameter types";
    assert equals_c(process_parameter_type(str("i32")), "int32_t"), "Expected i32 -> int32_t";
    assert equals_c(process_parameter_type(str("ref i32")), "int32_t*"), "Expected ref i32 -> int32_t*";
    assert equals_c(process_parameter_type(str("mut i32")), "int32_t"), "Expected mut i32 -> int32_t";
    assert equals_c(process_parameter_type(str("i32*")), "int32_t*"), "Expected i32* -> int32_t*";
    
    println "\nTest 7: Generate simple model";
    mut model_arena: Arena = Arena.create(4096);
    mut model_ast: ASTNode;
    model_ast.node_type = str("Model");
    model_ast.data.model_node.name = str("Point");
    model_ast.data.model_node.is_public = false;
    
    val field_names_list: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names_list, addr_of(model_arena), str("x"));
    StringList.push(field_names_list, addr_of(model_arena), str("y"));
    model_ast.data.model_node.field_names = field_names_list;
    
    val field_types_list: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types_list, addr_of(model_arena), str("i32"));
    StringList.push(field_types_list, addr_of(model_arena), str("i32"));
    model_ast.data.model_node.field_types = field_types_list;
    
    model_ast.children = nil;
    val model_code: string = generate_c(addr_of(model_ast));
    assert str_contains_c(model_code, "struct Point"), "Expected struct Point";
    assert str_contains_c(model_code, "int32_t x"), "Expected int32_t x field";
    assert str_contains_c(model_code, "int32_t y"), "Expected int32_t y field";
    
    println "\nTest 8: Generate model with different types";
    mut model2_ast: ASTNode;
    model2_ast.node_type = str("Model");
    model2_ast.data.model_node.name = str("Person");
    model2_ast.data.model_node.is_public = true;
    
    val field_names2: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names2, addr_of(model_arena), str("age"));
    StringList.push(field_names2, addr_of(model_arena), str("height"));
    StringList.push(field_names2, addr_of(model_arena), str("active"));
    model2_ast.data.model_node.field_names = field_names2;
    
    val field_types2: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types2, addr_of(model_arena), str("i32"));
    StringList.push(field_types2, addr_of(model_arena), str("f32"));
    StringList.push(field_types2, addr_of(model_arena), str("bool"));
    model2_ast.data.model_node.field_types = field_types2;
    
    model2_ast.children = nil;
    val model2_code: string = generate_c(addr_of(model2_ast));
    assert str_contains_c(model2_code, "struct Person"), "Expected struct Person";
    assert str_contains_c(model2_code, "int32_t age"), "Expected int32_t age field";
    assert str_contains_c(model2_code, "float height"), "Expected float height field";
    assert str_contains_c(model2_code, "bool active"), "Expected bool active field";
    
    println "\nTest 9: Model with array field";
    mut model3_ast: ASTNode;
    model3_ast.node_type = str("Model");
    model3_ast.data.model_node.name = str("Buffer");
    model3_ast.data.model_node.is_public = false;
    
    val field_names3: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names3, addr_of(model_arena), str("data"));
    model3_ast.data.model_node.field_names = field_names3;
    
    val field_types3: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types3, addr_of(model_arena), str("i32[100]"));
    model3_ast.data.model_node.field_types = field_types3;
    
    model3_ast.children = nil;
    val model3_code: string = generate_c(addr_of(model3_ast));
    assert str_contains_c(model3_code, "struct Buffer"), "Expected struct Buffer";
    assert str_contains_c(model3_code, "int32_t data[100]"), "Expected array field";
    
    println "\nTest 10: Model with pointer field";
    mut model4_ast: ASTNode;
    model4_ast.node_type = str("Model");
    model4_ast.data.model_node.name = str("Node");
    model4_ast.data.model_node.is_public = false;
    
    val field_names4: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names4, addr_of(model_arena), str("value"));
    StringList.push(field_names4, addr_of(model_arena), str("next"));
    model4_ast.data.model_node.field_names = field_names4;
    
    val field_types4: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types4, addr_of(model_arena), str("i32"));
    StringList.push(field_types4, addr_of(model_arena), str("ref Node"));
    model4_ast.data.model_node.field_types = field_types4;
    
    model4_ast.children = nil;
    val model4_code: string = generate_c(addr_of(model4_ast));
    assert str_contains_c(model4_code, "struct Node"), "Expected struct Node";
    assert str_contains_c(model4_code, "int32_t value"), "Expected value field";
    assert str_contains_c(model4_code, "Node* next"), "Expected pointer field";
    
    println "\nTest 11: Test helper functions";
    assert equals_c(map_axe_type_to_c(str("i32")), "int32_t"), "Expected i32 mapping";
    assert equals_c(map_axe_type_to_c(str("ref i64")), "int64_t*"), "Expected ref i64 mapping";
    assert equals_c(map_axe_type_to_c(str("mut f32")), "float"), "Expected mut f32 mapping";
    
    println "\nTest 12: Generate enum";
    mut enum_ast: ASTNode;
    enum_ast.node_type = str("Enum");
    enum_ast.data.enum_node.name = str("Color");
    
    val enum_values: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(enum_values, addr_of(model_arena), str("Red"));
    StringList.push(enum_values, addr_of(model_arena), str("Green"));
    StringList.push(enum_values, addr_of(model_arena), str("Blue"));
    enum_ast.data.enum_node.values = enum_values;
    
    enum_ast.children = nil;
    val enum_code: string = generate_c(addr_of(enum_ast));
    assert str_contains_c(enum_code, "typedef enum"), "Expected typedef enum";
    assert str_contains_c(enum_code, "Color_Red"), "Expected Color_Red value";
    assert str_contains_c(enum_code, "Color_Green"), "Expected Color_Green value";
    assert str_contains_c(enum_code, "Color_Blue"), "Expected Color_Blue value";
    assert str_contains_c(enum_code, "} Color;"), "Expected } Color;";

    println "\nTest 13: MemberAccess assignment";
    mut member_assign_ast: ASTNode;
    member_assign_ast.node_type = str("MemberAccess");
    member_assign_ast.data.member_access.object_name = str("obj");
    member_assign_ast.data.member_access.member_name = str("field");
    member_assign_ast.data.member_access.value = str("42");
    val member_assign_code: string = generate_c(addr_of(member_assign_ast));
    assert str_contains_c(member_assign_code, "obj.field = 42;"), "Expected obj.field = 42;";

    println "\nTest 14: MemberAccess read";
    mut member_read_ast: ASTNode;
    member_read_ast.node_type = str("MemberAccess");
    member_read_ast.data.member_access.object_name = str("obj");
    member_read_ast.data.member_access.member_name = str("field");
    member_read_ast.data.member_access.value = str("");
    val member_read_code: string = generate_c(addr_of(member_read_ast));
    assert str_contains_c(member_read_code, "obj.field;"), "Expected obj.field; for read";
}
