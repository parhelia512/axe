// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
// 
// Handles the rendering process.

use structs (ASTNode);
use std.string;
use std.io;
use std.maps;

/// Type mappings from Axe to C
mut g_type_mappings: StringStringMap;

/// Track reference depths for variables
mut g_ref_depths: StringIntMap;

/// Track mutability
mut g_is_mutable: StringBoolMap;

/// Function prefixes for imported modules
mut g_function_prefixes: StringStringMap;

/// Model name mappings
mut g_model_names: StringStringMap;

/// Enum names
mut g_enum_names: StringBoolMap;

/// Generated typedefs to avoid duplicates
mut g_generated_typedefs: StringBoolMap;

/// Generated functions to avoid duplicates
mut g_generated_functions: StringBoolMap;

/// Field types for models
mut g_field_types: StringStringMap;

/// Variable types
mut g_var_types: StringStringMap;

/// Initialize renderer globals
def initialize_renderer() {
    mut arena: Arena = Arena.create(1024 * 1024);
    
    g_type_mappings = deref(StringStringMap.create(addr_of(arena), 128));
    g_ref_depths = deref(StringIntMap.create(addr_of(arena), 128));
    g_is_mutable = deref(StringBoolMap.create(addr_of(arena), 128));
    g_function_prefixes = deref(StringStringMap.create(addr_of(arena), 128));
    g_model_names = deref(StringStringMap.create(addr_of(arena), 128));
    g_enum_names = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_typedefs = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_functions = deref(StringBoolMap.create(addr_of(arena), 128));
    g_field_types = deref(StringStringMap.create(addr_of(arena), 128));
    g_var_types = deref(StringStringMap.create(addr_of(arena), 128));
    
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i8"), str("int8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u8"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i16"), str("int16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u16"), str("uint16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i32"), str("int32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u32"), str("uint32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i64"), str("int64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u64"), str("uint64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("isize"), str("intptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("usize"), str("uintptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f32"), str("float"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f64"), str("double"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("bool"), str("bool"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("char"), str("char"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("rchar"), str("char*"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("byte"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("ptrdiff"), str("isize"));
}

/// Map Axe type to C type
def map_type(axe_type: string): string {
    if StringStringMap.contains(addr_of(g_type_mappings), axe_type) {
        return StringStringMap.get(addr_of(g_type_mappings), axe_type);
    }
    return axe_type;
}

/// Process parameter type (handle ref, mut, pointers, etc.)
def process_parameter_type(param_type: string): string {
    mut result: string = param_type;
    
    if has_prefix(result, str("mut ")) {
        result = strip(substr(result, 4, str_len(result) - 4));
    }
    
    if has_prefix(result, str("ref ")) {
        val base_type: string = strip(substr(result, 4, str_len(result) - 4));
        val mapped_base: string = map_type(base_type);
        return concat(mapped_base, str("*"));
    }
    
    if has_suffix(result, str("*")) {
        val base_type: string = strip(substring_se(result, 0, str_len(result) - 1));
        val mapped_base: string = map_type(base_type);
        return concat(mapped_base, str("*"));
    }
    
    if has_prefix(result, str("list(")) and has_suffix(result, str(")")) {
        val element_type_start: i32 = 5;
        val element_type_end: i32 = str_len(result) - 1;
        val element_type: string = substring_se(result, element_type_start, element_type_end);
        val mapped_element: string = map_type(element_type);
        
        mut list_struct: string = str("__list_");
        list_struct = concat(list_struct, mapped_element);
        list_struct = concat(list_struct, str("_t"));
        return list_struct;
    }
    
    if StringStringMap.contains(addr_of(g_model_names), result) {
        return StringStringMap.get(addr_of(g_model_names), result);
    }
    
    return map_type(result);
}

/// Generate C code from AST
def generate_c(ast: ref ASTNode): string {
    mut result: string = str("");
    
    if ast == nil {
        return result;
    }
    
    val node_type: string = ast.node_type;
    
    if equals_c(node_type, "Program") {
        result = concat(result, str("#define nil ((void*)0)\n"));
        result = concat(result, str("#include <stdio.h>\n"));
        result = concat(result, str("#include <stdbool.h>\n"));
        result = concat(result, str("#include <stdlib.h>\n"));
        result = concat(result, str("#include <string.h>\n"));
        result = concat(result, str("#include <stdint.h>\n"));
        result = concat(result, str("\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
    }
    
    if equals_c(node_type, "Function") {
        mut func_name: string = ast.data.function.name;
        val return_type: string = ast.data.function.return_type;
        val is_public: bool = ast.data.function.is_public;
        
        if !equals_c(func_name, "main") {
            if StringStringMap.contains(addr_of(g_function_prefixes), func_name) {
                func_name = StringStringMap.get(addr_of(g_function_prefixes), func_name);
            }
        }
        
        if StringBoolMap.contains(addr_of(g_generated_functions), func_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_functions), addr_of(arena), func_name, true);
        
        if equals_c(func_name, "main") {
            result = concat(result, str("int main(int argc, char** argv) {\n"));
            
            if ast.children != nil {
                val children: ref list(ASTNode) = ast.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_code: string = generate_c(addr_of(children.data[i]));
                    result = concat(result, child_code);
                    i++;
                }
            }
            
            result = concat(result, str("return 0;\n"));
            result = concat(result, str("}\n\n"));
            return result;
        }
        
        val mapped_return_type: string = map_type(return_type);
        
        result = concat(result, mapped_return_type);
        result = concat(result, str(" "));
        result = concat(result, func_name);
        result = concat(result, str("("));
        
        // Add parameters
        val params: ref list(string) = ast.data.function.params;
        if params != nil {
            mut param_idx: i32 = 0;
            loop {
                if param_idx >= len(deref(params)) {
                    break;
                }
                
                if param_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                val param: string = params.data[param_idx];
                val colon_pos: i32 = find_char_from(param, ':', 0);

                if colon_pos >= 0 {
                    val param_name: string = strip(substring_se(param, 0, colon_pos));
                    val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                    val processed_type: string = process_parameter_type(param_type);
                    
                    result = concat(result, processed_type);
                    result = concat(result, str(" "));
                    result = concat(result, param_name);
                } else {
                    result = concat(result, param);
                }
                
                param_idx++;
            }
        }
        
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n\n"));
        return result;
    }
    
    if equals_c(node_type, "Return") {
        result = concat(result, str("return "));
        val expr: string = ast.data.return_node.expression;
        result = concat(result, expr);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Break") {
        result = concat(result, str("break;\n"));
        return result;
    }
    
    if equals_c(node_type, "Continue") {
        result = concat(result, str("continue;\n"));
        return result;
    }
    
    if equals_c(node_type, "Declaration") {
        val var_name: string = ast.data.declaration.name;
        val type_name: string = ast.data.declaration.type_name;
        val is_mutable: bool = ast.data.declaration.is_mutable;
        val initializer: string = ast.data.declaration.initializer;
        
        val mapped_type: string = map_type(type_name);
        
        if is_mutable {
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        } else {
            result = concat(result, str("const "));
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        }
        
        if str_len(initializer) > 0 {
            result = concat(result, str(" = "));
            result = concat(result, initializer);
        }
        
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Assignment") {
        val variable: string = ast.data.assignment.variable;
        val expression: string = ast.data.assignment.expression;
        
        result = concat(result, variable);
        result = concat(result, str(" = "));
        result = concat(result, expression);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "FunctionCall") {
        val func_name: string = ast.data.func_call.function_name;
        
        result = concat(result, func_name);
        result = concat(result, str("("));
        
        val args: ref list(string) = ast.data.func_call.args;
        if args != nil {
            mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= len(deref(args)) {
                    break;
                }
                
                if arg_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                result = concat(result, args.data[arg_idx]);
                arg_idx++;
            }
        }
        
        result = concat(result, str(");\n"));
        return result;
    }
    
    if equals_c(node_type, "Loop") {
        result = concat(result, str("while (1) {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "If") {
        val condition: string = ast.data.if_node.condition;
        
        result = concat(result, str("if ("));
        result = concat(result, condition);
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "Model") {
        result = concat(result, str("// Model node\n"));
        result = concat(result, str("typedef struct {} model_placeholder;\n\n"));
        return result;
    }
    
    if equals_c(node_type, "Enum") {
        result = concat(result, str("// Enum node\n"));
        result = concat(result, str("typedef enum {} enum_placeholder;\n\n"));
        return result;
    }
    
    return result;
}

/// Render a function node
def render_function(func: ref ASTNode): string {
    mut result: string = str("");
    
    // TODO: Implement function rendering
    result = concat(result, str("void placeholder() {}\n"));
    
    return result;
}

/// Render a model node
def render_model(modl: ref ASTNode): string {
    mut result: string = str("");
    
    // TODO: Implement model rendering
    result = concat(result, str("typedef struct {} placeholder;\n"));
    
    return result;
}

/// Render an enum node
def render_enum(enum_node: ref ASTNode): string {
    mut result: string = str("");
    
    // TODO: Implement enum rendering
    result = concat(result, str("typedef enum {} placeholder;\n"));
    
    return result;
}

test {
    initialize_renderer();
    
    println "\nTest 1: Initialize renderer";
    assert StringStringMap.contains(addr_of(g_type_mappings), str("i32")), "Expected i32 type mapping";
    assert equals_c(map_type(str("i32")), "int32_t"), "Expected i32 to map to int32_t";
    
    println "\nTest 2: Map types";
    assert equals_c(map_type(str("i64")), "int64_t"), "Expected i64 to map to int64_t";
    assert equals_c(map_type(str("f32")), "float"), "Expected f32 to map to float";
    assert equals_c(map_type(str("bool")), "bool"), "Expected bool to map to bool";
    
    println "\nTest 3: Generate empty program";
    mut empty_ast: ASTNode;
    empty_ast.node_type = str("Program");
    empty_ast.children = nil;
    val code: string = generate_c(addr_of(empty_ast));
    assert str_contains_c(code, "#include <stdio.h>"), "Expected stdio.h include";
    assert str_contains_c(code, "#include <stdint.h>"), "Expected stdint.h include";
    
    println "\nTest 4: Generate main function";
    mut func_ast: ASTNode;
    func_ast.node_type = str("Function");
    func_ast.data.function.name = str("main");
    func_ast.data.function.return_type = str("i32");
    func_ast.data.function.is_public = false;
    func_ast.data.function.params = nil;
    func_ast.children = nil;
    val func_code: string = generate_c(addr_of(func_ast));
    assert str_contains_c(func_code, "int main"), "Expected int main function";
    assert str_contains_c(func_code, "return 0;"), "Expected return 0 in main";
    
    println "\nTest 5: Generate simple function";
    mut simple_func: ASTNode;
    simple_func.node_type = str("Function");
    simple_func.data.function.name = str("add");
    simple_func.data.function.return_type = str("i32");
    simple_func.data.function.is_public = false;
    simple_func.data.function.params = nil;
    simple_func.children = nil;
    val simple_code: string = generate_c(addr_of(simple_func));
    assert str_contains_c(simple_code, "int32_t add"), "Expected int32_t add function";
    
    println "\nTest 6: Process parameter types";
    assert equals_c(process_parameter_type(str("i32")), "int32_t"), "Expected i32 -> int32_t";
    assert equals_c(process_parameter_type(str("ref i32")), "int32_t*"), "Expected ref i32 -> int32_t*";
    assert equals_c(process_parameter_type(str("mut i32")), "int32_t"), "Expected mut i32 -> int32_t";
    assert equals_c(process_parameter_type(str("i32*")), "int32_t*"), "Expected i32* -> int32_t*";
}
