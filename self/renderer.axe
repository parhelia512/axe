// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
// 
// Handles the rendering process.

use structs     (ASTNode);
use std.lists   (StringList);
use std.string;
use std.io;
use std.maps;

/// Type mappings from Axe to C
mut g_type_mappings: StringStringMap;

/// Track reference depths for variables
mut g_ref_depths: StringIntMap;

/// Track mutability
mut g_is_mutable: StringBoolMap;

/// Function prefixes for imported modules
mut g_function_prefixes: StringStringMap;

/// Model name mappings
mut g_model_names: StringStringMap;

/// Enum names
mut g_enum_names: StringBoolMap;

/// Generated typedefs to avoid duplicates
mut g_generated_typedefs: StringBoolMap;

/// Generated functions to avoid duplicates
mut g_generated_functions: StringBoolMap;

/// Field types for models
mut g_field_types: StringStringMap;

/// Variable types
mut g_var_types: StringStringMap;

/// Initialize renderer globals
def initialize_renderer() {
    mut arena: Arena = Arena.create(1024 * 1024);
    
    g_type_mappings = deref(StringStringMap.create(addr_of(arena), 128));
    g_ref_depths = deref(StringIntMap.create(addr_of(arena), 128));
    g_is_mutable = deref(StringBoolMap.create(addr_of(arena), 128));
    g_function_prefixes = deref(StringStringMap.create(addr_of(arena), 128));
    g_model_names = deref(StringStringMap.create(addr_of(arena), 128));
    g_enum_names = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_typedefs = deref(StringBoolMap.create(addr_of(arena), 128));
    g_generated_functions = deref(StringBoolMap.create(addr_of(arena), 128));
    g_field_types = deref(StringStringMap.create(addr_of(arena), 128));
    g_var_types = deref(StringStringMap.create(addr_of(arena), 128));
    
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i8"), str("int8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u8"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i16"), str("int16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u16"), str("uint16_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i32"), str("int32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u32"), str("uint32_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("i64"), str("int64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("u64"), str("uint64_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("isize"), str("intptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("usize"), str("uintptr_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f32"), str("float"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("f64"), str("double"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("bool"), str("bool"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("char"), str("char"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("rchar"), str("char*"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("byte"), str("uint8_t"));
    StringStringMap.set(addr_of(g_type_mappings), addr_of(arena), str("ptrdiff"), str("isize"));
}

/// Map Axe type to C type
def map_type(axe_type: string): string {
    if StringStringMap.contains(addr_of(g_type_mappings), axe_type) {
        return StringStringMap.get(addr_of(g_type_mappings), axe_type);
    }
    return axe_type;
}

/// Get canonical model C name from g_model_names
def canonical_model_c_name(name: string): string {
    if StringStringMap.contains(addr_of(g_model_names), name) {
        return StringStringMap.get(addr_of(g_model_names), name);
    }
    return str("");
}

/// Map Axe type to C type (comprehensive version for model fields)
def map_axe_type_to_c(axe_type: string): string {
    mut result: string = axe_type;
    
    // Handle mut prefix
    if has_prefix(result, str("mut ")) {
        result = strip(substr(result, 4, str_len(result) - 4));
        return map_axe_type_to_c(result);
    }
    
    // Handle list types [999]
    if has_suffix(result, str("[999]")) {
        val element_type: string = strip(substring_se(result, 0, str_len(result) - 5));
        if has_prefix(element_type, str("ref ")) {
            val base_elem: string = strip(substr(element_type, 4, str_len(element_type) - 4));
            val mapped_elem: string = map_axe_type_to_c(base_elem);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t*"));
            return struct_name;
        } else {
            val mapped_elem: string = map_axe_type_to_c(element_type);
            mut struct_name: string = str("__list_");
            struct_name = concat(struct_name, mapped_elem);
            struct_name = concat(struct_name, str("_t"));
            return struct_name;
        }
    }
    
    // Handle ref prefix
    if has_prefix(result, str("ref ")) {
        val base_type: string = strip(substr(result, 4, str_len(result) - 4));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    // Handle pointer suffix
    if has_suffix(result, str("*")) {
        val base_type: string = strip(substring_se(result, 0, str_len(result) - 1));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    // Check type mappings
    if StringStringMap.contains(addr_of(g_type_mappings), result) {
        return StringStringMap.get(addr_of(g_type_mappings), result);
    }
    
    // Check model names
    if StringStringMap.contains(addr_of(g_model_names), result) {
        return StringStringMap.get(addr_of(g_model_names), result);
    }
    
    return result;
}

/// Format model field type with proper struct prefix
def format_model_field_type(field_type: string): string {
    mut trimmed: string = strip(field_type);
    mut qualifiers: string = str("");
    
    loop {
        if !has_prefix(trimmed, str("const ")) {
            break;
        }
        qualifiers = concat(qualifiers, str("const "));
        trimmed = strip(substr(trimmed, 6, str_len(trimmed) - 6));
    }
    
    mut had_struct_prefix: bool = false;
    if has_prefix(trimmed, str("struct ")) {
        had_struct_prefix = true;
        trimmed = strip(substr(trimmed, 7, str_len(trimmed) - 7));
    }
    
    mut pointer_suffix: string = str("");
    loop {
        val len: i32 = str_len(trimmed);
        if len == 0 {
            break;
        }
        val last_char: char = get_char(trimmed, len - 1);
        if last_char != '*' {
            break;
        }
        pointer_suffix = concat(pointer_suffix, str("*"));
        trimmed = strip(substring_se(trimmed, 0, len - 1));
    }
    
    val model_name: string = canonical_model_c_name(trimmed);
    if str_len(model_name) > 0 {
        if StringBoolMap.contains(addr_of(g_enum_names), model_name) {
            trimmed = model_name;
        } else {
            trimmed = concat(str("struct "), model_name);
        }
    } else {
        if had_struct_prefix {
            trimmed = concat(str("struct "), trimmed);
        }
    }
    
    mut final_result: string = qualifiers;
    final_result = concat(final_result, trimmed);
    final_result = concat(final_result, pointer_suffix);
    return final_result;
}

/// Process parameter type (handle ref, mut, pointers, etc.)
def process_parameter_type(param_type: string): string {
    mut result: string = param_type;
    
    if has_prefix(result, str("mut ")) {
        result = strip(substr(result, 4, str_len(result) - 4));
    }
    
    if has_prefix(result, str("ref ")) {
        val base_type: string = strip(substr(result, 4, str_len(result) - 4));
        val mapped_base: string = map_type(base_type);
        return concat(mapped_base, str("*"));
    }
    
    if has_suffix(result, str("*")) {
        val base_type: string = strip(substring_se(result, 0, str_len(result) - 1));
        val mapped_base: string = map_type(base_type);
        return concat(mapped_base, str("*"));
    }
    
    if has_prefix(result, str("list(")) and has_suffix(result, str(")")) {
        val element_type_start: i32 = 5;
        val element_type_end: i32 = str_len(result) - 1;
        val element_type: string = substring_se(result, element_type_start, element_type_end);
        val mapped_element: string = map_type(element_type);
        
        mut list_struct: string = str("__list_");
        list_struct = concat(list_struct, mapped_element);
        list_struct = concat(list_struct, str("_t"));
        return list_struct;
    }
    
    if StringStringMap.contains(addr_of(g_model_names), result) {
        return StringStringMap.get(addr_of(g_model_names), result);
    }
    
    return map_type(result);
}

/// Generate C code from AST
def generate_c(ast: ref ASTNode): string {
    mut result: string = str("");
    
    if ast == nil {
        return result;
    }
    
    val node_type: string = ast.node_type;
    
    if equals_c(node_type, "Program") {
        result = concat(result, str("#define nil ((void*)0)\n"));
        result = concat(result, str("#include <stdio.h>\n"));
        result = concat(result, str("#include <stdbool.h>\n"));
        result = concat(result, str("#include <stdlib.h>\n"));
        result = concat(result, str("#include <string.h>\n"));
        result = concat(result, str("#include <stdint.h>\n"));
        result = concat(result, str("\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
    }
    
    if equals_c(node_type, "Function") {
        mut func_name: string = ast.data.function.name;
        val return_type: string = ast.data.function.return_type;
        val is_public: bool = ast.data.function.is_public;
        
        if !equals_c(func_name, "main") {
            if StringStringMap.contains(addr_of(g_function_prefixes), func_name) {
                func_name = StringStringMap.get(addr_of(g_function_prefixes), func_name);
            }
        }
        
        if StringBoolMap.contains(addr_of(g_generated_functions), func_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_functions), addr_of(arena), func_name, true);
        
        if equals_c(func_name, "main") {
            result = concat(result, str("int main(int argc, char** argv) {\n"));
            
            if ast.children != nil {
                val children: ref list(ASTNode) = ast.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_code: string = generate_c(addr_of(children.data[i]));
                    result = concat(result, child_code);
                    i++;
                }
            }
            
            result = concat(result, str("return 0;\n"));
            result = concat(result, str("}\n\n"));
            return result;
        }
        
        val mapped_return_type: string = map_type(return_type);
        
        result = concat(result, mapped_return_type);
        result = concat(result, str(" "));
        result = concat(result, func_name);
        result = concat(result, str("("));
        
        val params: ref list(string) = ast.data.function.params;
        if params != nil {
            mut param_idx: i32 = 0;
            loop {
                if param_idx >= len(deref(params)) {
                    break;
                }
                
                if param_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                val param: string = params.data[param_idx];
                val colon_pos: i32 = find_char_from(param, ':', 0);

                if colon_pos >= 0 {
                    val param_name: string = strip(substring_se(param, 0, colon_pos));
                    val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                    val processed_type: string = process_parameter_type(param_type);
                    
                    result = concat(result, processed_type);
                    result = concat(result, str(" "));
                    result = concat(result, param_name);
                } else {
                    result = concat(result, param);
                }
                
                param_idx++;
            }
        }
        
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n\n"));
        return result;
    }
    
    if equals_c(node_type, "Return") {
        result = concat(result, str("return "));
        val expr: string = ast.data.return_node.expression;
        result = concat(result, expr);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Break") {
        result = concat(result, str("break;\n"));
        return result;
    }
    
    if equals_c(node_type, "Continue") {
        result = concat(result, str("continue;\n"));
        return result;
    }
    
    if equals_c(node_type, "Declaration") {
        val var_name: string = ast.data.declaration.name;
        val type_name: string = ast.data.declaration.type_name;
        val is_mutable: bool = ast.data.declaration.is_mutable;
        val initializer: string = ast.data.declaration.initializer;
        
        val mapped_type: string = map_type(type_name);
        
        if is_mutable {
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        } else {
            result = concat(result, str("const "));
            result = concat(result, mapped_type);
            result = concat(result, str(" "));
            result = concat(result, var_name);
        }
        
        if str_len(initializer) > 0 {
            result = concat(result, str(" = "));
            result = concat(result, initializer);
        }
        
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "Assignment") {
        val variable: string = ast.data.assignment.variable;
        val expression: string = ast.data.assignment.expression;
        
        result = concat(result, variable);
        result = concat(result, str(" = "));
        result = concat(result, expression);
        result = concat(result, str(";\n"));
        return result;
    }
    
    if equals_c(node_type, "FunctionCall") {
        val func_name: string = ast.data.func_call.function_name;
        
        result = concat(result, func_name);
        result = concat(result, str("("));
        
        val args: ref list(string) = ast.data.func_call.args;
        if args != nil {
            mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= len(deref(args)) {
                    break;
                }
                
                if arg_idx > 0 {
                    result = concat(result, str(", "));
                }
                
                result = concat(result, args.data[arg_idx]);
                arg_idx++;
            }
        }
        
        result = concat(result, str(");\n"));
        return result;
    }
    
    if equals_c(node_type, "Loop") {
        result = concat(result, str("while (1) {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "If") {
        val condition: string = ast.data.if_node.condition;
        
        result = concat(result, str("if ("));
        result = concat(result, condition);
        result = concat(result, str(") {\n"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr_of(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat(result, str("}\n"));
        return result;
    }
    
    if equals_c(node_type, "Model") {
        val model_name: string = ast.data.model_node.name;
        val is_public: bool = ast.data.model_node.is_public;
        val field_names: ref list(string) = ast.data.model_node.field_names;
        val field_types: ref list(string) = ast.data.model_node.field_types;
        
        if StringBoolMap.contains(addr_of(g_generated_typedefs), model_name) {
            return str("");
        }
        
        mut arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr_of(g_generated_typedefs), addr_of(arena), model_name, true);
        
        result = concat(result, str("struct "));
        result = concat(result, model_name);
        result = concat(result, str(" {\n"));
        
        if field_names != nil and field_types != nil {
            mut field_idx: i32 = 0;
            loop {
                if field_idx >= len(deref(field_names)) {
                    break;
                }
                
                val field_name: string = field_names.data[field_idx];
                mut field_type: string = field_types.data[field_idx];
                mut array_part: string = str("");
                
                // Check for list types [999]
                if has_suffix(field_type, str("[999]")) {
                    val base_type: string = substring_se(field_type, 0, str_len(field_type) - 5);
                    mut mapped_type: string = map_axe_type_to_c(base_type);
                    
                    if !has_suffix(mapped_type, str("*")) {
                        mapped_type = concat(mapped_type, str("*"));
                    }
                    
                    result = concat(result, str("    "));
                    result = concat(result, mapped_type);
                    result = concat(result, str(" "));
                    result = concat(result, field_name);
                    result = concat(result, str(";\n"));
                    
                    field_idx++;
                    continue;
                }
                
                val bracket_pos: i32 = find_char_from(field_type, '[', 0);
                if bracket_pos >= 0 {
                    array_part = substr(field_type, bracket_pos, str_len(field_type) - bracket_pos);
                    field_type = strip(substring_se(field_type, 0, bracket_pos));
                }
                
                mut mapped_type: string = map_axe_type_to_c(field_type);
                
                if has_prefix(mapped_type, str("ref ")) {
                    mapped_type = concat(strip(substr(mapped_type, 4, str_len(mapped_type) - 4)), str("*"));
                }
                
                mapped_type = format_model_field_type(mapped_type);
                
                if compare(field_type, model_name) == 0 {
                    mapped_type = concat(str("struct "), field_type);
                    mapped_type = concat(mapped_type, str("*"));
                }
                
                result = concat(result, str("    "));
                result = concat(result, mapped_type);
                result = concat(result, str(" "));
                result = concat(result, field_name);
                result = concat(result, array_part);
                result = concat(result, str(";\n"));
                
                field_idx++;
            }
        }
        
        result = concat(result, str("};\n\n"));
        return result;
    }
    
    if equals_c(node_type, "Enum") {
        result = concat(result, str("// Enum node\n"));
        result = concat(result, str("typedef enum {} enum_placeholder;\n\n"));
        return result;
    }
    
    return result;
}

test {
    initialize_renderer();
    
    println "\nTest 1: Initialize renderer";
    assert StringStringMap.contains(addr_of(g_type_mappings), str("i32")), "Expected i32 type mapping";
    assert equals_c(map_type(str("i32")), "int32_t"), "Expected i32 to map to int32_t";
    
    println "\nTest 2: Map types";
    assert equals_c(map_type(str("i64")), "int64_t"), "Expected i64 to map to int64_t";
    assert equals_c(map_type(str("f32")), "float"), "Expected f32 to map to float";
    assert equals_c(map_type(str("bool")), "bool"), "Expected bool to map to bool";
    
    println "\nTest 3: Generate empty program";
    mut empty_ast: ASTNode;
    empty_ast.node_type = str("Program");
    empty_ast.children = nil;
    val code: string = generate_c(addr_of(empty_ast));
    assert str_contains_c(code, "#include <stdio.h>"), "Expected stdio.h include";
    assert str_contains_c(code, "#include <stdint.h>"), "Expected stdint.h include";
    
    println "\nTest 4: Generate main function";
    mut func_ast: ASTNode;
    func_ast.node_type = str("Function");
    func_ast.data.function.name = str("main");
    func_ast.data.function.return_type = str("i32");
    func_ast.data.function.is_public = false;
    func_ast.data.function.params = nil;
    func_ast.children = nil;
    val func_code: string = generate_c(addr_of(func_ast));
    assert str_contains_c(func_code, "int main"), "Expected int main function";
    assert str_contains_c(func_code, "return 0;"), "Expected return 0 in main";
    
    println "\nTest 5: Generate simple function";
    mut simple_func: ASTNode;
    simple_func.node_type = str("Function");
    simple_func.data.function.name = str("add");
    simple_func.data.function.return_type = str("i32");
    simple_func.data.function.is_public = false;
    simple_func.data.function.params = nil;
    simple_func.children = nil;
    val simple_code: string = generate_c(addr_of(simple_func));
    assert str_contains_c(simple_code, "int32_t add"), "Expected int32_t add function";
    
    println "\nTest 6: Process parameter types";
    assert equals_c(process_parameter_type(str("i32")), "int32_t"), "Expected i32 -> int32_t";
    assert equals_c(process_parameter_type(str("ref i32")), "int32_t*"), "Expected ref i32 -> int32_t*";
    assert equals_c(process_parameter_type(str("mut i32")), "int32_t"), "Expected mut i32 -> int32_t";
    assert equals_c(process_parameter_type(str("i32*")), "int32_t*"), "Expected i32* -> int32_t*";
    
    println "\nTest 7: Generate simple model";
    mut model_arena: Arena = Arena.create(4096);
    mut model_ast: ASTNode;
    model_ast.node_type = str("Model");
    model_ast.data.model_node.name = str("Point");
    model_ast.data.model_node.is_public = false;
    
    val field_names_list: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names_list, addr_of(model_arena), str("x"));
    StringList.push(field_names_list, addr_of(model_arena), str("y"));
    model_ast.data.model_node.field_names = field_names_list;
    
    val field_types_list: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types_list, addr_of(model_arena), str("i32"));
    StringList.push(field_types_list, addr_of(model_arena), str("i32"));
    model_ast.data.model_node.field_types = field_types_list;
    
    model_ast.children = nil;
    val model_code: string = generate_c(addr_of(model_ast));
    assert str_contains_c(model_code, "struct Point"), "Expected struct Point";
    assert str_contains_c(model_code, "int32_t x"), "Expected int32_t x field";
    assert str_contains_c(model_code, "int32_t y"), "Expected int32_t y field";
    
    println "\nTest 8: Generate model with different types";
    mut model2_ast: ASTNode;
    model2_ast.node_type = str("Model");
    model2_ast.data.model_node.name = str("Person");
    model2_ast.data.model_node.is_public = true;
    
    val field_names2: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names2, addr_of(model_arena), str("age"));
    StringList.push(field_names2, addr_of(model_arena), str("height"));
    StringList.push(field_names2, addr_of(model_arena), str("active"));
    model2_ast.data.model_node.field_names = field_names2;
    
    val field_types2: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types2, addr_of(model_arena), str("i32"));
    StringList.push(field_types2, addr_of(model_arena), str("f32"));
    StringList.push(field_types2, addr_of(model_arena), str("bool"));
    model2_ast.data.model_node.field_types = field_types2;
    
    model2_ast.children = nil;
    val model2_code: string = generate_c(addr_of(model2_ast));
    assert str_contains_c(model2_code, "struct Person"), "Expected struct Person";
    assert str_contains_c(model2_code, "int32_t age"), "Expected int32_t age field";
    assert str_contains_c(model2_code, "float height"), "Expected float height field";
    assert str_contains_c(model2_code, "bool active"), "Expected bool active field";
    
    println "\nTest 9: Model with array field";
    mut model3_ast: ASTNode;
    model3_ast.node_type = str("Model");
    model3_ast.data.model_node.name = str("Buffer");
    model3_ast.data.model_node.is_public = false;
    
    val field_names3: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names3, addr_of(model_arena), str("data"));
    model3_ast.data.model_node.field_names = field_names3;
    
    val field_types3: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types3, addr_of(model_arena), str("i32[100]"));
    model3_ast.data.model_node.field_types = field_types3;
    
    model3_ast.children = nil;
    val model3_code: string = generate_c(addr_of(model3_ast));
    assert str_contains_c(model3_code, "struct Buffer"), "Expected struct Buffer";
    assert str_contains_c(model3_code, "int32_t data[100]"), "Expected array field";
    
    println "\nTest 10: Model with pointer field";
    mut model4_ast: ASTNode;
    model4_ast.node_type = str("Model");
    model4_ast.data.model_node.name = str("Node");
    model4_ast.data.model_node.is_public = false;
    
    val field_names4: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_names4, addr_of(model_arena), str("value"));
    StringList.push(field_names4, addr_of(model_arena), str("next"));
    model4_ast.data.model_node.field_names = field_names4;
    
    val field_types4: ref StringList = StringList.create(addr_of(model_arena), 10);
    StringList.push(field_types4, addr_of(model_arena), str("i32"));
    StringList.push(field_types4, addr_of(model_arena), str("ref Node"));
    model4_ast.data.model_node.field_types = field_types4;
    
    model4_ast.children = nil;
    val model4_code: string = generate_c(addr_of(model4_ast));
    assert str_contains_c(model4_code, "struct Node"), "Expected struct Node";
    assert str_contains_c(model4_code, "int32_t value"), "Expected value field";
    assert str_contains_c(model4_code, "Node* next"), "Expected pointer field";
    
    println "\nTest 11: Test helper functions";
    assert equals_c(map_axe_type_to_c(str("i32")), "int32_t"), "Expected i32 mapping";
    assert equals_c(map_axe_type_to_c(str("ref i64")), "int64_t*"), "Expected ref i64 mapping";
    assert equals_c(map_axe_type_to_c(str("mut f32")), "float"), "Expected mut f32 mapping";
}
