use std.string;
use std.io;
use std.maps;

use lexer (Token);

/// Macro definition modelure
pub model MacroDef {
    params: ref list(string);
    body: ref list(Token);
}

/// Parser context - holds state during parsing
pub model ParserContext {
    tokens: ref list(Token);
    pos: i32;
    is_axec: bool;
    check_entry_point: bool;
    current_module: string;
    current_scope: Scope;
}

/// Scope tracking for variable declarations
pub model Scope {
    variables: StringStringMap;
    parent: ref Scope;
}

/// AST Node - all node types combined with a union
pub model ASTNode {
    node_type: string;
    children: ref list(ASTNode);

    // Union of all possible node-specific data
    // This allows each node to store only the data relevant to its type
    data: union {
        overload_node: model {
            name: string;
            param_name: string;
            call_expr: string;
            type_names: ref list(string);
            target_functions: ref list(string);
        };
        
        declaration: model {
            name: string;
            is_mutable: bool;
            initializer: string;
            type_name: string;
            ref_depth: i32;
        };
        
        array_decl: model {
            name: string;
            is_mutable: bool;
            element_type: string;
            size: string;
            size2: string;
            initializer: list(string);
        };
        
        array_access: model {
            array_name: string;
            index: string;
            index2: string;
        };
        
        array_assign: model {
            array_name: string;
            index: string;
            index2: string;
            value: string;
        };
        
        array_literal: model {
            element_type: string;
            elements: list(string);
        };
        
        function: model {
            name: string;
            params: list(string);
            return_type: string;
            is_public: bool;
        };
        
        macro_node: model {
            name: string;
            params: list(string);
            param_types: list(string);
            body_tokens: list(Token);
        };
        
        assert_node: model {
            condition: string;
            message: string;
        };
        
        if_node: model {
            condition: string;
            elif_branches: list(ASTNode);
            else_body: list(ASTNode);
        };
        
        println: model {
            messages: ref list(string);
            is_expressions: ref list(bool);
        };
        
        print: model {
            messages: ref list(string);
            is_expressions: ref list(bool);
        };
        
        assignment: model {
            variable: string;
            expression: string;
            operator: string;  // "=", "+=", "-="
        };
        
        func_call: model {
            function_name: string;
            args: ref list(string);
        };
        
        interpolated_str: model {
            parts: list(string);
            expressions: list(string);
        };
        
        for_loop: model {
            initialization: string;
            condition: string;
            increment: string;
            is_mutable: bool;
            var_name: string;
            var_type: string;
            init_value: string;
            is_parallel: bool;
            reduction_clauses: list(string);
        };
        
        for_in: model {
            var_name: string;
            array_name: string;
            array_size: string;
        };
        
        return_node: model {
            expression: string;
        };
        
        raw_c: model {
            code: string;
        };
        
        use_node: model {
            module_name: string;
            imports: ref list(string);
            import_all: bool;
        };
        
        model_node: model {
            name: string;
            is_public: bool;
            field_names: list(string);
            field_types: list(string);

            // Union field metadata (for fields declared as `field: union { ... }`).
            // For each union member, we store:
            //   - union_member_parent: the parent union field name
            //   - union_member_names/types: the member name and type
            union_member_parents: list(string);
            union_member_names: list(string);
            union_member_types: list(string);
        };
        
        enum_node: model {
            name: string;
            values: list(string);
        };
        
        model_instantiation: model {
            model_name: string;
            variable_name: string;
            is_mutable: bool;
            field_names: list(string);
            field_values: list(string);
        };
        
        member_access: model {
            object_name: string;
            member_name: string;
            value: string;
        };
        
        external_import: model {
            header_file: string;
        };
        
        opaque_node: model {
            type_names: list(string);
        };
        
        extern_node: model {
            function_name: string;
            params: list(string);
            return_type: string;
        };
        
        unsafe_node: model {
            body: ref list(ASTNode);
        };
        
        switch_node: model {
            expression: string;
        };
        
        case_node: model {
            value: string;
            is_default: bool;
        };
        
        inc_dec: model {
            variable: string;
            is_increment: bool;
        };
        
        member_inc_dec: model {
            object_name: string;
            member_name: string;
            is_increment: bool;
        };
        
        platform_node: model {
            platform_name: string;
        };
        
        parallel_for: model {
            initialization: string;
            condition: string;
            increment: string;
            reduction_clauses: ref list(string);
        };
        
        parallel_local: model {
            private_vars: ref list(string);
            private_types: ref list(string);
            is_mutable: ref list(bool);
        };
        
        /// Simple nodes with no additional data (Loop, Break, Continue, Test, Program, Parallel, Single)
        /// These just use node_type and children
        empty: i32;
    };
}

def create_function_node(name: string, params: list(string), return_type: string, is_public: bool): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Function");
    node.data.function.name = name;
    node.data.function.params = params;
    node.data.function.return_type = return_type;
    node.data.function.is_public = is_public;
    return node;
}

def create_declaration_node(name: string, is_mutable: bool, initializer: string, type_name: string, ref_depth: i32): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Declaration");
    node.data.declaration.name = name;
    node.data.declaration.is_mutable = is_mutable;
    node.data.declaration.initializer = initializer;
    node.data.declaration.type_name = type_name;
    node.data.declaration.ref_depth = ref_depth;
    return node;
}

def create_if_node(condition: string): ASTNode {
    mut node: ASTNode;
    node.node_type = str("If");
    node.data.if_node.condition = condition;
    return node;
}

def create_assignment_node(variable: string, expression: string): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Assignment");
    node.data.assignment.variable = variable;
    node.data.assignment.expression = expression;
    node.data.assignment.operator = str("=");
    return node;
}

def create_return_node(expression: string): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Return");
    node.data.return_node.expression = expression;
    return node;
}

def create_loop_node(): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Loop");
    return node;
}

def create_break_node(): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Break");
    return node;
}

def create_continue_node(): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Continue");
    return node;
}

def create_program_node(): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Program");
    return node;
}

test {
    println "models module loaded";
}
