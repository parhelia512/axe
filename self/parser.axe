// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
// 
// Handles the parsing process - converts tokens into an AST

use lexer (
    Token, 
    TokenType, lex
);

use structs (
    ASTNode,
    ParserContext,
    Scope
);

use gstate;
use std.string;
use std.io;
use std.maps;
use std.arena;
use std.errors;

mut g_type_aliases: StringStringMap;
mut g_imported_modules: StringBoolMap;
mut g_list_of_types: StringStringMap;
mut g_var_mutability: StringBoolMap;
mut g_macro_names: list(string);
mut g_macro_defs: list(MacroDef);

/// Initialize the state-related globals
pub def initialize_all() {
    mut arena: Arena = Arena.create(1024 * 1024);
    g_type_aliases = deref(StringStringMap.create(addr(arena), 128));
    g_imported_modules = deref(StringBoolMap.create(addr(arena), 128));
    g_list_of_types = deref(StringStringMap.create(addr(arena), 128));
    g_var_mutability = deref(StringBoolMap.create(addr(arena), 128));
    g_macro_names.len = 0;
    g_macro_defs.len = 0;
}

def macros_add(name: string, defn: MacroDef) {
    mut i: i32 = 0;
    loop {
        if i >= len(g_macro_names) {
            break;
        }
        if compare(g_macro_names.data[i], name) == 0 {
            g_macro_defs.data[i] = defn;
            return;
        }
        i = i + 1;
    }

    append(g_macro_names, name);
    append(g_macro_defs, defn);
}

def macros_contains(name: string): bool {
    mut i: i32 = 0;
    loop {
        if i >= len(g_macro_names) {
            break;
        }
        if compare(g_macro_names.data[i], name) == 0 {
            return true;
        }
        i = i + 1;
    }
    return false;
}

def macros_get(name: string): MacroDef {
    mut i: i32 = 0;
    loop {
        if i >= len(g_macro_names) {
            break;
        }
        if compare(g_macro_names.data[i], name) == 0 {
            return g_macro_defs.data[i];
        }
        i = i + 1;
    }

    mut empty: MacroDef;
    return empty;
}

/// Check if a string consists only of decimal digits (for macro arg classification)
def is_all_digits(s: string): bool {
    if str_len(s) == 0 {
        return false;
    }
    mut i: i32 = 0;
    loop {
        if i >= str_len(s) {
            break;
        }
        val ch: char = get_char(s, i);
        if ch < '0' or ch > '9' {
            return false;
        }
        i = i + 1;
    }
    return true;
}

/// Register a variable's mutability (true for mut, false for val)
def register_variable(var_name: string, is_mutable: bool) {
    mut arena: Arena = Arena.create(1024);
    debug_print_raw "\n[DEBUG] register_variable:";
    debug_print_raw "\n[DEBUG]   name:";
    print var_name;
    debug_print_raw "\n[DEBUG]   is_mutable:";
    if is_mutable {
        println "true";
    } else {
        println "false";
    }
    StringBoolMap.set(addr(g_var_mutability), addr(arena), var_name, is_mutable);
}

/// Check if a variable has been declared (tracked in mutability map)
def is_variable_declared(var_name: string): bool {
    val declared: bool = StringBoolMap.contains(addr(g_var_mutability), var_name);
    debug_print_raw "\n[DEBUG] is_variable_declared:";
    println var_name;
    if declared {
        debug_print_raw "\n[DEBUG]   declared: true";
    } else {
        debug_print_raw "\n[DEBUG]   declared: false";
    }
    return declared;
}

/// Check if a variable is mutable; undeclared variables are treated as mutable here
def is_variable_mutable(var_name: string): bool {
    if !is_variable_declared(var_name) {
        debug_print_raw "\n[DEBUG] is_variable_mutable: not declared, treating as mutable:";
        println var_name;
        return true;
    }
    val mut_val: bool = StringBoolMap.get(addr(g_var_mutability), var_name);
    debug_print_raw "\n[DEBUG] is_variable_mutable:";
    print var_name;
    if mut_val {
        debug_print_raw "\n[DEBUG]   mutable: true";
    } else {
        debug_print_raw "\n[DEBUG]   mutable: false";
    }
    return mut_val;
}

/// Add a child AST node to a parent AST node
pub def add_child_to_ast(ast: ref ASTNode, child: ASTNode) {
    if ast.children == nil {
        unsafe {
            mut new_list: list(ASTNode);
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(new_list), list_size);
                ast.children = heap_list;
            }
        }
    }
    
    if ast.children != nil {
        unsafe {
            mut temp_list: list(ASTNode);
            val list_size: usize = C.sizeof(list(ASTNode));
            C.memcpy(addr(temp_list), ast.children, list_size);
            append(temp_list, child);          
            C.memcpy(ast.children, addr(temp_list), list_size);
        }
    }
}

/// Parse the tokens into an AST
pub def parse(tokens: ref list(Token), is_axec: bool, check_entry_point: bool, current_module: string): ASTNode {
    mut ctx: ParserContext;
    ctx.tokens = tokens;
    ctx.pos = 0;
    ctx.is_axec = is_axec;
    ctx.check_entry_point = check_entry_point;
    ctx.current_module = current_module;
    
    debug_print_raw "=== DEBUG TOKENS ===";
    mut i: i32 = 0;
    loop {
        if i >= len(ctx.tokens) {
            break;
        }
        val t: Token = ctx.tokens.data[i];
        debug_print_i32 i;
        debug_print_i32 t.token_type;
        debug_print_str t.value;
        i = i + 1;
    }
    debug_print_raw "=== END TOKENS ===";

    mut ast: ASTNode;
    ast.node_type = str("Program");
    
    StringStringMap.clear(addr(g_type_aliases));
    StringBoolMap.clear(addr(g_imported_modules));
    StringStringMap.clear(addr(g_list_of_types));
    StringBoolMap.clear(addr(g_var_mutability));
    
    if str_len(current_module) > 0 {
        // g_imported_modules[current_module] = true
        println "Auto-imported current module: ";
        println current_module;
    }
    
    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        skip_whitespace(addr(ctx));        
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        parse_top_level(addr(ctx), addr(ast));
    }
    
    return ast;
}

/// Parse a top-level construct (use, def, model, enum, val, mut val, etc.)
def parse_top_level(ctx: ref ParserContext, ast: ref ASTNode) {
    if ctx.pos >= len(ctx.tokens) {
        return;
    }
    
    val token_type = ctx.tokens.data[ctx.pos].token_type;
    
    if token_type == TokenType.USE {
        mut node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(node.node_type) > 0 {
            add_child_to_ast(ast, node);
        }
        return;
    }

    if token_type == TokenType.IDENTIFIER {
        val ident_tok: Token = ctx.tokens.data[ctx.pos];
        val ident_name: string = ident_tok.value;

        if macros_contains(ident_name) {
            ctx.pos = ctx.pos + 1; // skip macro name
            skip_whitespace(ctx);

            if !expect(ctx, TokenType.LPAREN) {
                mut err: string = str("ERROR: Expected '(' after macro name");
                err = concat(err, str(" instead got "));
                err = concat(err, ctx.tokens.data[ctx.pos].value);
                enforce(false, error.create(err.data));
                return;
            }
            consume(ctx); // '('

            mut args: list(string);
            mut current_arg: string = str("");
            mut paren_depth: i32 = 0;

            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                val t: Token = peek(ctx);

                if t.token_type == TokenType.RPAREN and paren_depth == 0 {
                    val trimmed: string = strip(current_arg);
                    if str_len(trimmed) > 0 {
                        append(args, trimmed);
                    }
                    consume(ctx);
                    break;
                }

                if t.token_type == TokenType.LPAREN {
                    paren_depth = paren_depth + 1;
                    current_arg = concat(current_arg, t.value);
                    consume(ctx);
                    continue;
                }

                if t.token_type == TokenType.RPAREN {
                    paren_depth = paren_depth - 1;
                    current_arg = concat(current_arg, t.value);
                    consume(ctx);
                    continue;
                }

                if t.token_type == TokenType.COMMA and paren_depth == 0 {
                    val trimmed_arg: string = strip(current_arg);
                    if str_len(trimmed_arg) > 0 {
                        append(args, trimmed_arg);
                    }
                    current_arg = str("");
                    consume(ctx);
                    continue;
                }

                if t.token_type == TokenType.STR {
                    current_arg = concat(current_arg, str("\""));
                    current_arg = concat(current_arg, t.value);
                    current_arg = concat(current_arg, str("\""));
                } elif t.token_type == TokenType.CHAR {
                    current_arg = concat(current_arg, str("'"));
                    current_arg = concat(current_arg, t.value);
                    current_arg = concat(current_arg, str("'"));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    current_arg = concat(current_arg, str(" "));
                } else {
                    current_arg = concat(current_arg, t.value);
                }
                consume(ctx);
            }

            skip_whitespace(ctx);

            if !expect(ctx, TokenType.SEMICOLON) {
                enforce_raw(false, "ERROR: Expected ';' after macro invocation");
                return;
            }
            consume(ctx);

            val defn: MacroDef = macros_get(ident_name);

            mut expanded_tokens: list(Token);
            mut i_tok: i32 = 0;
            loop {
                if i_tok >= len(defn.body) {
                    break;
                }
                append(expanded_tokens, defn.body.data[i_tok]);
                i_tok = i_tok + 1;
            }

            mut i_param: i32 = 0;
            loop {
                if i_param >= len(defn.params) or i_param >= len(args) {
                    break;
                }

                val param_name: string = defn.params.data[i_param];
                val arg_expr: string = args.data[i_param];

                mut j_tok: i32 = 0;
                loop {
                    if j_tok >= len(expanded_tokens) {
                        break;
                    }

                    if expanded_tokens.data[j_tok].token_type == TokenType.IDENTIFIER {
                        mut exp_token: ref Token = addr(expanded_tokens.data[j_tok]);
                        if compare(exp_token.value, param_name) == 0 {
                            exp_token.value = arg_expr;

                            if is_all_digits(arg_expr) {
                                exp_token.token_type = TokenType.NUMBER;
                            }
                        }
                    }
                    j_tok = j_tok + 1;
                }

                i_param = i_param + 1;
            }

            val expanded_ref: ref list(Token) = addr(expanded_tokens);
            val expanded_ast: ASTNode = parse(expanded_ref, ctx.is_axec, false, ctx.current_module);

            if expanded_ast.children != nil {
                mut k: i32 = 0;
                loop {
                    if k >= deref(expanded_ast.children).len {
                        break;
                    }
                    add_child_to_ast(ast, expanded_ast.children.data[k]);
                    k = k + 1;
                }
            }

            return;
        }
    }
    
    if token_type == TokenType.MAIN {
        ctx.pos++;
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            enforce_raw(false, "Expected '{' after 'def main()'" );
            return;
        }
        ctx.pos++; // Skip '{'
        
        mut main_node: ASTNode;
        main_node.node_type = str("Function");
        main_node.data.function.name = str("main");
        main_node.data.function.return_type = str("");
        main_node.data.function.is_public = false;
        
        unsafe {
            mut empty_params: list(string);
            val params_size: usize = C.sizeof(list(string));
            val heap_params: ref list(string) = cast[ref list(string)](C.malloc(params_size));
            if heap_params != nil {
                C.memcpy(heap_params, addr(empty_params), params_size);
                main_node.data.function.params = heap_params;
            }
        }
        
        mut children: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            skip_whitespace(ctx);
            
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                ctx.pos++; // Skip '}'
                break;
            }
            
            mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(children, stmt);
            }
        }
        
        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(children), list_size);
                main_node.children = heap_list;
            }
        }
        
        add_child_to_ast(ast, main_node);
        return;
    }
    
    if token_type == TokenType.DEF {
        ctx.pos++; // Skip 'def'
        mut func_node: ASTNode = parse_function(ctx);
        if str_len(func_node.node_type) > 0 {
            add_child_to_ast(ast, func_node);
        }
        return;
    }
    
    if token_type == TokenType.EXTERN {
        mut extern_node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(extern_node.node_type) > 0 {
            add_child_to_ast(ast, extern_node);
        }
        return;
    }
    
    if token_type == TokenType.MODEL {
        ctx.pos++;
        skip_whitespace(ctx);

        if ctx.pos >= len(ctx.tokens) {
            mut err: string = str("ERROR: Expected model name after 'model'");
            enforce(false, error.create(err.data));
            return;
        }

        // If we see `model {` with no name at top level, treat it as an
        // anonymous model block and skip its body instead of just erroring.
        if ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
            ctx.pos++; // Skip '{'
            mut depth_model: i32 = 1;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t_br: Token = ctx.tokens.data[ctx.pos];
                if t_br.token_type == TokenType.LBRACE {
                    depth_model = depth_model + 1;
                } elif t_br.token_type == TokenType.RBRACE {
                    depth_model = depth_model - 1;
                    if depth_model == 0 {
                        ctx.pos++; // consume final '}'
                        break;
                    }
                }
                ctx.pos++;
            }
            return;
        }

        if ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
            mut err: string = str("ERROR: Expected model name after 'model', instead got: ");
            err = concat(err, ctx.tokens.data[ctx.pos].value);
            enforce(false, error.create(err.data));
            return;
        }

        mut model_node: ASTNode;
        model_node.node_type = str("Model");
        val model_name: string = ctx.tokens.data[ctx.pos].value;
        model_node.data.model_node.name = model_name;
        model_node.data.model_node.is_public = false;
        ctx.pos++;

        skip_whitespace(ctx);
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            enforce_raw(false, "ERROR: Expected '{' after model name");
            return;
        }
        ctx.pos++; // Skip '{'

        mut field_names: list(string);
        mut field_types: list(string);

        mut union_member_parents: list(string);
        mut union_member_names: list(string);
        mut union_member_types: list(string);

        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                ctx.pos++; // Skip '}'
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.PUB {
                ctx.pos++;
                skip_whitespace(ctx);

                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.DEF {
                    ctx.pos++; // skip 'def'
                    mut method_node: ASTNode = parse_function(ctx);
                    if str_len(method_node.node_type) > 0 {
                        method_node.data.function.is_public = true;

                        val orig_name: string = method_node.data.function.name;
                        mut full_name: string = model_name;
                        full_name = concat(full_name, str("__"));
                        full_name = concat(full_name, orig_name);
                        method_node.data.function.name = full_name;

                        add_child_to_ast(ast, method_node);
                    }
                    continue;
                }
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.DEF {
                // Non-pub static method inside model
                ctx.pos++; // skip 'def'
                mut method_node2: ASTNode = parse_function(ctx);
                if str_len(method_node2.node_type) > 0 {
                    val orig_name2: string = method_node2.data.function.name;
                    mut full_name2: string = model_name;
                    full_name2 = concat(full_name2, str("__"));
                    full_name2 = concat(full_name2, orig_name2);
                    method_node2.data.function.name = full_name2;
                    add_child_to_ast(ast, method_node2);
                }
                continue;
            }

            if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER {
                val field_name: string = ctx.tokens.data[ctx.pos].value;
                ctx.pos++;

                skip_whitespace(ctx);

                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.COLON {
                    ctx.pos++;
                    skip_whitespace(ctx);

                    // Parse base type
                    mut field_type: string = parse_type(ctx);

                    // Special handling for `field_name: union { ... }` including anonymous models
                    if str_len(field_type) == 5 and compare(field_type, str("union")) == 0 and ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
                        // Record this as a union field
                        append(field_names, field_name);
                        append(field_types, field_type);

                        ctx.pos++; // Skip '{'

                        loop {
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }

                            skip_whitespace(ctx);
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }

                            val t_inner: Token = ctx.tokens.data[ctx.pos];
                            if t_inner.token_type == TokenType.RBRACE {
                                ctx.pos++; // Skip '}'
                                break;
                            }

                            if t_inner.token_type == TokenType.SEMICOLON or t_inner.token_type == TokenType.NEWLINE {
                                ctx.pos++;
                                continue;
                            }

                            if t_inner.token_type != TokenType.IDENTIFIER {
                                ctx.pos++;
                                continue;
                            }

                            // union member name
                            val member_name: string = t_inner.value;
                            ctx.pos++;

                            skip_whitespace(ctx);
                            if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.COLON {
                                // Malformed, bail out of this member
                                continue;
                            }
                            ctx.pos++; // Skip ':'

                            skip_whitespace(ctx);
                            mut member_base_type: string = parse_type(ctx);

                            // Anonymous model inside union: `member_name: model { ... }`
                            if str_len(member_base_type) == 5 and compare(member_base_type, str("model")) == 0 and ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
                                // Record the anonymous model as a union member of type "model"
                                append(union_member_parents, field_name);
                                append(union_member_names, member_name);
                                append(union_member_types, member_base_type);

                                ctx.pos++; // Skip '{' of anonymous model

                                mut brace_depth: i32 = 0;
                                loop {
                                    if ctx.pos >= len(ctx.tokens) {
                                        break;
                                    }

                                    val t_nested: Token = ctx.tokens.data[ctx.pos];

                                    if t_nested.token_type == TokenType.WHITESPACE or t_nested.token_type == TokenType.NEWLINE or t_nested.token_type == TokenType.SEMICOLON or t_nested.token_type == TokenType.COMMENT {
                                        ctx.pos++;
                                        continue;
                                    }

                                    if t_nested.token_type == TokenType.RBRACE {
                                        if brace_depth == 0 {
                                            ctx.pos++; // consume closing '}' of anonymous model
                                            break;
                                        }
                                        brace_depth = brace_depth - 1;
                                        ctx.pos++;
                                        continue;
                                    }

                                    if t_nested.token_type == TokenType.LBRACE {
                                        brace_depth = brace_depth + 1;
                                        ctx.pos++;
                                        continue;
                                    }

                                    if t_nested.token_type != TokenType.IDENTIFIER {
                                        ctx.pos++;
                                        continue;
                                    }

                                    // Nested field inside anonymous model
                                    val nested_name: string = t_nested.value;
                                    ctx.pos++;

                                    skip_whitespace(ctx);
                                    if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.COLON {
                                        continue;
                                    }
                                    ctx.pos++; // Skip ':'

                                    skip_whitespace(ctx);
                                    mut nested_type: string = parse_type(ctx);

                                    // Optional semicolon
                                    skip_whitespace(ctx);
                                    if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                                        ctx.pos++;
                                    }

                                    // Parent of nested fields is the anonymous model member name
                                    append(union_member_parents, member_name);
                                    append(union_member_names, nested_name);
                                    append(union_member_types, nested_type);
                                }

                                // Optional semicolon after anonymous model member
                                skip_whitespace(ctx);
                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                                    ctx.pos++;
                                }
                            } else {
                                // Normal union member (non-anonymous-model)
                                mut member_type: string = member_base_type;

                                // Consume optional semicolon after union member
                                skip_whitespace(ctx);
                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                                    ctx.pos++;
                                }

                                append(union_member_parents, field_name);
                                append(union_member_names, member_name);
                                append(union_member_types, member_type);
                            }
                        }

                        // After union block, optional semicolon at model level
                        skip_whitespace(ctx);
                        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                            ctx.pos++;
                        }
                    } else {
                        // Normal (non-union) field type, preserve existing suffix handling
                        loop {
                            skip_whitespace(ctx);
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }

                            if ctx.tokens.data[ctx.pos].token_type == TokenType.DOT {
                                field_type = concat(field_type, str("."));
                                ctx.pos++;

                                skip_whitespace(ctx);

                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER {
                                    field_type = concat(field_type, ctx.tokens.data[ctx.pos].value);
                                    ctx.pos++;
                                } else {
                                    break;
                                }
                            } elif ctx.tokens.data[ctx.pos].token_type == TokenType.SLASH {
                                field_type = concat(field_type, str("/"));
                                ctx.pos++;

                                skip_whitespace(ctx);

                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER {
                                    field_type = concat(field_type, ctx.tokens.data[ctx.pos].value);
                                    ctx.pos++;
                                } else {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }

                        skip_whitespace(ctx);
                        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                            ctx.pos++;
                        }

                        append(field_names, field_name);
                        append(field_types, field_type);
                    }
                } else {
                    // No type annotation, skip to semicolon
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = ctx.tokens.data[ctx.pos];
                        if t.token_type == TokenType.SEMICOLON {
                            ctx.pos++;
                            break;
                        }
                        ctx.pos++;
                    }
                }
            } else {
                ctx.pos++;
            }
        }

        unsafe {
            val list_size: usize = C.sizeof(list(string));
            val heap_names: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_names != nil {
                C.memcpy(heap_names, addr(field_names), list_size);
                model_node.data.model_node.field_names = heap_names;
            }

            val heap_types: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_types != nil {
                C.memcpy(heap_types, addr(field_types), list_size);
                model_node.data.model_node.field_types = heap_types;
            }

            val union_list_size: usize = C.sizeof(list(string));
            if len(union_member_parents) > 0 {
                val heap_union_parents: ref list(string) = cast[ref list(string)](C.malloc(union_list_size));
                if heap_union_parents != nil {
                    C.memcpy(heap_union_parents, addr(union_member_parents), union_list_size);
                    model_node.data.model_node.union_member_parents = heap_union_parents;
                }

                val heap_union_names: ref list(string) = cast[ref list(string)](C.malloc(union_list_size));
                if heap_union_names != nil {
                    C.memcpy(heap_union_names, addr(union_member_names), union_list_size);
                    model_node.data.model_node.union_member_names = heap_union_names;
                }

                val heap_union_types: ref list(string) = cast[ref list(string)](C.malloc(union_list_size));
                if heap_union_types != nil {
                    C.memcpy(heap_union_types, addr(union_member_types), union_list_size);
                    model_node.data.model_node.union_member_types = heap_union_types;
                }
            }
        }

        add_child_to_ast(ast, model_node);
        return;
    }
    
    if token_type == TokenType.ENUM {
        ctx.pos++;
        skip_whitespace(ctx);

        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
            enforce_raw(false, "ERROR: Expected enum name after 'enum'");
            return;
        }

        val name_tok: Token = ctx.tokens.data[ctx.pos];
        ctx.pos++;
        val enum_name: string = name_tok.value;

        skip_whitespace(ctx);
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            enforce_raw(false, "ERROR: Expected '{' after enum name");
            return;
        }

        ctx.pos++;

        mut values: list(string);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            val t: Token = ctx.tokens.data[ctx.pos];

            if t.token_type == TokenType.RBRACE {
                ctx.pos++;
                break;
            }

            if t.token_type == TokenType.IDENTIFIER {
                append(values, t.value);
                ctx.pos++;
                continue;
            }

            if t.token_type == TokenType.COMMA or
               t.token_type == TokenType.SEMICOLON or
               t.token_type == TokenType.WHITESPACE or
               t.token_type == TokenType.NEWLINE {
                ctx.pos++;
                continue;
            }

            ctx.pos++;
        }

        mut enum_node: ASTNode;
        enum_node.node_type = str("Enum");
        enum_node.data.enum_node.name = enum_name;

        unsafe {
            val list_size: usize = C.sizeof(list(string));
            mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(values), list_size);
                enum_node.data.enum_node.values = heap_list;
            }
        }

        add_child_to_ast(ast, enum_node);
        return;
    }
    
    if token_type == TokenType.MUT or token_type == TokenType.VAL {
        mut decl_node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(decl_node.node_type) > 0 {
            add_child_to_ast(ast, decl_node);
        }
        return;
    }

    if token_type == TokenType.TEST {
        ctx.pos++;  // Skip 'test'
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            enforce_raw(false, "Expected '{' after 'test'");
            return;
        }
        ctx.pos++; // Skip '{'
        
        mut test_node: ASTNode;
        test_node.node_type = str("Test");
        
        mut children: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                ctx.pos++; // Skip '}'
                break;
            }
            
            mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(children, stmt);
            }
        }
        
        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(children), list_size);
                test_node.children = heap_list;
            }
        }
        
        add_child_to_ast(ast, test_node);
        return;
    }
    
    if token_type == TokenType.OVERLOAD {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            enforce_raw(false, "ERROR: Expected overload name after 'overload'");
            return;
        }
        val overload_name: Token = consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LPAREN) {
            enforce_raw(false, "ERROR: Expected '(' after overload name");
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            enforce_raw(false, "ERROR: Expected parameter name in overload");
            return;
        }
        val param_name_token: Token = consume(ctx);
        val param_name: string = param_name_token.value;
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.COLON) {
            consume(ctx);
            skip_whitespace(ctx);
            if expect(ctx, TokenType.IDENTIFIER) {
                consume(ctx); // Skip type annotation (e.g., 'generic')
                skip_whitespace(ctx);
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            enforce_raw(false, "ERROR: Expected ')' after overload parameter");
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after overload header");
            return;
        }
        consume(ctx);
        
        // Parse type mappings: type => function;
        mut type_names: list(string);
        mut target_funcs: list(string);
        
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if expect(ctx, TokenType.RBRACE) {
                break;
            }
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                enforce_raw(false, "ERROR: Expected type name in overload mapping");
                return;
            }
            val type_token: Token = consume(ctx);
            append(type_names, type_token.value);
            // Support pointer types like "char*" by optionally consuming a STAR
            skip_whitespace(ctx);
            if expect(ctx, TokenType.STAR) {
                consume(ctx);
                // Append '*' to the last stored type name
                val last_idx: i32 = len(type_names) - 1;
                type_names.data[last_idx] = concat(type_names.data[last_idx], str("*"));
                skip_whitespace(ctx);
            }
            
            // Expect '=>'
            if !expect(ctx, TokenType.OPERATOR) {
                enforce_raw(false, "ERROR: Expected '=>' in overload mapping");
                return;
            }
            val op_token: Token = consume(ctx);
            if !equals_c(op_token.value, "=>") {
                enforce_raw(false, "ERROR: Expected '=>' in overload mapping");
                return;
            }
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                enforce_raw(false, "ERROR: Expected target function name in overload mapping");
                return;
            }
            val first_target_token: Token = consume(ctx);
            mut target_name: string = first_target_token.value;
            skip_whitespace(ctx);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
                    break;
                }
                val extra_tok: Token = consume(ctx);

                target_name = concat(target_name, str("_"));
                target_name = concat(target_name, extra_tok.value);

                skip_whitespace(ctx);
            }
            append(target_funcs, target_name);
            
            if !expect(ctx, TokenType.SEMICOLON) {
                mut err: string = str("ERROR: Expected ';' after overload mapping, instead got ");
                if ctx.pos < len(ctx.tokens) {
                    err = concat(err, ctx.tokens.data[ctx.pos].value);
                } else {
                    err = concat(err, str("<eof>"));
                }
                enforce_raw(false, err.data);
                return;
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.RBRACE) {
            enforce_raw(false, "ERROR: Expected '}' after overload mappings");
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        // Parse call expression: (expr)
        if !expect(ctx, TokenType.LPAREN) {
            enforce_raw(false, "ERROR: Expected '(' with call expression after overload block");
            return;
        }
        consume(ctx);
        
        mut call_expr: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if expect(ctx, TokenType.RPAREN) {
                break;
            }
            
            val t: Token = consume(ctx);
            if t.token_type == TokenType.STR {
                call_expr = concat(call_expr, str("\""));
                call_expr = concat(call_expr, t.value);
                call_expr = concat(call_expr, str("\""));
            } elif t.token_type == TokenType.CHAR {
                call_expr = concat(call_expr, str("'"));
                call_expr = concat(call_expr, t.value);
                call_expr = concat(call_expr, str("'"));
            } else {
                call_expr = concat(call_expr, t.value);
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            enforce_raw(false, "ERROR: Expected ')' after overload call expression");
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "ERROR: Expected ';' after overload definition");
            return;
        }
        consume(ctx);
        
        mut overload_node: ASTNode;
        overload_node.node_type = str("Overload");
        overload_node.data.overload_node.name = overload_name.value;
        overload_node.data.overload_node.param_name = param_name;
        overload_node.data.overload_node.call_expr = call_expr;
        
        unsafe {
            val type_list_size: usize = C.sizeof(list(string));
            val heap_type_list: ref list(string) = cast[ref list(string)](C.malloc(type_list_size));
            if heap_type_list != nil {
                C.memcpy(heap_type_list, addr(type_names), type_list_size);
                overload_node.data.overload_node.type_names = heap_type_list;
            }
            
            val func_list_size: usize = C.sizeof(list(string));
            val heap_func_list: ref list(string) = cast[ref list(string)](C.malloc(func_list_size));
            if heap_func_list != nil {
                C.memcpy(heap_func_list, addr(target_funcs), func_list_size);
                overload_node.data.overload_node.target_functions = heap_func_list;
            }
        }
        
        add_child_to_ast(ast, overload_node);
        return;
    }
    
    if token_type == TokenType.PUB {
        ctx.pos++;  // Skip 'pub'
        skip_whitespace(ctx);
        parse_top_level(ctx, ast);
        return;
    }
    
    if token_type == TokenType.MACRO {
        ctx.pos++;  // Skip 'macro'
        skip_whitespace(ctx);

        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
            enforce_raw(false, "ERROR: Expected macro name after 'macro'");
            return;
        }

        val name_tok: Token = ctx.tokens.data[ctx.pos];
        val macro_name: string = name_tok.value;
        ctx.pos++;

        skip_whitespace(ctx);

        mut params: list(string);
        mut param_types: list(string);

        if !expect(ctx, TokenType.LPAREN) {
            mut err: string = str("ERROR: Expected '(' after macro name");
            err = concat(err, str(" instead got "));
            err = concat(err, ctx.tokens.data[ctx.pos].value);
            enforce(false, error.create(err.data));
            return;
        }
        consume(ctx); // '('

        loop {
            skip_whitespace(ctx);
            if expect(ctx, TokenType.RPAREN) {
                consume(ctx);
                break;
            }

            if !expect(ctx, TokenType.IDENTIFIER) {
                enforce_raw(false, "ERROR: Expected parameter name in macro definition");
                return;
            }

            val param_tok: Token = consume(ctx);
            val param_name: string = param_tok.value;

            skip_whitespace(ctx);

            if !expect(ctx, TokenType.COLON) {
                enforce_raw(false, "ERROR: Expected ':' after macro parameter name");
                return;
            }
            consume(ctx);

            skip_whitespace(ctx);

            if !expect(ctx, TokenType.IDENTIFIER) {
                enforce_raw(false, "ERROR: Expected type after ':' in macro parameter");
                return;
            }

            val type_tok: Token = consume(ctx);
            val param_type: string = type_tok.value;

            append(params, param_name);
            append(param_types, param_type);

            skip_whitespace(ctx);

            if expect(ctx, TokenType.COMMA) {
                consume(ctx);
                continue;
            }
        }

        skip_whitespace(ctx);

        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after macro header");
            return;
        }
        consume(ctx); // '{'

        mut body_tokens: list(Token);
        mut brace_depth: i32 = 1;

        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            val t: Token = ctx.tokens.data[ctx.pos];

            if t.token_type == TokenType.LBRACE {
                brace_depth = brace_depth + 1;
                append(body_tokens, t);
                ctx.pos++;
                continue;
            }

            if t.token_type == TokenType.RBRACE {
                brace_depth = brace_depth - 1;
                if brace_depth == 0 {
                    ctx.pos++;
                    break;
                }
                append(body_tokens, t);
                ctx.pos++;
                continue;
            }

            append(body_tokens, t);
            ctx.pos++;
        }

        if brace_depth != 0 {
            enforce_raw(false, "ERROR: Expected '}' after macro body");
            return;
        }

        mut heap_params: ref list(string) = nil;
        mut heap_body: ref list(Token) = nil;
        
        unsafe {
            val params_size: usize = C.sizeof(list(string));
            heap_params = cast[ref list(string)](C.malloc(params_size));
            if heap_params != nil {
                C.memcpy(heap_params, addr(params), params_size);
            }

            val body_size: usize = C.sizeof(list(Token));
            heap_body = cast[ref list(Token)](C.malloc(body_size));
            if heap_body != nil {
                C.memcpy(heap_body, addr(body_tokens), body_size);
            }
        }

        mut macro_node: ASTNode;
        macro_node.node_type = str("Macro");
        macro_node.data.macro_node.name = macro_name;
        macro_node.data.macro_node.params = heap_params;
        macro_node.data.macro_node.param_types = addr(param_types);
        macro_node.data.macro_node.body_tokens = heap_body;

        add_child_to_ast(ast, macro_node);

        mut defn: MacroDef;
        defn.params = heap_params;
        defn.body = heap_body;
        macros_add(macro_name, defn);

        return;
    }
    
    if token_type == TokenType.OPAQUE {
        ctx.pos++;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                ctx.pos++;
                break;
            }
            ctx.pos++;
        }
        return;
    }
    
    if token_type == TokenType.PLATFORM {
        ctx.pos++;
        skip_whitespace(ctx);
        
        if ctx.pos < len(ctx.tokens) {
            ctx.pos++;
        }
        
        skip_whitespace(ctx);
        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
            ctx.pos++;
            mut depth: i32 = 1;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
                    depth = depth + 1;
                }
                if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                    depth = depth - 1;
                    if depth == 0 {
                        ctx.pos++;
                        break;
                    }
                }
                ctx.pos++;
            }
        }
        return;
    }
    
    // Unknown token type - skip it
    ctx.pos++;
}

/// Skip the whitespace and newline tokens
def skip_whitespace(ctx: ref ParserContext) {
    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        val token_type = ctx.tokens.data[ctx.pos].token_type;
        
        if token_type == TokenType.WHITESPACE or token_type == TokenType.NEWLINE {
            ctx.pos++;
        } else {
            break;
        }
    }
}

/// Peek at current token without advancing
def peek(ctx: ref ParserContext): Token {
    if ctx.pos < len(ctx.tokens) {
        return ctx.tokens.data[ctx.pos];
    }
    
    mut empty: Token;
    empty.token_type = TokenType.IDENTIFIER;
    empty.value = str("");
    empty.line = 0;
    empty.column = 0;
    return empty;
}

/// Consume current token and advance
def consume(ctx: ref ParserContext): Token {
    val token: Token = peek(ctx);
    ctx.pos = ctx.pos + 1;
    return token;
}

/// Check if current token matches expected type
def expect(ctx: ref ParserContext, expected_type: i32): bool {
    skip_whitespace(ctx);
    val token: Token = peek(ctx);
    return token.token_type == expected_type;
}

/// Parse a type specification (e.g., "i32", "ref string", "list(Token)")
def parse_type(ctx: ref ParserContext): string {
    skip_whitespace(ctx);
    
    if ctx.pos >= len(ctx.tokens) {
        enforce_raw(false, "Expected type but reached end of tokens");
        return str("");
    }
    
    mut ref_prefix: string = str("");
    
    loop {
        val token: Token = peek(ctx);
        if token.token_type == TokenType.REF {
            ref_prefix = concat_c(ref_prefix, "ref ");
            consume(ctx);
            skip_whitespace(ctx);
        } else {
            break;
        }
    }
    
    skip_whitespace(ctx);
    mut type_name: string = str("");
    val current_token: Token = peek(ctx);
    
    if current_token.token_type == TokenType.MODEL {
        consume(ctx);
        return concat_c(ref_prefix, "model");
    }
    
    if current_token.token_type == TokenType.IDENTIFIER {
        type_name = current_token.value;
        consume(ctx);
        
        // Handle list(ElementType) syntax
        if equals_c(type_name, "list") {
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.LPAREN) {
                enforce_raw(false, "ERROR: Expected '(' after 'list'");
                return str("");
            }
            consume(ctx);
            
            skip_whitespace(ctx);
            val elem_token: Token = consume(ctx);
            val element_type: string = elem_token.value;
            
            skip_whitespace(ctx);
            if !expect(ctx, TokenType.RPAREN) {
                enforce_raw(false, "ERROR: Expected ')' after list element type");
                return str("");
            }
            consume(ctx);
            type_name = concat(element_type, str("[999]"));
        }

        loop {
            if expect(ctx, TokenType.LBRACKET) {
                consume(ctx);
                type_name = concat(type_name, str("["));
                
                loop {
                    val tok: Token = peek(ctx);
                    if tok.token_type == TokenType.RBRACKET {
                        break;
                    }
                    type_name = concat(type_name, tok.value);
                    consume(ctx);
                }
                
                if expect(ctx, TokenType.RBRACKET) {
                    consume(ctx);
                    type_name = concat(type_name, str("]"));
                }
            } else {
                break;
            }
        }
        
        loop {
            val tok: Token = peek(ctx);
            if (tok.token_type == TokenType.OPERATOR and equals_c(tok.value, "*")) or
               (tok.token_type == TokenType.STAR) {
                consume(ctx);
                type_name = concat(type_name, str("*"));
            } else {
                break;
            }
        }
    } else {
        enforce_raw(false, "ERROR: Invalid type specification");
        return str("");
    }
    
    if StringStringMap.contains(addr(g_type_aliases), type_name) {
        type_name = StringStringMap.get(addr(g_type_aliases), type_name);
    }
    
    return concat(ref_prefix, type_name);
}

/// Parse ref depth (e.g., "ref ref int" returns 2)
def parse_ref_depth(ctx: ref ParserContext): i32 {
    mut depth: i32 = 0;
    
    loop {
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        val token: Token = peek(ctx);
        if token.token_type == TokenType.REF {
            depth = depth + 1;
            consume(ctx);
        } else {
            break;
        }
    }
    
    return depth;
}

/// Parse function definition
def parse_function(ctx: ref ParserContext): ASTNode {
    mut func: ASTNode;
    func.node_type = str("Function");
    
    skip_whitespace(ctx);
    if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
        enforce_raw(false, "ERROR: Expected function name after 'def'");
        return func;
    }
    
    mut func_name: string = ctx.tokens.data[ctx.pos].value;
    func.data.function.name = func_name;
    func.data.function.return_type = str("");
    func.data.function.is_public = false;
    ctx.pos++;
    
    skip_whitespace(ctx);

    if ctx.pos + 1 < len(ctx.tokens) {
        if ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER and
           equals_c(ctx.tokens.data[ctx.pos + 1].value, "(") {
            mut merged: string = func_name;
            val next_ident: string = ctx.tokens.data[ctx.pos].value;

            if str_len(next_ident) > 0 and get_char(next_ident, 0) != '_' {
                merged = concat(merged, str("_"));
            }

            merged = concat(merged, next_ident);
            func_name = merged;
            func.data.function.name = merged;
            ctx.pos++;
            skip_whitespace(ctx);
        }
    }

    if !expect(ctx, TokenType.LPAREN) {
        println "DEBUG parse_function: missing '(' after function name";

        mut dbg: string = str("  func_name = ");
        dbg = concat(dbg, func_name);
        println dbg;
        mut buffer: char[64] = {};
        dbg = str("  ctx.pos = ");
        dbg = concat_c(dbg, int_to_str(ctx.pos, buffer));
        dbg = concat(dbg, str(" / "));
        dbg = concat_c(dbg, int_to_str(len(ctx.tokens), buffer));
        println dbg;

        if ctx.pos < len(ctx.tokens) {
            dbg = str("  current token type = ");
            dbg = concat_c(dbg, int_to_str(ctx.tokens.data[ctx.pos].token_type, buffer));
            dbg = concat(dbg, str(", value = '"));
            dbg = concat(dbg, ctx.tokens.data[ctx.pos].value);
            dbg = concat(dbg, str("'"));
            println dbg;
        } else {
            println "  current token = <eof>";
        }

        mut start_dbg: i32 = ctx.pos - 5;
        if start_dbg < 0 {
            start_dbg = 0;
        }
        mut end_dbg: i32 = ctx.pos + 5;
        val total_tokens: i32 = len(ctx.tokens);
        if end_dbg > total_tokens {
            end_dbg = total_tokens;
        }
        println "  Surrounding tokens:";
        mut i_dbg: i32 = start_dbg;
        loop {
            if i_dbg >= end_dbg {
                break;
            }
            val tok_dbg: Token = ctx.tokens.data[i_dbg];
            mut buffer: char[64] = {};

            dbg = str("    [");
            dbg = concat_c(dbg, int_to_str(i_dbg, buffer));

            dbg = concat(dbg, str("] type="));
            dbg = concat_c(dbg, int_to_str(tok_dbg.token_type, buffer));
            dbg = concat(dbg, str(", value='"));
            dbg = concat(dbg, tok_dbg.value);
            dbg = concat(dbg, str("'"));
            println dbg;
            i_dbg = i_dbg + 1;
        }

        mut err: string = str("ERROR: Expected '(' after function name");
        if ctx.pos < len(ctx.tokens) {
            err = concat(err, str(" instead got "));
            err = concat(err, ctx.tokens.data[ctx.pos].value);
        } else {
            err = concat(err, str(" instead got <eof>"));
        }
        err = concat(err, str(" in function "));
        err = concat(err, func_name);
        enforce_raw(false, err.data);
        return func;
    }
    consume(ctx);

    mut params: list(string);
    mut current_param: string = str("");
    mut paren_depth_params: i32 = 0;

    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }

        val t: Token = ctx.tokens.data[ctx.pos];

        if t.token_type == TokenType.RPAREN and paren_depth_params == 0 {
            mut trimmed: string = strip(current_param);
            if str_len(trimmed) > 0 {
                append(params, trimmed);
            }
            ctx.pos++;
            break;
        }

        if t.token_type == TokenType.LPAREN {
            paren_depth_params = paren_depth_params + 1;
            current_param = concat(current_param, t.value);
            consume(ctx);
            continue;
        }

        if t.token_type == TokenType.RPAREN {
            paren_depth_params = paren_depth_params - 1;
            current_param = concat(current_param, t.value);
            consume(ctx);
            continue;
        }

        if t.token_type == TokenType.COMMA and paren_depth_params == 0 {
            mut trimmed_param: string = strip(current_param);
            if str_len(trimmed_param) > 0 {
                append(params, trimmed_param);
            }
            current_param = str("");
            consume(ctx);
            continue;
        }

        if t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
            consume(ctx);
            continue;
        }

        // Preserve spacing for ref/mut prefixes so types like 'ref char'
        // and 'ref ref char' are not squashed into 'refchar'. The renderer
        // relies on a 'ref ' prefix (with space) to map these to pointers.
        
        if t.token_type == TokenType.REF {
            current_param = concat(current_param, str("ref "));
        } elif t.token_type == TokenType.MUT {
            current_param = concat(current_param, str("mut "));
        } else {
            current_param = concat(current_param, t.value);
        }
        consume(ctx);
    }

    // Store parameters on function node (if any)
    if len(params) > 0 {
        unsafe {
            val params_size: usize = C.sizeof(list(string));
            val heap_params: ref list(string) = cast[ref list(string)](C.malloc(params_size));
            if heap_params != nil {
                C.memcpy(heap_params, addr(params), params_size);
                func.data.function.params = heap_params;
            }
        }
    }

    skip_whitespace(ctx);
    if expect(ctx, TokenType.COLON) {
        consume(ctx);
        val return_type: string = parse_type(ctx);
        func.data.function.return_type = return_type;
    }
    
    skip_whitespace(ctx);
    if !expect(ctx, TokenType.LBRACE) {
        mut msg: string = str("ERROR: Expected '{' after function declaration, instead got: ");
        msg = concat(msg, ctx.tokens.data[ctx.pos].value);
        msg = concat(msg, str(" in function "));
        msg = concat(msg, func_name);
        enforce_raw(false, msg.data);
        return func;
    }
    consume(ctx);
    
    mut children: list(ASTNode);
    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
            ctx.pos++;
            break;
        }
        
        mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(stmt.node_type) > 0 {
            append(children, stmt);
        }
    }
    
    unsafe {
        val list_size: usize = C.sizeof(list(ASTNode));
        val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
        if heap_list != nil {
            C.memcpy(heap_list, addr(children), list_size);
            func.children = heap_list;
        }
    }
    
    return func;
}

/// Parse a single statement (helper for parsing function bodies, loops, etc.)
///
/// Returns an ASTNode for the statement, or nil node for whitespace/newlines
def parse_statement_helper(ctx: ref ParserContext, scope: ref Scope): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Empty");
    
    if ctx.pos >= len(ctx.tokens) {
        return node;
    }
    
    val token: Token = peek(ctx);
    val token_type: i32 = token.token_type;
    
    if token_type == TokenType.WHITESPACE or token_type == TokenType.NEWLINE {
        consume(ctx);
        return node;
    }
    
    // Handle BREAK
    if token_type == TokenType.BREAK {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "ERROR: Expected ';' after break");
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Break");
        return node;
    }
    
    // Handle CONTINUE
    if token_type == TokenType.CONTINUE {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "ERROR: Expected ';' after continue");
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Continue");
        return node;
    }
    
    // Handle ASSERT
    if token_type == TokenType.ASSERT {
        consume(ctx);
        skip_whitespace(ctx);
        
        mut has_parens: bool = false;
        if expect(ctx, TokenType.LPAREN) {
            has_parens = true;
            consume(ctx);
        }
        
        mut condition: string = str("");
        mut paren_depth: i32 = 0;
        
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            
            if t.token_type == TokenType.LPAREN {
                paren_depth = paren_depth + 1;
                condition = concat(condition, t.value);
                condition = concat(condition, str(" "));
            } elif t.token_type == TokenType.RPAREN {
                if paren_depth == 0 and has_parens {
                    break;
                }
                paren_depth = paren_depth - 1;
                condition = concat(condition, t.value);
                condition = concat(condition, str(" "));
            } elif t.token_type == TokenType.COMMA and paren_depth == 0 {
                break;
            } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                if t.token_type == TokenType.STR {
                    condition = concat(condition, str("\""));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("\" "));
                } elif t.token_type == TokenType.CHAR {
                    condition = concat(condition, str("'"));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("' "));
                } else {
                    condition = concat(condition, t.value);
                    condition = concat(condition, str(" "));
                }
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.COMMA) {
            enforce_raw(false, "ERROR: Expected ',' after assert condition");
            return node;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.STR) {
            enforce_raw(false, "ERROR: Expected string message after comma in assert");
            return node;
        }
        val message_token: Token = consume(ctx);
        val message: string = message_token.value;
        skip_whitespace(ctx);
        
        if has_parens {
            if !expect(ctx, TokenType.RPAREN) {
                enforce_raw(false, "ERROR: Expected ')' after assert message");
                return node;
            }
            consume(ctx);
            skip_whitespace(ctx);
        }
        
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "ERROR: Expected ';' after assert statement");
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Assert");
        node.data.assert_node.condition = condition;
        node.data.assert_node.message = message;
        debug_print_raw "\n[DEBUG] ASSERT condition:";
        print condition;
        debug_print_raw "\n[DEBUG] ASSERT message:";
        print message;
        return node;
    }
    
    // Handle RETURN
    if token_type == TokenType.RETURN {
        consume(ctx);
        skip_whitespace(ctx);
        
        mut expr: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.SEMICOLON {
                break;
            }
            if t.token_type == TokenType.STR {
                expr = concat(expr, str("\""));
                expr = concat(expr, t.value);
                expr = concat(expr, str("\" "));
            } elif t.token_type == TokenType.CHAR {
                expr = concat(expr, str("'"));
                expr = concat(expr, t.value);
                expr = concat(expr, str("' "));
            } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
            } else {
                if (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("and")) == 0)
                   or t.token_type == TokenType.AND {
                    expr = concat(expr, str("&&"));
                    expr = concat(expr, str(" "));
                } elif (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("or")) == 0)
                       or t.token_type == TokenType.OR {
                    expr = concat(expr, str("||"));
                    expr = concat(expr, str(" "));
                } else {
                    expr = concat(expr, t.value);
                    expr = concat(expr, str(" "));
                }
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "ERROR: Expected ';' after return");
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Return");
        debug_print_raw "\n[DEBUG] RETURN expr:";
        print expr;
        node.data.return_node.expression = expr;
        return node;
    }
    
    // Handle LOOP
    if token_type == TokenType.LOOP {
        consume(ctx);
        skip_whitespace(ctx);

        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after loop");
            return node;
        }
        consume(ctx); // skip '{'

        mut lnode: ASTNode;
        lnode.node_type = str("Loop");

        mut body: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx); // skip '}'
                break;
            }

            mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }

        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(body), list_size);
                lnode.children = heap_list;
            }
        }

        return lnode;
    }
    
    // Handle SWITCH
    if token_type == TokenType.SWITCH {
        consume(ctx);
        skip_whitespace(ctx);
        
        mut switch_expr: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                switch_expr = concat(switch_expr, t.value);
                switch_expr = concat(switch_expr, str(" "));
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after switch expression");
            return node;
        }
        consume(ctx);
        
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Switch");
        return node;
    }
    
    // Handle IF
    if token_type == TokenType.IF {
        consume(ctx);
        skip_whitespace(ctx);

        // Parse condition expression up to '{'
        mut condition: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {

                // If we see a VAL token immediately followed by an IDENTIFIER token, it
                // may be an identifier like 'value' that was split into 'val' + 'ue'.
                //
                // In that case, concatenate the two pieces without an extra space so
                // the condition string becomes "value" instead of "val ue".

                if t.token_type == TokenType.VAL and ctx.pos + 1 < len(ctx.tokens) {
                    val next_tok: Token = ctx.tokens.data[ctx.pos + 1];
                    if next_tok.token_type == TokenType.IDENTIFIER {
                        mut merged: string = t.value;
                        merged = concat(merged, next_tok.value);
                        condition = concat(condition, merged);
                        condition = concat(condition, str(" "));
                        consume(ctx);
                        consume(ctx);
                        continue;
                    }
                }

                if (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("and")) == 0)
                   or t.token_type == TokenType.AND {
                    condition = concat(condition, str("&&"));
                    condition = concat(condition, str(" "));
                } elif (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("or")) == 0)
                       or t.token_type == TokenType.OR {
                    condition = concat(condition, str("||"));
                    condition = concat(condition, str(" "));
                } elif t.token_type == TokenType.STR {
                    condition = concat(condition, str("\""));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("\" "));
                } elif t.token_type == TokenType.CHAR {
                    condition = concat(condition, str("'"));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("' "));
                } else {
                    condition = concat(condition, t.value);
                    condition = concat(condition, str(" "));
                }
            }
            consume(ctx);
        }

        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after if condition");
            return node;
        }
        consume(ctx); // skip '{'

        // Parse if-body statements into a list of children
        mut if_children: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            val t_body: Token = peek(ctx);
            if t_body.token_type == TokenType.RBRACE {
                consume(ctx); // end of if-body
                break;
            }

            mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(if_children, stmt);
            }
        }

        // Support elif/else chains by lowering
        //   if cond1 { ... }
        //   elif cond2 { ... }
        //   else { ... }
        // into a chain of If nodes where each elif becomes the else-branch of the previous.
        //
        // NOTE: We use a list to collect elif nodes and then chain them linearly at the end.

        mut elif_nodes: list(ASTNode);
        mut final_else_children: list(ASTNode);

        skip_whitespace(ctx);

        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type != TokenType.ELIF {
                break;
            }

            ctx.pos = ctx.pos + 1;
            skip_whitespace(ctx);

            mut elif_condition: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t_el: Token = peek(ctx);
                if t_el.token_type == TokenType.LBRACE {
                    break;
                }
                if t_el.token_type != TokenType.WHITESPACE and t_el.token_type != TokenType.NEWLINE {
                    if t_el.token_type == TokenType.VAL and ctx.pos + 1 < len(ctx.tokens) {
                        val next_tok_el: Token = ctx.tokens.data[ctx.pos + 1];
                        if next_tok_el.token_type == TokenType.IDENTIFIER {
                            mut merged_el: string = t_el.value;
                            merged_el = concat(merged_el, next_tok_el.value);
                            elif_condition = concat(elif_condition, merged_el);
                            elif_condition = concat(elif_condition, str(" "));
                            consume(ctx);
                            consume(ctx);
                            continue;
                        }
                    }

                    if (t_el.token_type == TokenType.IDENTIFIER and compare(t_el.value, str("and")) == 0)
                       or t_el.token_type == TokenType.AND {
                        elif_condition = concat(elif_condition, str("&&"));
                        elif_condition = concat(elif_condition, str(" "));
                    } elif (t_el.token_type == TokenType.IDENTIFIER and compare(t_el.value, str("or")) == 0)
                           or t_el.token_type == TokenType.OR {
                        elif_condition = concat(elif_condition, str("||"));
                        elif_condition = concat(elif_condition, str(" "));
                    } elif t_el.token_type == TokenType.STR {
                        elif_condition = concat(elif_condition, str("\""));
                        elif_condition = concat(elif_condition, t_el.value);
                        elif_condition = concat(elif_condition, str("\" "));
                    } elif t_el.token_type == TokenType.CHAR {
                        elif_condition = concat(elif_condition, str("'"));
                        elif_condition = concat(elif_condition, t_el.value);
                        elif_condition = concat(elif_condition, str("' "));
                    } else {
                        elif_condition = concat(elif_condition, t_el.value);
                        elif_condition = concat(elif_condition, str(" "));
                    }
                }
                consume(ctx);
            }

            if !expect(ctx, TokenType.LBRACE) {
                enforce_raw(false, "ERROR: Expected '{' after elif condition");
                return node;
            }
            consume(ctx); // skip '{'

            mut elif_children: list(ASTNode);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                val t_eb: Token = peek(ctx);
                if t_eb.token_type == TokenType.RBRACE {
                    consume(ctx);
                    break;
                }

                mut stmt_eb: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt_eb.node_type) > 0 {
                    append(elif_children, stmt_eb);
                }
            }

            mut elif_node: ASTNode;
            elif_node.node_type = str("If");
            elif_node.data.if_node.condition = elif_condition;

            unsafe {
                mut body_list_el: list(ASTNode);
                mut i_el: i32 = 0;
                loop {
                    if i_el >= len(elif_children) {
                        break;
                    }
                    append(body_list_el, elif_children.data[i_el]);
                    i_el = i_el + 1;
                }

                val sz_el: usize = C.sizeof(list(ASTNode));
                val heap_el: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz_el));
                if heap_el != nil {
                    C.memcpy(heap_el, addr(body_list_el), sz_el);
                    elif_node.children = heap_el;
                }
            }

            append(elif_nodes, elif_node);
            skip_whitespace(ctx);
        }

        skip_whitespace(ctx);
        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.ELSE {
            ctx.pos = ctx.pos + 1; // consume 'else'
            skip_whitespace(ctx);

            if !expect(ctx, TokenType.LBRACE) {
                enforce_raw(false, "ERROR: Expected '{' after else");
                return node;
            }
            consume(ctx); // skip '{'

            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                val t_else2: Token = peek(ctx);
                if t_else2.token_type == TokenType.RBRACE {
                    consume(ctx); // end of else-body
                    break;
                }

                mut stmt2: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt2.node_type) > 0 {
                    append(final_else_children, stmt2);
                }
            }
        }

        mut i_chain: i32 = len(elif_nodes) - 1;
        loop {
            if i_chain < 0 {
                break;
            }
            
            mut else_body_for_this: list(ASTNode);
            
            if i_chain == len(elif_nodes) - 1 {
                if len(final_else_children) > 0 {
                    mut k_final: i32 = 0;
                    loop {
                        if k_final >= len(final_else_children) {
                            break;
                        }
                        append(else_body_for_this, final_else_children.data[k_final]);
                        k_final = k_final + 1;
                    }
                }
            } else {
                append(else_body_for_this, elif_nodes.data[i_chain + 1]);
            }
            
            if len(else_body_for_this) > 0 {
                unsafe {
                    mut new_children: list(ASTNode);
                    mut curr_elif_ptr: ref ASTNode = addr(elif_nodes.data[i_chain]);
                    
                    if curr_elif_ptr.children != nil {
                        mut j_copy: i32 = 0;
                        val curr_children: ref list(ASTNode) = curr_elif_ptr.children;
                        loop {
                            if j_copy >= len(deref(curr_children)) {
                                break;
                            }
                            append(new_children, curr_children.data[j_copy]);
                            j_copy = j_copy + 1;
                        }
                    }
                    
                    mut marker: ASTNode;
                    marker.node_type = str("ElseMarker");
                    append(new_children, marker);
                    
                    mut k_else: i32 = 0;
                    loop {
                        if k_else >= len(else_body_for_this) {
                            break;
                        }
                        append(new_children, else_body_for_this.data[k_else]);
                        k_else = k_else + 1;
                    }
                    
                    val sz_new: usize = C.sizeof(list(ASTNode));
                    val heap_new: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz_new));
                    if heap_new != nil {
                        C.memcpy(heap_new, addr(new_children), sz_new);
                        curr_elif_ptr.children = heap_new;
                    }
                }
            }
            
            i_chain = i_chain - 1;
        }

        mut else_children: list(ASTNode);
        if len(elif_nodes) > 0 {
            append(else_children, elif_nodes.data[0]);
        } else {
            mut k_else_final: i32 = 0;
            loop {
                if k_else_final >= len(final_else_children) {
                    break;
                }
                append(else_children, final_else_children.data[k_else_final]);
                k_else_final = k_else_final + 1;
            }
        }

        // Build If AST node with children list containing then-body and
        // (optionally) else-body nodes in order.
        node.node_type = str("If");
        node.data.if_node.condition = condition;

        unsafe {
            mut body_list: list(ASTNode);

            // First, if-body statements
            mut i_body: i32 = 0;
            loop {
                if i_body >= len(if_children) {
                    break;
                }
                append(body_list, if_children.data[i_body]);
                i_body = i_body + 1;
            }

            // Sentinel: an empty node marking boundary between if and else
            if len(else_children) > 0 {
                mut marker: ASTNode;
                marker.node_type = str("ElseMarker");
                append(body_list, marker);

                mut i_else: i32 = 0;
                loop {
                    if i_else >= len(else_children) {
                        break;
                    }
                    append(body_list, else_children.data[i_else]);
                    i_else = i_else + 1;
                }
            }

            val list_size_if: usize = C.sizeof(list(ASTNode));
            val heap_list_if: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size_if));
            if heap_list_if != nil {
                C.memcpy(heap_list_if, addr(body_list), list_size_if);
                node.children = heap_list_if;
            }
        }

        return node;
    }
    
    if token_type == TokenType.FOR {
        consume(ctx);
        skip_whitespace(ctx);

        mut is_for_in: bool = false;
        mut temp_pos: i32 = ctx.pos;
        
        loop {
            if temp_pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[temp_pos].token_type != TokenType.WHITESPACE and ctx.tokens.data[temp_pos].token_type != TokenType.NEWLINE {
                break;
            }
            temp_pos = temp_pos + 1;
        }
        
        if temp_pos < len(ctx.tokens) and ctx.tokens.data[temp_pos].token_type == TokenType.IDENTIFIER {
            temp_pos = temp_pos + 1;
            loop {
                if temp_pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[temp_pos].token_type != TokenType.WHITESPACE and ctx.tokens.data[temp_pos].token_type != TokenType.NEWLINE {
                    break;
                }
                temp_pos = temp_pos + 1;
            }
            if temp_pos < len(ctx.tokens) and ctx.tokens.data[temp_pos].token_type == TokenType.IN {
                is_for_in = true;
            }
        }
        
        if is_for_in {
            if !expect(ctx, TokenType.IDENTIFIER) {
                enforce_raw(false, "ERROR: Expected variable name in for-in loop");
                return node;
            }
            val item_var_token: Token = consume(ctx);
            val item_var: string = item_var_token.value;
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IN) {
                enforce_raw(false, "ERROR: Expected 'in' in for-in loop");
                return node;
            }
            consume(ctx); // skip 'in'
            skip_whitespace(ctx);
            
            mut collection: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val ct: Token = peek(ctx);
                if ct.token_type == TokenType.LBRACE {
                    break;
                }
                if ct.token_type == TokenType.WHITESPACE or ct.token_type == TokenType.NEWLINE {
                    consume(ctx);
                    continue;
                }
                collection = concat(collection, ct.value);
                consume(ctx);
            }
            collection = strip(collection);
            
            if !expect(ctx, TokenType.LBRACE) {
                enforce_raw(false, "ERROR: Expected '{' after for-in header");
                return node;
            }
            consume(ctx); // skip '{'
            
            mut for_in_node: ASTNode;
            for_in_node.node_type = str("ForIn");
            for_in_node.data.for_in.var_name = item_var;
            for_in_node.data.for_in.array_name = collection;
            
            mut body: list(ASTNode);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                    consume(ctx); // skip '}'
                    break;
                }
                mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt.node_type) > 0 {
                    append(body, stmt);
                }
            }
            
            unsafe {
                val list_size: usize = C.sizeof(list(ASTNode));
                val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
                if heap_list != nil {
                    C.memcpy(heap_list, addr(body), list_size);
                    for_in_node.children = heap_list;
                }
            }
            
            return for_in_node;
        }
        
        mut header: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                header = concat(header, t.value);
                header = concat(header, str(" "));
            }
            consume(ctx);
        }

        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after for header");
            return node;
        }
        consume(ctx); // skip '{'

        mut init: string = str("");
        mut cond: string = str("");
        mut incr: string = str("");
        mut part_idx: i32 = 0;
        mut current: string = str("");

        mut i_hdr: i32 = 0;
        loop {
            if i_hdr >= str_len(header) {
                break;
            }
            val ch_hdr: char = get_char(header, i_hdr);
            if ch_hdr == ';' {
                val trimmed: string = strip(current);
                if str_len(trimmed) > 0 {
                    if part_idx == 0 {
                        init = trimmed;
                    } elif part_idx == 1 {
                        cond = trimmed;
                    } else {
                        incr = trimmed;
                    }
                }
                part_idx = part_idx + 1;
                current = str("");
            } else {
                current = concat_chr(current, ch_hdr);
            }
            i_hdr = i_hdr + 1;
        }

        val last_trimmed: string = strip(current);
        if str_len(last_trimmed) > 0 {
            if part_idx == 0 {
                init = last_trimmed;
            } elif part_idx == 1 {
                cond = last_trimmed;
            } else {
                incr = last_trimmed;
            }
        }

        mut fnode: ASTNode;
        fnode.node_type = str("For");
        fnode.data.for_loop.initialization = init;
        fnode.data.for_loop.condition = cond;
        fnode.data.for_loop.increment = incr;

        mut body: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx); // skip '}'
                break;
            }

            mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }

        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(body), list_size);
                fnode.children = heap_list;
            }
        }

        return fnode;
    }
    
    // Handle PUT.
    if token_type == TokenType.PRINT {
        consume(ctx);
        skip_whitespace(ctx);

        if !expect(ctx, TokenType.STR) {
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t_skip: Token = peek(ctx);
                if t_skip.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            return node;
        }

        val str_token: Token = consume(ctx);
        skip_whitespace(ctx);

        if expect(ctx, TokenType.SEMICOLON) {
            consume(ctx);
        }

        mut messages: list(string);
        mut flags: list(bool);
        append(messages, str_token.value);
        append(flags, false);

        node.node_type = str("Print");

        unsafe {
            val list_size_str: usize = C.sizeof(list(string));
            mut heap_messages: ref list(string) = cast[ref list(string)](C.malloc(list_size_str));
            if heap_messages != nil {
                C.memcpy(heap_messages, addr(messages), list_size_str);
                node.data.print.messages = heap_messages;
            }

            val list_size_bool: usize = C.sizeof(list(bool));
            mut heap_flags: ref list(bool) = cast[ref list(bool)](C.malloc(list_size_bool));
            if heap_flags != nil {
                C.memcpy(heap_flags, addr(flags), list_size_bool);
                node.data.print.is_expressions = heap_flags;
            }
        }

        return node;
    }

    // Handle VAL and MUT VAL (variable declarations)
    if token_type == TokenType.VAL {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            enforce_raw(false, "ERROR: Expected identifier after 'val'");
            return node;
        }
        val var_name: Token = consume(ctx);
        skip_whitespace(ctx);

        mut type_name: string = str("");
        mut initializer: string = str("");
        mut has_explicit_type: bool = false;

        if expect(ctx, TokenType.COLON) {
            consume(ctx);
            type_name = parse_type(ctx);
            has_explicit_type = true;
            skip_whitespace(ctx);
        }

        if expect(ctx, TokenType.OPERATOR) {
            val op_token: Token = peek(ctx);
            if equals_c(op_token.value, "=") {
                consume(ctx);
                skip_whitespace(ctx);

                mut rhs_has_function_call: bool = false;
                mut last_non_ws_token_type: i32 = -1;
                mut first_non_ws_token: Token;
                mut non_ws_count: i32 = 0;

                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }

                    if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        if non_ws_count == 0 {
                            first_non_ws_token = t;
                        }
                        non_ws_count = non_ws_count + 1;

                        if t.token_type == TokenType.IDENTIFIER {
                            if ctx.pos + 1 < len(ctx.tokens) {
                                val next_t: Token = ctx.tokens.data[ctx.pos + 1];
                                if next_t.token_type == TokenType.LPAREN and last_non_ws_token_type != TokenType.NEW {
                                    rhs_has_function_call = true;
                                }
                            }
                        }
                        last_non_ws_token_type = t.token_type;
                    }

                    if t.token_type == TokenType.STR {
                        initializer = concat(initializer, str("\""));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("\" "));
                    } elif t.token_type == TokenType.CHAR {
                        initializer = concat(initializer, str("'"));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("' "));
                    } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        // skip it
                    } else {
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str(" "));
                    }
                    consume(ctx);
                }

                if !has_explicit_type {
                    if non_ws_count == 1 {
                        if first_non_ws_token.token_type == TokenType.NUMBER or (first_non_ws_token.token_type == TokenType.IDENTIFIER and is_all_digits(first_non_ws_token.value)) {
                            type_name = str("int32_t");
                        } elif first_non_ws_token.token_type == TokenType.CHAR {
                            type_name = str("char");
                        } elif first_non_ws_token.token_type == TokenType.STR {
                            type_name = str("char*");
                        }
                    }

                    mut trimmed_init_val: string = strip(initializer);

                    if str_len(type_name) == 0 {
                        val brace_pos_val: i32 = find_char_from(trimmed_init_val, '{', 0);
                        if brace_pos_val > 0 {
                            val inferred_name_brace: string = strip(substring_se(trimmed_init_val, 0, brace_pos_val));
                            if str_len(inferred_name_brace) > 0 {
                                type_name = inferred_name_brace;
                            }
                        }
                    }
                }
            } else {
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }
                    consume(ctx);
                }
            }
        } else {
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
        }

        node.node_type = str("Declaration");
        node.data.declaration.name = var_name.value;
        node.data.declaration.is_mutable = false;
        node.data.declaration.initializer = initializer;
        node.data.declaration.type_name = type_name;
        node.data.declaration.ref_depth = 0;
        register_variable(var_name.value, false);
        debug_print_raw "\n[DEBUG] VAL declaration details:";
        debug_print_raw "\n[DEBUG]   name:";
        print var_name.value;
        debug_print_raw "\n[DEBUG]   type_name:";
        print type_name;
        debug_print_raw "\n[DEBUG]   initializer:";
        print initializer;
        debug_print_raw "\n[DEBUG] VAL declaration finished for:";
        print var_name.value;
        return node;
    }
    
    if token_type == TokenType.MUT {
        consume(ctx); // Skip 'mut'
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.VAL) {
            consume(ctx);
            skip_whitespace(ctx);
        }
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            enforce_raw(false, "ERROR: Expected identifier after 'mut'");
            return node;
        }
        val var_name: Token = consume(ctx);
        skip_whitespace(ctx);

        mut type_name: string = str("");
        mut initializer: string = str("");
        mut has_explicit_type_mut: bool = false;

        if expect(ctx, TokenType.COLON) {
            consume(ctx);
            type_name = parse_type(ctx);
            has_explicit_type_mut = true;
            skip_whitespace(ctx);
        }

        if expect(ctx, TokenType.OPERATOR) {
            val op_token: Token = peek(ctx);
            if equals_c(op_token.value, "=") {
                consume(ctx);
                skip_whitespace(ctx);

                mut rhs_has_function_call_mut: bool = false;
                mut last_non_ws_token_type_mut: i32 = -1;
                mut first_non_ws_token_mut: Token;
                mut non_ws_count_mut: i32 = 0;

                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }

                    if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        if non_ws_count_mut == 0 {
                            first_non_ws_token_mut = t;
                        }
                        non_ws_count_mut = non_ws_count_mut + 1;

                        if t.token_type == TokenType.IDENTIFIER {
                            if ctx.pos + 1 < len(ctx.tokens) {
                                val next_t: Token = ctx.tokens.data[ctx.pos + 1];
                                if next_t.token_type == TokenType.LPAREN and last_non_ws_token_type_mut != TokenType.NEW {
                                    rhs_has_function_call_mut = true;
                                }
                            }
                        }
                        last_non_ws_token_type_mut = t.token_type;
                    }

                    if t.token_type == TokenType.STR {
                        initializer = concat(initializer, str("\""));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("\" "));
                    } elif t.token_type == TokenType.CHAR {
                        initializer = concat(initializer, str("'"));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("' "));
                    } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        // skip adding explicit whitespace
                    } else {
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str(" "));
                    }
                    consume(ctx);
                }

                if !has_explicit_type_mut {
                    if non_ws_count_mut == 1 {
                        if first_non_ws_token_mut.token_type == TokenType.NUMBER or (first_non_ws_token_mut.token_type == TokenType.IDENTIFIER and is_all_digits(first_non_ws_token_mut.value)) {
                            type_name = str("int32_t");
                        } elif first_non_ws_token_mut.token_type == TokenType.CHAR {
                            type_name = str("char");
                        } elif first_non_ws_token_mut.token_type == TokenType.STR {
                            type_name = str("char*");
                        }
                    }

                    mut trimmed_init_mut: string = strip(initializer);
                    if str_len(type_name) == 0 and has_prefix(trimmed_init_mut, str("new ")) {
                        trimmed_init_mut = substring_se(trimmed_init_mut, 4, str_len(trimmed_init_mut));
                        trimmed_init_mut = strip(trimmed_init_mut);

                        mut end_pos_mut: i32 = -1;
                        mut i_mut: i32 = 0;
                        loop {
                            if i_mut >= str_len(trimmed_init_mut) {
                                break;
                            }
                            val ch_mut: char = get_char(trimmed_init_mut, i_mut);
                            if ch_mut == '(' or ch_mut == ' ' or ch_mut == '\t' {
                                end_pos_mut = i_mut;
                                break;
                            }
                            i_mut = i_mut + 1;
                        }
                        if end_pos_mut < 0 {
                            end_pos_mut = str_len(trimmed_init_mut);
                        }
                        val inferred_name_mut: string = strip(substring_se(trimmed_init_mut, 0, end_pos_mut));
                        if str_len(inferred_name_mut) > 0 {
                            type_name = inferred_name_mut;
                        }
                    }
                }
            } else {
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }
                    consume(ctx);
                }
            }
        } else {
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
        }

        node.node_type = str("Declaration");
        node.data.declaration.name = var_name.value;
        node.data.declaration.is_mutable = true;
        node.data.declaration.initializer = initializer;
        node.data.declaration.type_name = type_name;
        node.data.declaration.ref_depth = 0;
        register_variable(var_name.value, true);
        debug_print_raw "\n[DEBUG] MUT declaration finished for:";
        print var_name.value;
        return node;
    }
    
    // Handle IDENTIFIER (function calls, assignments, etc.)
    if token_type == TokenType.IDENTIFIER {
        val ident_token: Token = consume(ctx);
        mut ident_name: string = ident_token.value;
        skip_whitespace(ctx);

        if ctx.pos + 1 < len(ctx.tokens) {
            val look1: Token = ctx.tokens.data[ctx.pos];
            val look2: Token = ctx.tokens.data[ctx.pos + 1];

            if look1.token_type == TokenType.IDENTIFIER and equals_c(look2.value, "(") {
                mut merged_call: string = ident_name;
                val next_ident_call: string = look1.value;

                if str_len(next_ident_call) > 0 and get_char(next_ident_call, 0) != '_' {
                    merged_call = concat(merged_call, str("_"));
                }

                merged_call = concat(merged_call, next_ident_call);
                ident_name = merged_call;
                ctx.pos = ctx.pos + 1;
                skip_whitespace(ctx);
            }
        }

        if ctx.pos >= len(ctx.tokens) {
            return node;
        }
        
        val next_token: Token = peek(ctx);
        
        if next_token.token_type == TokenType.LPAREN {
            consume(ctx);            
            mut paren_depth: i32 = 1;
            mut args_str: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.LPAREN {
                    paren_depth = paren_depth + 1;
                    args_str = concat(args_str, str("("));
                } elif t.token_type == TokenType.RPAREN {
                    paren_depth = paren_depth - 1;
                    if paren_depth == 0 {
                        consume(ctx);
                        break;
                    }
                    args_str = concat(args_str, str(")"));
                } elif t.token_type == TokenType.STR {
                    args_str = concat(args_str, str("\""));
                    args_str = concat(args_str, t.value);
                    args_str = concat(args_str, str("\""));
                } elif t.token_type == TokenType.CHAR {
                    args_str = concat(args_str, str("'"));
                    args_str = concat(args_str, t.value);
                    args_str = concat(args_str, str("'"));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    // normalize to single space
                    args_str = concat(args_str, str(" "));
                } else {
                    args_str = concat(args_str, t.value);
                }
                consume(ctx);
            }
            
            skip_whitespace(ctx);
            
            if expect(ctx, TokenType.SEMICOLON) {
                consume(ctx);
            }
            
            node.node_type = str("FunctionCall");
            node.data.func_call.function_name = ident_name;

            mut args_list: list(string);
            val trimmed_args: string = strip(args_str);
            if str_len(trimmed_args) > 0 {
                append(args_list, trimmed_args);
            }

            unsafe {
                val list_size: usize = C.sizeof(list(string));
                mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
                if heap_list != nil {
                    C.memcpy(heap_list, addr(args_list), list_size);
                    node.data.func_call.args = heap_list;
                }
            }
            return node;
        }
        
        if next_token.token_type == TokenType.LBRACKET {
            consume(ctx); // Skip '['
            skip_whitespace(ctx);
            
            mut index_expr: string = str("");
            mut bracket_depth: i32 = 0;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.LBRACKET {
                    bracket_depth = bracket_depth + 1;
                    index_expr = concat(index_expr, t.value);
                    index_expr = concat(index_expr, str(" "));
                } elif t.token_type == TokenType.RBRACKET {
                    if bracket_depth == 0 {
                        break;
                    }
                    bracket_depth = bracket_depth - 1;
                    index_expr = concat(index_expr, t.value);
                    index_expr = concat(index_expr, str(" "));
                } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                    index_expr = concat(index_expr, t.value);
                    index_expr = concat(index_expr, str(" "));
                }
                consume(ctx);
            }
            
            if !expect(ctx, TokenType.RBRACKET) {
                enforce_raw(false, "ERROR: Expected ']' after array index");
                return node;
            }
            consume(ctx);
            skip_whitespace(ctx);
            
            mut index2_expr: string = str("");
            if expect(ctx, TokenType.LBRACKET) {
                consume(ctx); // Skip '['
                skip_whitespace(ctx);
                
                bracket_depth = 0;
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.LBRACKET {
                        bracket_depth = bracket_depth + 1;
                        index2_expr = concat(index2_expr, t.value);
                        index2_expr = concat(index2_expr, str(" "));
                    } elif t.token_type == TokenType.RBRACKET {
                        if bracket_depth == 0 {
                            break;
                        }
                        bracket_depth = bracket_depth - 1;
                        index2_expr = concat(index2_expr, t.value);
                        index2_expr = concat(index2_expr, str(" "));
                    } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        index2_expr = concat(index2_expr, t.value);
                        index2_expr = concat(index2_expr, str(" "));
                    }
                    consume(ctx);
                }
                
                if !expect(ctx, TokenType.RBRACKET) {
                    enforce_raw(false, "ERROR: Expected ']' after second array index");
                    return node;
                }
                consume(ctx);
                skip_whitespace(ctx);
            }
            
            // Check if this is array assignment: array[index] = value
            if expect(ctx, TokenType.OPERATOR) {
                val op_token: Token = peek(ctx);
                if equals_c(op_token.value, "=") {
                    consume(ctx); // Skip '='
                    skip_whitespace(ctx);
                    
                    mut value_expr: string = str("");
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.SEMICOLON {
                            consume(ctx);
                            break;
                        }
                        if t.token_type == TokenType.STR {
                            value_expr = concat(value_expr, str("\""));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("\" "));
                        } elif t.token_type == TokenType.CHAR {
                            value_expr = concat(value_expr, str("'"));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("' "));
                        } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        } else {
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    node.node_type = str("ArrayAssign");
                    node.data.array_assign.array_name = ident_name;
                    node.data.array_assign.index = index_expr;
                    node.data.array_assign.index2 = index2_expr;
                    node.data.array_assign.value = value_expr;
                    return node;
                }
            }
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            
            node.node_type = str("ArrayAccess");
            node.data.array_access.array_name = ident_name;
            node.data.array_access.index = index_expr;
            node.data.array_access.index2 = index2_expr;
            return node;
        }
        
        if next_token.token_type == TokenType.DOT {
            consume(ctx); // Skip '.'
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                enforce_raw(false, "ERROR: Expected member name after '.'");
                return node;
            }

            val member_token: Token = consume(ctx);
            mut member_name: string = member_token.value;

            skip_whitespace(ctx);

            if ctx.pos + 1 < len(ctx.tokens) {
                val look_member: Token = ctx.tokens.data[ctx.pos];
                val look_after: Token = ctx.tokens.data[ctx.pos + 1];
                if look_member.token_type == TokenType.IDENTIFIER and look_after.token_type == TokenType.LPAREN {
                    mut merged_member: string = member_name;
                    val next_ident_member: string = look_member.value;

                    if str_len(next_ident_member) > 0 and get_char(next_ident_member, 0) != '_' {
                        merged_member = concat(merged_member, str("_"));
                    }

                    merged_member = concat(merged_member, next_ident_member);
                    member_name = merged_member;
                    ctx.pos = ctx.pos + 1;
                    skip_whitespace(ctx);
                }
            }

            if expect(ctx, TokenType.LPAREN) {
                consume(ctx); // skip '('
                mut paren_depth2: i32 = 1;
                mut args_str2: string = str("");
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t2: Token = peek(ctx);
                    if t2.token_type == TokenType.LPAREN {
                        paren_depth2 = paren_depth2 + 1;
                        args_str2 = concat(args_str2, str("("));
                    } elif t2.token_type == TokenType.RPAREN {
                        paren_depth2 = paren_depth2 - 1;
                        if paren_depth2 == 0 {
                            consume(ctx);
                            break;
                        }
                        args_str2 = concat(args_str2, str(")"));
                    } elif t2.token_type == TokenType.STR {
                        args_str2 = concat(args_str2, str("\""));
                        args_str2 = concat(args_str2, t2.value);
                        args_str2 = concat(args_str2, str("\""));
                    } elif t2.token_type == TokenType.CHAR {
                        args_str2 = concat(args_str2, str("'"));
                        args_str2 = concat(args_str2, t2.value);
                        args_str2 = concat(args_str2, str("'"));
                    } elif t2.token_type == TokenType.WHITESPACE or t2.token_type == TokenType.NEWLINE {
                        args_str2 = concat(args_str2, str(" "));
                    } else {
                        args_str2 = concat(args_str2, t2.value);
                    }
                    consume(ctx);
                }

                skip_whitespace(ctx);
                if expect(ctx, TokenType.SEMICOLON) {
                    consume(ctx);
                }

                node.node_type = str("FunctionCall");
                mut full_name: string = ident_name;

                if equals_c(ident_name, "C") {
                    full_name = member_name;
                } else {
                    full_name = concat(full_name, str("__"));
                    full_name = concat(full_name, member_name);
                }

                node.data.func_call.function_name = full_name;

                mut args_list2: list(string);
                val trimmed2: string = strip(args_str2);
                if str_len(trimmed2) > 0 {
                    append(args_list2, trimmed2);
                }

                unsafe {
                    val list_size2: usize = C.sizeof(list(string));
                    mut heap_list2: ref list(string) = cast[ref list(string)](C.malloc(list_size2));
                    if heap_list2 != nil {
                        C.memcpy(heap_list2, addr(args_list2), list_size2);
                        node.data.func_call.args = heap_list2;
                    }
                }
                return node;
            }
            
            if expect(ctx, TokenType.LBRACKET) {
                consume(ctx); // Skip '['
                skip_whitespace(ctx);
                
                mut member_index_expr: string = str("");
                mut member_bracket_depth: i32 = 0;
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.LBRACKET {
                        member_bracket_depth = member_bracket_depth + 1;
                        member_index_expr = concat(member_index_expr, t.value);
                        member_index_expr = concat(member_index_expr, str(" "));
                    } elif t.token_type == TokenType.RBRACKET {
                        if member_bracket_depth == 0 {
                            break;
                        }
                        member_bracket_depth = member_bracket_depth - 1;
                        member_index_expr = concat(member_index_expr, t.value);
                        member_index_expr = concat(member_index_expr, str(" "));
                    } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        member_index_expr = concat(member_index_expr, t.value);
                        member_index_expr = concat(member_index_expr, str(" "));
                    }
                    consume(ctx);
                }
                
                if !expect(ctx, TokenType.RBRACKET) {
                    enforce_raw(false, "ERROR: Expected ']' after member array index");
                    return node;
                }
                consume(ctx);
                skip_whitespace(ctx);
                
                mut member_index2_expr: string = str("");
                if expect(ctx, TokenType.LBRACKET) {
                    consume(ctx); // Skip '['
                    skip_whitespace(ctx);
                    
                    member_bracket_depth = 0;
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.LBRACKET {
                            member_bracket_depth = member_bracket_depth + 1;
                            member_index2_expr = concat(member_index2_expr, t.value);
                            member_index2_expr = concat(member_index2_expr, str(" "));
                        } elif t.token_type == TokenType.RBRACKET {
                            if member_bracket_depth == 0 {
                                break;
                            }
                            member_bracket_depth = member_bracket_depth - 1;
                            member_index2_expr = concat(member_index2_expr, t.value);
                            member_index2_expr = concat(member_index2_expr, str(" "));
                        } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                            member_index2_expr = concat(member_index2_expr, t.value);
                            member_index2_expr = concat(member_index2_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    if !expect(ctx, TokenType.RBRACKET) {
                        enforce_raw(false, "ERROR: Expected ']' after second member array index");
                        return node;
                    }
                    consume(ctx);
                    skip_whitespace(ctx);
                }
                
                if expect(ctx, TokenType.OPERATOR) {
                    val member_op_token: Token = peek(ctx);
                    if equals_c(member_op_token.value, "=") {
                        consume(ctx); // Skip '='
                        skip_whitespace(ctx);
                        
                        mut member_array_value_expr: string = str("");
                        loop {
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }
                            val t: Token = peek(ctx);
                            if t.token_type == TokenType.SEMICOLON {
                                consume(ctx);
                                break;
                            }
                            if t.token_type == TokenType.STR {
                                member_array_value_expr = concat(member_array_value_expr, str("\""));
                                member_array_value_expr = concat(member_array_value_expr, t.value);
                                member_array_value_expr = concat(member_array_value_expr, str("\" "));
                            } elif t.token_type == TokenType.CHAR {
                                member_array_value_expr = concat(member_array_value_expr, str("'"));
                                member_array_value_expr = concat(member_array_value_expr, t.value);
                                member_array_value_expr = concat(member_array_value_expr, str("' "));
                            } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                            } else {
                                member_array_value_expr = concat(member_array_value_expr, t.value);
                                member_array_value_expr = concat(member_array_value_expr, str(" "));
                            }
                            consume(ctx);
                        }
                        
                        mut full_array_name: string = ident_name;
                        full_array_name = concat(full_array_name, str("."));
                        full_array_name = concat(full_array_name, member_name);
                        
                        node.node_type = str("ArrayAssign");
                        node.data.array_assign.array_name = full_array_name;
                        node.data.array_assign.index = member_index_expr;
                        node.data.array_assign.index2 = member_index2_expr;
                        node.data.array_assign.value = member_array_value_expr;
                        return node;
                    }
                }
                
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }
                    consume(ctx);
                }
                
                mut access_array_name: string = ident_name;
                access_array_name = concat(access_array_name, str("."));
                access_array_name = concat(access_array_name, member_name);
                
                node.node_type = str("ArrayAccess");
                node.data.array_access.array_name = access_array_name;
                node.data.array_access.index = member_index_expr;
                node.data.array_access.index2 = member_index2_expr;
                return node;
            }
            
            if expect(ctx, TokenType.OPERATOR) {
                val op_token: Token = peek(ctx);
                if equals_c(op_token.value, "=") {
                    debug_print_raw "\n[DEBUG] MemberAccess assignment check:";
                    debug_print_raw "\n[DEBUG]   object ident_name:";
                    print ident_name;
                    debug_print_raw "\n[DEBUG]   member_name:";
                    print member_name;

                    if !is_variable_mutable(ident_name) {
                        mut err: string = str("ERROR: Cannot assign to member '");
                        err = concat(err, member_name);
                        err = concat(err, str("' of immutable variable '"));
                        err = concat(err, ident_name);
                        err = concat(err, str("'"));
                        enforce_raw(false, err.data);
                        return node;
                    }

                    consume(ctx);
                    skip_whitespace(ctx);
                    
                    mut value_expr: string = str("");
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.SEMICOLON {
                            consume(ctx);
                            break;
                        }
                        if t.token_type == TokenType.STR {
                            value_expr = concat(value_expr, str("\""));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("\" "));
                        } elif t.token_type == TokenType.CHAR {
                            value_expr = concat(value_expr, str("'"));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("' "));
                        } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        } else {
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    node.node_type = str("MemberAccess");
                    node.data.member_access.object_name = ident_name;
                    node.data.member_access.member_name = member_name;
                    node.data.member_access.value = value_expr;
                    return node;
                }
            }
            
            // Check for: member increment/decrement, so obj.field++ or obj.field--
            if expect(ctx, TokenType.INCREMENT) or expect(ctx, TokenType.DECREMENT) {
                val inc_dec_token: Token = peek(ctx);
                val is_inc: bool = inc_dec_token.token_type == TokenType.INCREMENT;
                consume(ctx);
                skip_whitespace(ctx);
                
                if !expect(ctx, TokenType.SEMICOLON) {
                    enforce_raw(false, "ERROR: Expected ';' after member increment/decrement");
                    return node;
                }
                consume(ctx);
                
                node.node_type = str("MemberIncDec");
                node.data.member_inc_dec.object_name = ident_name;
                node.data.member_inc_dec.member_name = member_name;
                node.data.member_inc_dec.is_increment = is_inc;
                return node;
            }
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            
            node.node_type = str("MemberAccess");
            node.data.member_access.object_name = ident_name;
            node.data.member_access.member_name = member_name;
            node.data.member_access.value = str("");
            return node;
        }
        
        if next_token.token_type == TokenType.STAR_DOT {
            consume(ctx); // Skip '*.'
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                enforce_raw(false, "ERROR: Expected member name after '*.'");
                return node;
            }
            
            val ptr_member_token: Token = consume(ctx);
            val ptr_member_name: string = ptr_member_token.value;
            skip_whitespace(ctx);
            
            if expect(ctx, TokenType.OPERATOR) {
                val op_token: Token = peek(ctx);
                if equals_c(op_token.value, "=") {
                    consume(ctx); // Skip '='
                    skip_whitespace(ctx);
                    
                    mut ptr_value_expr: string = str("");
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.SEMICOLON {
                            consume(ctx);
                            break;
                        }
                        if t.token_type == TokenType.STR {
                            ptr_value_expr = concat(ptr_value_expr, str("\""));
                            ptr_value_expr = concat(ptr_value_expr, t.value);
                            ptr_value_expr = concat(ptr_value_expr, str("\" "));
                        } elif t.token_type == TokenType.CHAR {
                            ptr_value_expr = concat(ptr_value_expr, str("'"));
                            ptr_value_expr = concat(ptr_value_expr, t.value);
                            ptr_value_expr = concat(ptr_value_expr, str("' "));
                        } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        } else {
                            ptr_value_expr = concat(ptr_value_expr, t.value);
                            ptr_value_expr = concat(ptr_value_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    node.node_type = str("PtrMemberAccess");
                    node.data.member_access.object_name = ident_name;
                    node.data.member_access.member_name = ptr_member_name;
                    node.data.member_access.value = ptr_value_expr;
                    return node;
                }
            }
            
            if expect(ctx, TokenType.INCREMENT) or expect(ctx, TokenType.DECREMENT) {
                val ptr_inc_dec_token: Token = peek(ctx);
                val ptr_is_inc: bool = ptr_inc_dec_token.token_type == TokenType.INCREMENT;
                consume(ctx);
                skip_whitespace(ctx);
                
                if !expect(ctx, TokenType.SEMICOLON) {
                    enforce_raw(false, "ERROR: Expected ';' after pointer member increment/decrement");
                    return node;
                }
                consume(ctx);
                
                node.node_type = str("PtrMemberIncDec");
                node.data.member_inc_dec.object_name = ident_name;
                node.data.member_inc_dec.member_name = ptr_member_name;
                node.data.member_inc_dec.is_increment = ptr_is_inc;
                return node;
            }
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            
            node.node_type = str("PtrMemberAccess");
            node.data.member_access.object_name = ident_name;
            node.data.member_access.member_name = ptr_member_name;
            node.data.member_access.value = str("");
            return node;
        }
        
        if next_token.token_type == TokenType.OPERATOR and equals_c(next_token.value, "=") {
            debug_print_raw "\n[DEBUG] parse_statement_helper: entering Assignment branch";
            debug_print_raw "\n[DEBUG]   ident_name:";
            print ident_name;

            if !is_variable_declared(ident_name) {
                if !ctx.is_axec {
                    mut err: string = str("ERROR: Undeclared variable: ");
                    err = concat(err, ident_name);
                    enforce_raw(false, err.data);
                    return node;
                }
            }
            if !is_variable_mutable(ident_name) {
                mut err: string = str("ERROR: Cannot assign to immutable variable: ");
                err = concat(err, ident_name);
                enforce_raw(false, err.data);
                return node;
            }

            consume(ctx);
            skip_whitespace(ctx);

            mut expr: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    debug_print_raw "\n[DEBUG]   reached end of tokens while collecting RHS";
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    debug_print_raw "\n[DEBUG]   encountered ';' terminating RHS";
                    consume(ctx);
                    break;
                }

                // Per-token debug for RHS
                debug_print_raw "\n[DEBUG]   RHS token type:";
                print t.token_type;
                debug_print_raw "\n[DEBUG]   RHS token value:";
                print t.value;

                if t.token_type == TokenType.STR {
                    expr = concat(expr, str("\""));
                    expr = concat(expr, t.value);
                    expr = concat(expr, str("\" "));
                } elif t.token_type == TokenType.CHAR {
                    expr = concat(expr, str("'"));
                    expr = concat(expr, t.value);
                    expr = concat(expr, str("' "));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    // I dont give a shit
                } else {
                    if (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("and")) == 0)
                       or t.token_type == TokenType.AND {
                        expr = concat(expr, str("&&"));
                        expr = concat(expr, str(" "));
                    } elif (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("or")) == 0)
                           or t.token_type == TokenType.OR {
                        expr = concat(expr, str("||"));
                        expr = concat(expr, str(" "));
                    } else {
                        expr = concat(expr, t.value);
                        expr = concat(expr, str(" "));
                    }
                }
                consume(ctx);
            }

            debug_print_raw "\n[DEBUG]   final RHS expr:";
            println expr;

            mut trimmed_assign: string = strip(expr);
            val prefix_fix: string = str("_state = ");
            if compare(ident_name, str("fixed")) == 0 and has_prefix(trimmed_assign, prefix_fix) {
                ident_name = str("fixed_state");
                trimmed_assign = substring_se(trimmed_assign, str_len(prefix_fix), str_len(trimmed_assign));
                expr = trimmed_assign;
            }

            node.node_type = str("Assignment");
            node.data.assignment.variable = ident_name;
            node.data.assignment.expression = expr;
            return node;
        }
        
        // Handle: INCREMENT and DECREMENT: variable++ or variable--
        if next_token.token_type == TokenType.INCREMENT or next_token.token_type == TokenType.DECREMENT {
            val is_inc: bool = next_token.token_type == TokenType.INCREMENT;
            consume(ctx);
            skip_whitespace(ctx);

            if !is_variable_declared(ident_name) {
                if !ctx.is_axec {
                    mut err: string = str("ERROR: Undeclared variable: ");
                    err = concat(err, ident_name);
                    enforce_raw(false, err.data);
                    return node;
                }
            }
            if !is_variable_mutable(ident_name) {
                debug_print_raw "\n[DEBUG] Variable is not mutable:";
                println ident_name;
                mut err: string = str("ERROR: Cannot increment/decrement immutable variable: ");
                err = concat(err, ident_name);
                enforce_raw(false, err.data);
                return node;
            }
            
            if !expect(ctx, TokenType.SEMICOLON) {
                enforce_raw(false, "ERROR: Expected ';' after increment/decrement");
                return node;
            }
            consume(ctx);
            
            node.node_type = str("IncDec");
            node.data.inc_dec.variable = ident_name;
            node.data.inc_dec.is_increment = is_inc;
            return node;
        }
        
        // Function call without parentheses (Axe syntax sugar): e.g. println "hello"
        mut args_str_sugar: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.SEMICOLON {
                consume(ctx);
                break;
            }

            if t.token_type == TokenType.STR {
                args_str_sugar = concat(args_str_sugar, str("\""));
                args_str_sugar = concat(args_str_sugar, t.value);
                args_str_sugar = concat(args_str_sugar, str("\""));
            } elif t.token_type == TokenType.CHAR {
                args_str_sugar = concat(args_str_sugar, str("'"));
                args_str_sugar = concat(args_str_sugar, t.value);
                args_str_sugar = concat(args_str_sugar, str("'"));
            } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                args_str_sugar = concat(args_str_sugar, str(" "));
            } else {
                args_str_sugar = concat(args_str_sugar, t.value);
            }
            consume(ctx);
        }

        node.node_type = str("FunctionCall");
        node.data.func_call.function_name = ident_name;

        mut sugar_args_list: list(string);
        val trimmed_sugar: string = strip(args_str_sugar);
        if str_len(trimmed_sugar) > 0 {
            append(sugar_args_list, trimmed_sugar);
        }

        unsafe {
            val list_size_s: usize = C.sizeof(list(string));
            mut heap_list_s: ref list(string) = cast[ref list(string)](C.malloc(list_size_s));
            if heap_list_s != nil {
                C.memcpy(heap_list_s, addr(sugar_args_list), list_size_s);
                node.data.func_call.args = heap_list_s;
            }
        }

        return node;
    }
    
    // Handle PLATFORM
    if token_type == TokenType.PLATFORM {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.WINDOWS) and !expect(ctx, TokenType.POSIX) {
            enforce_raw(false, "ERROR: Expected 'windows' or 'posix' after 'platform'");
            return node;
        }
        val platform_token: Token = consume(ctx);
        val platform_name: string = platform_token.value;
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after platform name");
            return node;
        }
        consume(ctx);
        
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Platform");
        node.data.platform_node.platform_name = platform_name;
        return node;
    }
    
    // Handle PARALLEL
    if token_type == TokenType.PARALLEL {
        consume(ctx);
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.FOR) {
            consume(ctx);
            skip_whitespace(ctx);
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.LBRACE {
                    break;
                }
                consume(ctx);
            }
            
            if !expect(ctx, TokenType.LBRACE) {
                enforce_raw(false, "ERROR: Expected '{' after parallel for header");
                return node;
            }
            consume(ctx);
            
            mut depth: i32 = 1;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.LBRACE {
                    depth = depth + 1;
                } elif t.token_type == TokenType.RBRACE {
                    depth = depth - 1;
                    if depth == 0 {
                        consume(ctx);
                        break;
                    }
                }
                consume(ctx);
            }
            
            node.node_type = str("ParallelFor");
            return node;
        }
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after 'parallel'");
            return node;
        }
        consume(ctx);
        
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Parallel");
        return node;
    }
    
    // Handle SINGLE
    if token_type == TokenType.SINGLE {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after 'single'");
            return node;
        }
        consume(ctx);
        
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Single");
        return node;
    }
    
    if token_type == TokenType.UNSAFE {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after 'unsafe'");
            return node;
        }
        consume(ctx); // Skip '{'
        
        mut body: list(ASTNode);
        
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx); // Skip '}'
                break;
            }
            
            mut stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }
        
        node.node_type = str("Unsafe");

        unsafe {
            val list_size_ast: usize = C.sizeof(list(ASTNode));
            mut heap_body: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size_ast));
            if heap_body != nil {
                C.memcpy(heap_body, addr(body), list_size_ast);
                node.data.unsafe_node.body = heap_body;
            }
        }
        return node;
    }
    
    // Handle RAW (only in .axec files)
    if token_type == TokenType.RAW {
        if !ctx.is_axec {
            enforce_raw(false, "ERROR: Raw C blocks are only allowed in .axec files");
            return node;
        }

        consume(ctx); // Skip 'raw'
        skip_whitespace(ctx);

        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after 'raw'");
            return node;
        }
        consume(ctx); // '{'

        mut raw_code: string = str("");
        mut depth: i32 = 1;

        loop {
            if ctx.pos >= len(ctx.tokens) {
                enforce_raw(false, "ERROR: Unexpected end of tokens in raw block");
                return node;
            }

            val t: Token = peek(ctx);

            if t.token_type == TokenType.LBRACE {
                raw_code = concat(raw_code, str("{"));
                depth = depth + 1;
                consume(ctx);
                continue;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    break;
                } else {
                    raw_code = concat(raw_code, str("}"));
                    consume(ctx);
                    continue;
                }
            }

            if t.token_type == TokenType.NEWLINE {
                raw_code = concat(raw_code, str("\n"));
            } elif t.token_type == TokenType.STR {
                raw_code = concat(raw_code, str("\""));
                raw_code = concat(raw_code, t.value);
                raw_code = concat(raw_code, str("\""));
            } elif t.token_type == TokenType.CHAR {
                raw_code = concat(raw_code, str("'"));
                raw_code = concat(raw_code, t.value);
                raw_code = concat(raw_code, str("'"));
            } else {
                raw_code = concat(raw_code, t.value);
            }

            consume(ctx);
        }

        if !expect(ctx, TokenType.RBRACE) {
            enforce_raw(false, "ERROR: Expected '}' after raw block body");
            return node;
        }
        consume(ctx); // '}'

        node.node_type = str("RawC");
        node.data.raw_c.code = raw_code;
        return node;
    }
    
    // Handle OPAQUE (only in .axec files)
    if token_type == TokenType.OPAQUE {
        consume(ctx); // Skip 'opaque'
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after 'opaque'");
            return node;
        }
        consume(ctx);
        
        // Collect opaque type names
        mut type_names: list(string);
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.RBRACE {
                consume(ctx);
                break;
            }
            if t.token_type == TokenType.IDENTIFIER {
                append(type_names, t.value);
                consume(ctx);
            } elif t.token_type == TokenType.SEMICOLON or t.token_type == TokenType.COMMA {
                consume(ctx);
            } else {
                consume(ctx);
            }
        }
        
        skip_whitespace(ctx);
        
        node.node_type = str("Opaque");
        
        unsafe {
            val list_size: usize = C.sizeof(list(string));
            mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(type_names), list_size);
                node.data.opaque_node.type_names = heap_list;
            }
        }
        
        return node;
    }
    
    // Handle EXTERN (only in .axec files)
    if token_type == TokenType.EXTERN {
        consume(ctx); // Skip 'extern'
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.DEF) {
            enforce_raw(false, "ERROR: Expected 'def' after 'extern'");
            return node;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        // Get function name
        if !expect(ctx, TokenType.IDENTIFIER) {
            enforce_raw(false, "ERROR: Expected function name after 'extern def'");
            return node;
        }
        val func_name_token: Token = consume(ctx);
        val func_name: string = func_name_token.value;
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LPAREN) {
            enforce_raw(false, "ERROR: Expected '(' after extern function name");
            return node;
        }
        consume(ctx); // Skip '('
        
        mut extern_params: list(string);
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.RPAREN {
                break;
            }
            
            mut param_str: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val pt: Token = peek(ctx);
                if pt.token_type == TokenType.COMMA or pt.token_type == TokenType.RPAREN {
                    break;
                }
                if pt.token_type != TokenType.WHITESPACE and pt.token_type != TokenType.NEWLINE {
                    param_str = concat(param_str, pt.value);
                } else {
                    param_str = concat(param_str, str(" "));
                }
                consume(ctx);
            }
            
            val trimmed_param: string = strip(param_str);
            if str_len(trimmed_param) > 0 {
                append(extern_params, trimmed_param);
            }
            
            if ctx.pos < len(ctx.tokens) and peek(ctx).token_type == TokenType.COMMA {
                consume(ctx); // Skip comma
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            enforce_raw(false, "ERROR: Expected ')' after extern parameters");
            return node;
        }
        consume(ctx); // Skip ')'
        skip_whitespace(ctx);
        
        // Parse return type if present
        mut extern_return_type: string = str("");
        if ctx.pos < len(ctx.tokens) and peek(ctx).token_type == TokenType.COLON {
            consume(ctx); // Skip ':'
            skip_whitespace(ctx);
            
            // Parse return type until semicolon
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val rt: Token = peek(ctx);
                if rt.token_type == TokenType.SEMICOLON {
                    break;
                }
                if rt.token_type != TokenType.WHITESPACE and rt.token_type != TokenType.NEWLINE {
                    extern_return_type = concat(extern_return_type, rt.value);
                } elif str_len(extern_return_type) > 0 {
                    extern_return_type = concat(extern_return_type, str(" "));
                }
                consume(ctx);
            }
            extern_return_type = strip(extern_return_type);
        }
        
        skip_whitespace(ctx);
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "ERROR: Expected ';' after extern declaration");
            return node;
        }
        consume(ctx); // Skip ';'
        
        node.node_type = str("Extern");
        node.data.extern_node.function_name = func_name;
        node.data.extern_node.params = addr(extern_params);
        node.data.extern_node.return_type = extern_return_type;
        return node;
    }
    
    if token_type == TokenType.USE {
        consume(ctx); // Skip 'use'
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.EXTERNAL) {
            consume(ctx);
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.LPAREN) {
                enforce_raw(false, "ERROR: Expected '(' after 'use external'");
                return node;
            }
            consume(ctx);
            
            if !expect(ctx, TokenType.STR) {
                enforce_raw(false, "ERROR: Expected string literal for header file");
                return node;
            }
            val header_token: Token = consume(ctx);
            val header_file: string = header_token.value;
            
            if !expect(ctx, TokenType.RPAREN) {
                enforce_raw(false, "ERROR: Expected ')' after header file");
                return node;
            }
            consume(ctx);
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.SEMICOLON) {
                enforce_raw(false, "ERROR: Expected ';' after external import");
                return node;
            }
            consume(ctx);
            
            node.node_type = str("ExternalImport");
            node.data.external_import.header_file = header_file;
            return node;
        }
        
        mut module_name: string = str("");
        
        loop {
            if expect(ctx, TokenType.DOT) {
                val dot_tok: Token = peek(ctx);
                consume(ctx);
                
                if expect(ctx, TokenType.DOT) {
                    consume(ctx);
                    if expect(ctx, TokenType.SLASH) {
                        consume(ctx);
                        module_name = concat(module_name, str("../"));
                        continue;
                    }
                } elif expect(ctx, TokenType.SLASH) {
                    consume(ctx);
                    module_name = concat(module_name, str("./"));
                    continue;
                }
            }
            break;
        }
        
        // Parse module path (e.g., std.io or std/maps)
        if !expect(ctx, TokenType.IDENTIFIER) {
            enforce_raw(false, "ERROR: Expected module name after 'use'");
            return node;
        }
        val first_ident: Token = consume(ctx);
        module_name = concat(module_name, first_ident.value);
        
        loop {
            skip_whitespace(ctx);
            if expect(ctx, TokenType.DOT) {
                consume(ctx);
                module_name = concat(module_name, str("."));
                
                if !expect(ctx, TokenType.IDENTIFIER) {
                    enforce_raw(false, "ERROR: Expected identifier after '.' in module path");
                    return node;
                }
                val ident: Token = consume(ctx);
                module_name = concat(module_name, ident.value);
            } elif expect(ctx, TokenType.SLASH) {
                consume(ctx);
                module_name = concat(module_name, str("/"));
                
                if !expect(ctx, TokenType.IDENTIFIER) {
                    enforce_raw(false, "ERROR: Expected identifier after '/' in module path");
                    return node;
                }
                val ident: Token = consume(ctx);
                module_name = concat(module_name, ident.value);
            } elif expect(ctx, TokenType.IDENTIFIER) {
                val ident2: Token = peek(ctx);
                if str_len(ident2.value) > 0 and get_char(ident2.value, 0) == '_' {
                    consume(ctx);
                    module_name = concat(module_name, ident2.value);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        
        skip_whitespace(ctx);
        
        // Check for import all syntax: use module;
        if expect(ctx, TokenType.SEMICOLON) {
            consume(ctx);
            node.node_type = str("Use");
            node.data.use_node.module_name = module_name;
            node.data.use_node.import_all = true;
            return node;
        }
        
        // Parse selective imports: use module (item1, item2);
        if !expect(ctx, TokenType.LPAREN) {
            enforce_raw(false, "ERROR: Expected '(' or ';' after module name");
            return node;
        }
        consume(ctx);
        
        mut imports: list(string);
        loop {
            skip_whitespace(ctx);
            if expect(ctx, TokenType.RPAREN) {
                break;
            }
            
            if expect(ctx, TokenType.IDENTIFIER) {
                val import_token: Token = consume(ctx);
                append(imports, import_token.value);
            } elif expect(ctx, TokenType.COMMA) {
                consume(ctx);
            } else {
                enforce_raw(false, "ERROR: Expected identifier or ',' in use statement");
                return node;
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            enforce_raw(false, "ERROR: Expected ')' after imports");
            return node;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "ERROR: Expected ';' after use statement");
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Use");
        node.data.use_node.module_name = module_name;
        
        // Heap-allocate the imports list so it persists after function returns
        // The list struct contains data inline, so we just copy the whole struct
        unsafe {
            val list_size: usize = C.sizeof(list(string));
            mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(imports), list_size);
                node.data.use_node.imports = heap_list;
            }
        }
        
        node.data.use_node.import_all = false;
        return node;
    }
    
    // Handle CASE (within switch statements)
    if token_type == TokenType.CASE {
        debug_print_raw "\n[DEBUG] Parsing CASE statement";
        consume(ctx); // Skip 'case'
        debug_print_raw "\n[DEBUG] Consumed 'case' token";
        skip_whitespace(ctx);
        debug_print_raw "\n[DEBUG] Skipped whitespace after 'case'";
        
        // Collect case value until '{'
        mut case_value: string = str("");
        debug_print_raw "\n[DEBUG] Starting to collect case value";
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                case_value = concat(case_value, t.value);
                case_value = concat(case_value, str(" "));
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after case value");
            return node;
        }
        consume(ctx);
        
        // Skip case body
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Case");
        node.data.case_node.value = case_value;
        node.data.case_node.is_default = false;
        return node;
    }
    
    // Handle DEFAULT (within switch statements)
    if token_type == TokenType.DEFAULT {
        consume(ctx); // Skip 'default'
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "ERROR: Expected '{' after default");
            return node;
        }
        consume(ctx);
        
        // Skip default body
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Case");
        node.data.case_node.value = str("");
        node.data.case_node.is_default = true;
        return node;
    }
    
    // For now, skip unknown tokens
    consume(ctx);
    return node;
}

test {
    initialize_all();
    
    println "\nTest 1: parse_type with simple type";
    mut tokens1: list(Token) = lex(str("i32"));
    mut ctx1: ParserContext;
    ctx1.tokens = addr(tokens1);
    ctx1.pos = 0;
    mut type1: string = parse_type(addr(ctx1));
    assert equals_c(type1, "i32"), "Expected i32.";

    println "\nTest 2: skip_whitespace";
    mut tokens2: list(Token) = lex(str("   \n  \t  i32"));
    mut ctx2: ParserContext;
    ctx2.tokens = addr(tokens2);
    ctx2.pos = 0;
    mut pos_before: i32 = ctx2.pos;
    skip_whitespace(addr(ctx2));
    assert ctx2.pos > pos_before, "Expected position to advance after skipping whitespace";

    println "\nTest 3: peek and consume";
    mut tokens3: list(Token) = lex(str("identifier"));
    mut ctx3: ParserContext;
    ctx3.tokens = addr(tokens3);
    ctx3.pos = 0;
    mut peeked: Token = peek(addr(ctx3));
    mut pos_after_peek: i32 = ctx3.pos;
    mut consumed: Token = consume(addr(ctx3));
    mut pos_after_consume: i32 = ctx3.pos;
    assert pos_after_peek == 0 and pos_after_consume == 1, "Expected position to advance after consume";

    println "\nTest 4: expect";
    mut tokens4: list(Token) = lex(str("def function_name"));
    mut ctx4: ParserContext;
    ctx4.tokens = addr(tokens4);
    ctx4.pos = 0;
    assert expect(addr(ctx4), TokenType.DEF), "Expected to find 'def' token";

    println "\nTest 5: parse_type with ref type";
    mut tokens5: list(Token) = lex(str("ref i32"));
    mut ctx5: ParserContext;
    ctx5.tokens = addr(tokens5);
    ctx5.pos = 0;
    mut type5: string = parse_type(addr(ctx5));
    assert str_len(type5) > 0, "Expected non-empty type string for 'ref i32'";
    assert str_contains_c(type5, "i32"), "Expected type to contain 'i32'";

    println "\nTest 6: parse_type with list type";
    mut tokens6: list(Token) = lex(str("list(Token)"));
    mut ctx6: ParserContext;
    ctx6.tokens = addr(tokens6);
    ctx6.pos = 0;
    mut type6: string = parse_type(addr(ctx6));
    assert str_len(type6) > 0, "Expected non-empty type for list(Token)";
    assert str_contains_c(type6, "Token"), "Expected type to contain 'Token'";

    println "\nTest 7: parse simple function with parse_function";
    mut tokens7: list(Token) = lex(str("foo(): i32 { return 42; }"));
    mut ctx7: ParserContext;
    ctx7.tokens = addr(tokens7);
    ctx7.pos = 0;
    mut func7: ASTNode = parse_function(addr(ctx7));
    assert equals_c(func7.node_type, "Function"), "Expected Function node type";

    println "\nTest 8: parse function with parameters";
    mut tokens8: list(Token) = lex(str("add(a: i32): i32 { return a; }"));
    mut ctx8: ParserContext;
    ctx8.tokens = addr(tokens8);
    ctx8.pos = 0;
    mut func8: ASTNode = parse_function(addr(ctx8));
    assert equals_c(func8.node_type, "Function"), "Expected Function node for function with params";

    println "\nTest 9: parse full program with def main";
    mut tokens9: list(Token) = lex(str("def main() { }"));
    mut empty_module: string = str("");
    mut ast9: ASTNode = parse(addr(tokens9), false, false, empty_module);
    assert equals_c(ast9.node_type, "Program"), "Expected Program AST node";

    println "\nTest 10: parse program with model definition";
    mut tokens10: list(Token) = lex(str("model Point { x: i32 } def main() { }"));
    mut ast10: ASTNode = parse(addr(tokens10), false, false, str(""));
    assert equals_c(ast10.node_type, "Program"), "Expected Program node with model";

    println "\nTest 11: parse program with enum definition";
    mut tokens11: list(Token) = lex(str("enum Color { Red } def main() { }"));
    mut ast11: ASTNode = parse(addr(tokens11), false, false, str(""));
    assert equals_c(ast11.node_type, "Program"), "Expected Program node with enum";

    println "\nTest 12: parse program with use statement";
    mut tokens12: list(Token) = lex(str("use std.io; def main() { }"));
    mut ast12: ASTNode = parse(addr(tokens12), false, false, str(""));
    assert equals_c(ast12.node_type, "Program"), "Expected Program node with use statement";

    println "\nTest 13: parse program with global val";
    mut tokens13: list(Token) = lex(str("val CONSTANT: i32 = 42; def main() { }"));
    mut ast13: ASTNode = parse(addr(tokens13), false, false, str(""));
    assert equals_c(ast13.node_type, "Program"), "Expected Program node with global val";

    println "\nTest 14: parse program with mut val";
    mut tokens14: list(Token) = lex(str("mut val counter: i32 = 0; def main() { }"));
    mut ast14: ASTNode = parse(addr(tokens14), false, false, str(""));
    assert equals_c(ast14.node_type, "Program"), "Expected Program node with mut val";

    println "\nTest 15: parse program with pub function";
    mut tokens15: list(Token) = lex(str("pub def helper() { } def main() { }"));
    mut ast15: ASTNode = parse(addr(tokens15), false, false, str(""));
    assert equals_c(ast15.node_type, "Program"), "Expected Program node with pub function";

    println "\nTest 16: parse empty test block";
    mut tokens16: list(Token) = lex(str("test { }"));
    mut ast16: ASTNode = parse(addr(tokens16), false, false, str(""));
    assert equals_c(ast16.node_type, "Program"), "Expected Program node with test block";

    println "\nTest 17: parse_type with pointer syntax";
    mut tokens17: list(Token) = lex(str("i32*"));
    mut ctx17: ParserContext;
    ctx17.tokens = addr(tokens17);
    ctx17.pos = 0;
    mut type17: string = parse_type(addr(ctx17));
    assert str_len(type17) > 0, "Expected non-empty type for i32*";
    assert str_contains_c(type17, "i32"), "Expected type to contain 'i32'";

    println "\nTest 18: parse multiple functions";
    mut tokens18: list(Token) = lex(str("def foo() { } def bar() { } def main() { }"));
    mut ast18: ASTNode = parse(addr(tokens18), false, false, str(""));
    assert equals_c(ast18.node_type, "Program"), "Expected Program node with multiple functions";

    println "\nTest 19: parse_statement_helper with break";
    mut tokens19: list(Token) = lex(str("break;"));
    mut ctx19: ParserContext;
    ctx19.tokens = addr(tokens19);
    ctx19.pos = 0;
    ctx19.is_axec = false;
    ctx19.check_entry_point = false;
    ctx19.current_module = str("");
    mut stmt19: ASTNode = parse_statement_helper(addr(ctx19), addr(ctx19.current_scope));
    assert equals_c(stmt19.node_type, "Break"), "Expected Break node";

    println "\nTest 20: parse_statement_helper with return";
    mut tokens20: list(Token) = lex(str("return 42;"));
    mut ctx20: ParserContext;
    ctx20.tokens = addr(tokens20);
    ctx20.pos = 0;
    ctx20.is_axec = false;
    mut stmt20: ASTNode = parse_statement_helper(addr(ctx20), addr(ctx20.current_scope));
    assert equals_c(stmt20.node_type, "Return"), "Expected Return node";
    assert str_contains_c(stmt20.data.return_node.expression, "42"), "Expected return expression to contain '42'";

    println "\nTest 21: parse_statement_helper with assert";
    mut tokens21: list(Token) = lex(str("assert x > 0, \"x must be positive\";"));
    mut ctx21: ParserContext;
    ctx21.tokens = addr(tokens21);
    ctx21.pos = 0;
    ctx21.is_axec = false;
    mut stmt21: ASTNode = parse_statement_helper(addr(ctx21), addr(ctx21.current_scope));
    assert equals_c(stmt21.node_type, "Assert"), "Expected Assert node";
    assert str_len(stmt21.data.assert_node.condition) > 0, "Expected assert condition";
    assert str_len(stmt21.data.assert_node.message) > 0, "Expected assert message";

    println "\nTest 22: parse_statement_helper with unsafe block";
    mut tokens22: list(Token) = lex(str("unsafe { }"));
    mut ctx22: ParserContext;
    ctx22.tokens = addr(tokens22);
    ctx22.pos = 0;
    ctx22.is_axec = false;
    mut stmt22: ASTNode = parse_statement_helper(addr(ctx22), addr(ctx22.current_scope));
    assert equals_c(stmt22.node_type, "Unsafe"), "Expected Unsafe node";

    println "\nTest 23: parse_statement_helper with if-elif-else";
    mut tokens23: list(Token) = lex(str("if x > 0 { println x; } elif x < 0 { println x; } else { println x; }"));
    mut ctx23: ParserContext;
    ctx23.tokens = addr(tokens23);
    ctx23.pos = 0;
    ctx23.is_axec = false;
    mut stmt23: ASTNode = parse_statement_helper(addr(ctx23), addr(ctx23.current_scope));
    assert equals_c(stmt23.node_type, "If"), "Expected If node with elif and else";

    println "\nTest 24: parse_statement_helper with use statement";
    mut tokens24: list(Token) = lex(str("use std.io;"));
    mut ctx24: ParserContext;
    ctx24.tokens = addr(tokens24);
    ctx24.pos = 0;
    ctx24.is_axec = false;
    mut stmt24: ASTNode = parse_statement_helper(addr(ctx24), addr(ctx24.current_scope));
    assert equals_c(stmt24.node_type, "Use"), "Expected Use node";
    assert stmt24.data.use_node.import_all == true, "Expected import_all to be true";

    println "\nTest 25: parse_statement_helper with use selective imports";
    mut tokens25: list(Token) = lex(str("use std.maps (StringIntMap, StringStringMap);"));
    mut ctx25: ParserContext;
    ctx25.tokens = addr(tokens25);
    ctx25.pos = 0;
    ctx25.is_axec = false;
    mut stmt25: ASTNode = parse_statement_helper(addr(ctx25), addr(ctx25.current_scope));
    assert equals_c(stmt25.node_type, "Use"), "Expected Use node with selective imports";
    assert stmt25.data.use_node.import_all == false, "Expected import_all to be false";

    println "\nTest 26: parse_statement_helper with case";
    mut tokens26: list(Token) = lex(str("case 1 { println \"one\"; }"));
    mut ctx26: ParserContext;
    ctx26.tokens = addr(tokens26);
    ctx26.pos = 0;
    ctx26.is_axec = false;
    mut stmt26: ASTNode = parse_statement_helper(addr(ctx26), addr(ctx26.current_scope));
    assert equals_c(stmt26.node_type, "Case"), "Expected Case node";
    assert stmt26.data.case_node.is_default == false, "Expected non-default case";

    println "\nTest 27: parse_statement_helper with default";
    mut tokens27: list(Token) = lex(str("default { println \"other\"; }"));
    mut ctx27: ParserContext;
    ctx27.tokens = addr(tokens27);
    ctx27.pos = 0;
    ctx27.is_axec = false;
    mut stmt27: ASTNode = parse_statement_helper(addr(ctx27), addr(ctx27.current_scope));
    assert equals_c(stmt27.node_type, "Case"), "Expected Case node for default";
    assert stmt27.data.case_node.is_default == true, "Expected default case";

    println "\nTest 28: parse_statement_helper with member access assignment";
    mut tokens28: list(Token) = lex(str("obj.field = 42;"));
    mut ctx28: ParserContext;
    ctx28.tokens = addr(tokens28);
    ctx28.pos = 0;
    ctx28.is_axec = false;
    mut stmt28: ASTNode = parse_statement_helper(addr(ctx28), addr(ctx28.current_scope));
    assert equals_c(stmt28.node_type, "MemberAccess"), "Expected MemberAccess node";
    assert equals_c(stmt28.data.member_access.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt28.data.member_access.member_name, "field"), "Expected member name 'field'";
    assert str_contains_c(stmt28.data.member_access.value, "42"), "Expected value to contain '42'";

    println "\nTest 29: parse_statement_helper with member access read";
    mut tokens29: list(Token) = lex(str("obj.field;"));
    mut ctx29: ParserContext;
    ctx29.tokens = addr(tokens29);
    ctx29.pos = 0;
    ctx29.is_axec = false;
    mut stmt29: ASTNode = parse_statement_helper(addr(ctx29), addr(ctx29.current_scope));
    assert equals_c(stmt29.node_type, "MemberAccess"), "Expected MemberAccess node";
    assert equals_c(stmt29.data.member_access.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt29.data.member_access.member_name, "field"), "Expected member name 'field'";
    assert equals_c(stmt29.data.member_access.value, ""), "Expected empty value for read access";

    println "\nTest 30: parse_statement_helper with array access";
    mut tokens30: list(Token) = lex(str("arr[5];"));
    mut ctx30: ParserContext;
    ctx30.tokens = addr(tokens30);
    ctx30.pos = 0;
    ctx30.is_axec = false;
    mut stmt30: ASTNode = parse_statement_helper(addr(ctx30), addr(ctx30.current_scope));
    assert equals_c(stmt30.node_type, "ArrayAccess"), "Expected ArrayAccess node";
    assert equals_c(stmt30.data.array_access.array_name, "arr"), "Expected array name 'arr'";
    assert str_contains_c(stmt30.data.array_access.index, "5"), "Expected index to contain '5'";

    println "\nTest 31: parse_statement_helper with array assignment";
    mut tokens31: list(Token) = lex(str("arr[i] = 42;"));
    mut ctx31: ParserContext;
    ctx31.tokens = addr(tokens31);
    ctx31.pos = 0;
    ctx31.is_axec = false;
    mut stmt31: ASTNode = parse_statement_helper(addr(ctx31), addr(ctx31.current_scope));
    assert equals_c(stmt31.node_type, "ArrayAssign"), "Expected ArrayAssign node";
    assert equals_c(stmt31.data.array_assign.array_name, "arr"), "Expected array name 'arr'";
    assert str_contains_c(stmt31.data.array_assign.index, "i"), "Expected index to contain 'i'";
    assert str_contains_c(stmt31.data.array_assign.value, "42"), "Expected value to contain '42'";

    println "\nTest 32: parse_statement_helper with 2D array access";
    mut tokens32: list(Token) = lex(str("matrix[i][j];"));
    mut ctx32: ParserContext;
    ctx32.tokens = addr(tokens32);
    ctx32.pos = 0;
    ctx32.is_axec = false;
    mut stmt32: ASTNode = parse_statement_helper(addr(ctx32), addr(ctx32.current_scope));
    assert equals_c(stmt32.node_type, "ArrayAccess"), "Expected ArrayAccess node for 2D array";
    assert equals_c(stmt32.data.array_access.array_name, "matrix"), "Expected array name 'matrix'";
    assert str_contains_c(stmt32.data.array_access.index, "i"), "Expected first index to contain 'i'";
    assert str_contains_c(stmt32.data.array_access.index2, "j"), "Expected second index to contain 'j'";

    println "\nTest 33: parse_statement_helper with increment";
    mut tokens33: list(Token) = lex(str("x++;"));
    mut ctx33: ParserContext;
    ctx33.tokens = addr(tokens33);
    ctx33.pos = 0;
    ctx33.is_axec = false;
    mut stmt33: ASTNode = parse_statement_helper(addr(ctx33), addr(ctx33.current_scope));
    assert equals_c(stmt33.node_type, "IncDec"), "Expected IncDec node";
    assert equals_c(stmt33.data.inc_dec.variable, "x"), "Expected variable name 'x'";
    assert stmt33.data.inc_dec.is_increment == true, "Expected is_increment to be true";

    println "\nTest 34: parse_statement_helper with decrement";
    mut tokens34: list(Token) = lex(str("x--;"));
    mut ctx34: ParserContext;
    ctx34.tokens = addr(tokens34);
    ctx34.pos = 0;
    ctx34.is_axec = false;
    mut stmt34: ASTNode = parse_statement_helper(addr(ctx34), addr(ctx34.current_scope));
    assert equals_c(stmt34.node_type, "IncDec"), "Expected IncDec node";
    assert equals_c(stmt34.data.inc_dec.variable, "x"), "Expected variable name 'x'";
    assert stmt34.data.inc_dec.is_increment == false, "Expected is_increment to be false";

    println "\nTest 35: parse_statement_helper with member increment";
    mut tokens35: list(Token) = lex(str("obj.count++;"));
    mut ctx35: ParserContext;
    ctx35.tokens = addr(tokens35);
    ctx35.pos = 0;
    ctx35.is_axec = false;
    mut stmt35: ASTNode = parse_statement_helper(addr(ctx35), addr(ctx35.current_scope));
    assert equals_c(stmt35.node_type, "MemberIncDec"), "Expected MemberIncDec node";
    assert equals_c(stmt35.data.member_inc_dec.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt35.data.member_inc_dec.member_name, "count"), "Expected member name 'count'";
    assert stmt35.data.member_inc_dec.is_increment == true, "Expected is_increment to be true";

    println "\nTest 36: parse_statement_helper with member decrement";
    mut tokens36: list(Token) = lex(str("obj.count--;"));
    mut ctx36: ParserContext;
    ctx36.tokens = addr(tokens36);
    ctx36.pos = 0;
    ctx36.is_axec = false;
    mut stmt36: ASTNode = parse_statement_helper(addr(ctx36), addr(ctx36.current_scope));
    assert equals_c(stmt36.node_type, "MemberIncDec"), "Expected MemberIncDec node";
    assert equals_c(stmt36.data.member_inc_dec.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt36.data.member_inc_dec.member_name, "count"), "Expected member name 'count'";
    assert stmt36.data.member_inc_dec.is_increment == false, "Expected is_increment to be false";

    println "\nTest 37: A complete program parse";
    mut tokens37: list(Token) = lex(str(`use std.io;
        
        model Point {
            x: i32;
            y: i32;
        }
        
        enum Color {
            Red,
            Green,
            Blue
        }
        
        pub def main() {
            val p: Point = Point { x: 10, y: 20 };
            println p.x;
        }
    `));
    
    mut ctx37: ParserContext;

    ctx37.tokens = addr(tokens37);
    ctx37.pos = 0;
    ctx37.is_axec = false;

    mut stmt37: ASTNode = parse_statement_helper(addr(ctx37), addr(ctx37.current_scope));
    
    assert equals_c(stmt37.node_type, "Use"), "Expected Use node as first statement in program";
    assert equals_c(stmt37.data.use_node.module_name, "std.io"), "Expected module name 'std.io'";
}

// =============================================================================
// TDL: Missing features from parser.d that need to be ported to parser.axe
// =============================================================================
//
// HIGH PRIORITY (Core Language Features):
// ---------------------------------------
// 3. STRING INTERPOLATION
//    - Support string interpolation detection and std.string requirement checking
//
// MEDIUM PRIORITY (Statement Enhancements):
// -----------------------------------------
// 4. Enhanced EXTERN parameter parsing + OPAQUE
//    - parser.d lines 1366-1459: Full parameter and return type parsing
//    - parser.axe lines 1863-1899: Simplified version that skips to semicolon
//    - parser.d stores full parameter list and return type in ExternNode
//    - parser.axe only captures function name
//
// LOW PRIORITY (Code Quality):
// ----------------------------
// 6. Better error messages with line/column info
//    - parser.d uses enforce() with detailed contextual messages
//    - parser.axe uses enforce_raw() with simple string messages
//    - Could add line/column from current token to errors
//
// 7. String interpolation validation
//    - parser.d checks for INTERPOLATED_STR token type
//    - Validates std.string is imported before allowing interpolation
//    - Checks for presence of {} or ${} in interpolated strings
//
// QUESTIONABLE/DEFERRED:
// ---------------------
// 8. Macro system completeness
//    - Both implementations have TokenType.MACRO handling
//    - parser.d has macro invocation in IDENTIFIER case (lines 1563+)
//    - Need to verify if parser.axe macro system is complete
//
// COMPLETED:
// ---------
//  MAIN function parsing (def main() { ... })
//  OVERLOAD function parsing (type => function mappings)
//  SCOPE block parsing 
//  MODULE field type module path parsing (std.maps.StringIntMap, lexer.Token)
//  OPAQUE node type_names heap allocation fix
//  USE statement module path parsing (DOT and SLASH separators)
//  MODEL parsing with field types
//  ENUM parsing
//  DEF parsing
//  TEST parsing
//  PLATFORM block parsing
//  PARALLEL block parsing
//  SINGLE block parsing
//  RAW block parsing
//  Statement helper: BREAK, CONTINUE, ASSERT, RETURN, LOOP, FOR, IF, SWITCH
//  Variable declarations: MUT, VAL
//  Expression parsing with operators
//  Function calls with arguments
//  Increment/decrement operators (++/--)
//  Member access and member increment/decrement
//
// =============================================================================
// IMPLEMENTATION NOTES:
// =============================================================================
//
// For MAIN token:
// - Check if TokenType.MAIN exists in lexer.axe
// - Add case in parse_top_level after DEF handling
// - Create FunctionNode with name "main" and parse body until RBRACE
//
// For Enhanced EXTERN:
// - Parse parameter list properly: (name: type, name: type)
// - Parse optional return type after COLON
// - Store in ExternNode: function_name, params[], return_type
// - May require changes to structs.axe extern_node definition
//
// =============================================================================
