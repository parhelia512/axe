// Author: Navid Momtahen (C) 2025
// License: GPL-3.0
// 
// Handles build process orchestration.

use structs (
    ASTNode
);
use lexer (
    lex,
    Token
);
use parser (
    parse,
    initialize_all
);
use imports (
    reset_processed_modules,
    process_imports
);

use gstate;
use renderer;
use std.io;
use std.os;
use std.lists (StringList);

/// Detect if a name already has a module-style "__" prefix.
def has_double_underscore(name: string): bool {
    val nlen: i32 = str_len(name);
    mut k: i32 = 0;
    loop {
        if k + 1 >= nlen {
            break;
        }
        val c1: char = get_char(name, k);
        val c2: char = get_char(name, k + 1);
        if c1 == '_' and c2 == '_' {
            return true;
        }
        k++;
    }
    return false;
}

/// Prefix only root enums (those without an existing module-style prefix)
/// so that their C enums and members become unique symbols like:
///   - tests__enums__State
///   - tests__enums__State_RUNNING
def prefix_root_enums(node: ref ASTNode, mprefix: string) {
    if node == nil {
        return;
    }

    val nt: string = node.node_type;
    if equals_c(nt, "Enum") {
        val ename: string = node.data.enum_node.name;
        if str_len(mprefix) > 0 and !has_double_underscore(ename) {
            mut new_name: string = mprefix;
            new_name = concat_c(new_name, "__");
            new_name = concat(new_name, ename);
            node.data.enum_node.name = new_name;
        }
    }

    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut ci: i32 = 0;
        loop {
            if ci >= len(deref(chs)) {
                break;
            }
            prefix_root_enums(addr(chs.data[ci]), mprefix);
            ci = ci + 1;
        }
    }
}

/// Print AST node with indentation for debugging
def print_ast_node(node: ref ASTNode, indent: i32) {
    if node == nil {
        return;
    }
    
    mut ii: i32 = 0;
    loop {
        if ii >= indent {
            break;
        }
        print "  ";
        ii = ii + 1;
    }
    
    println node.node_type;
    
    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut ci: i32 = 0;
        loop {
            if ci >= len(deref(chs)) {
                break;
            }
            print_ast_node(addr(chs.data[ci]), indent + 1);
            ci++;
        }
    }
}

/// Compile an Axe source file to an executable
def compile_file(filename: string, is_axec: bool, output_filename: string): bool {
    println(concat(str("Compiling: "), filename));
    println "\n1 | IO";

    val source: string = read_file(filename);
    if str_len(source) == 0 {
        println "Error: Could not read source file";
        return false;
    }
    
    println "2 | Lex";
    val tokens: list(Token) = lex(source);
    if len(tokens) == 0 {
        println "Error: No tokens generated";
        return false;
    }
    
    val do_print_tokens: bool = ::print_tokens;

    if do_print_tokens {
        mut ti: i32 = 0;
        loop {
            if ti >= len(tokens) {
                break;
            }
            val cur_tok: ref Token = addr(tokens.data[ti]);
            val tok_type_str: string = i32_to_string(cur_tok.token_type);
            val tok_val: string = cur_tok.value;
            print(concat(str("["), tok_type_str));
            print "] ";
            println tok_val;
            ti++;
        }
    }
    
    println "3 | Parse";
    initialize_all();
    mut ast: ASTNode = parse(addr(tokens), is_axec, true, str(""));
    if len(ast.children) == 0 {
        println "Error: Failed to parse";
        return false;
    }
    
    println "4 | Imports";
    reset_processed_modules();

    mut base_dir: string = str(".");
    val lenf: i32 = str_len(filename);
    mut idx: i32 = lenf - 1;

    loop {
        if idx < 0 {
            break;
        }
        val ch: char = get_char(filename, idx);
        if ch == '/' or ch == '\\' {
            base_dir = substring_se(filename, 0, idx);
            break;
        }
        idx = idx - 1;
    }

    val module_name: string = str("");
    ast = process_imports(addr(ast), base_dir, is_axec, filename, true, module_name);
    
    val do_print_ast: bool = ::print_ast;
    if do_print_ast {
        print_ast_node(addr(ast), 0);
    }

    println "5 | Lowering";

    mut dir_name: string = str("");
    mut file_stem: string = str("");
    val flen: i32 = str_len(filename);
    mut last_dot: i32 = -1;
    mut i_ext: i32 = flen - 1;

    println "6 | PFCCG I";

    loop {
        if i_ext < 0 {
            break;
        }
        val ch_ext: char = get_char(filename, i_ext);
        if ch_ext == '.' {
            last_dot = i_ext;
            break;
        }
        i_ext = i_ext - 1;
    }
    if last_dot < 0 {
        last_dot = flen;
    }

    println "7 | PFCCG II";

    mut last_sep: i32 = -1;
    mut i_sep: i32 = flen - 1;
    loop {
        if i_sep < 0 {
            break;
        }
        val ch_sep: char = get_char(filename, i_sep);
        if ch_sep == '/' or ch_sep == '\\' {
            last_sep = i_sep;
            break;
        }
        i_sep = i_sep - 1;
    }

    if last_sep >= 0 {
        file_stem = substring_se(filename, last_sep + 1, last_dot);
    } else {
        file_stem = substring_se(filename, 0, last_dot);
    }

    println "8 | PFCCG III";
    if last_sep > 0 {
        mut dir_sep2: i32 = -1;
        mut j: i32 = last_sep - 1;
        loop {
            if j < 0 {
                break;
            }
            val ch2: char = get_char(filename, j);
            if ch2 == '/' or ch2 == '\\' {
                dir_sep2 = j;
                break;
            }
            j--;
        }
        if dir_sep2 >= 0 {
            dir_name = substring_se(filename, dir_sep2 + 1, last_sep);
        } else {
            dir_name = substring_se(filename, 0, last_sep);
        }
    }
    println "9 | PFCCG IV";

    mut module_prefix: string = str("");
    if str_len(dir_name) > 0 {
        module_prefix = dir_name;
        module_prefix = concat(module_prefix, str("__"));
        module_prefix = concat(module_prefix, file_stem);
    } else {
        module_prefix = file_stem;
    }

    println "10| PFCCG V";

    prefix_root_enums(addr(ast), module_prefix);
      
    initialize_renderer();

    println "11| GEN";

    val c_code: string = generate_c(addr(ast));

    if str_len(c_code) == 0 {
        println "Error: Failed to generate C code";
        return false;
    }

    val c_filename: string = replace_extension(filename, str(".c"));
    write_file(c_filename, c_code);
    // println(concat(str("\nGenerated: "), c_filename));
    
    println "12| Last compilation pass";

    val exe_filename: string = get_output_filename(output_filename, filename);
    val needs_omp: bool = should_link_openmp(addr(ast), filename);
    mut compile_cmd: string = str("clang ");
    
    compile_cmd = concat(compile_cmd, c_filename);
    if needs_omp {
        compile_cmd = concat(compile_cmd, str(" -fopenmp"));
    }
    
    val inc_paths: ref StringList = get_include_paths();
    if inc_paths != nil {
        mut ip_idx: i32 = 0;
        loop {
            if ip_idx >= len(deref(inc_paths)) {
                break;
            }
            compile_cmd = concat_c(compile_cmd, " -I");
            compile_cmd = concat(compile_cmd, inc_paths.data[ip_idx]);
            ip_idx++;
        }
    }
    
    if !::is_release_build {
        platform windows {
            compile_cmd = concat_c(compile_cmd, " -gcodeview -fuse-ld=lld -Xlinker /debug -ldbghelp");
        }
        platform posix {
            compile_cmd = concat_c(compile_cmd, " -g");
        }
    }
    
    compile_cmd = concat(compile_cmd, str(" -Wno-everything -O0 -o "));
    compile_cmd = concat(compile_cmd, exe_filename);
    
    val exit_code: i32 = exec(compile_cmd.data);
    

    if exit_code != 0 {
        println "Error: Compilation failed";
        return false;
    }

    val keep_file: bool = ::keep_emitted_file;

    if keep_file {
        println "Keeping emitted C file (-e flag)";
    } else {
        println "Deleting emitted C file";
        delete_file(c_filename);
    }
    
    println "Compiled.";
    
    val do_run: bool = ::run_after_compile;
    if do_run {
        println(concat(str("Running: "), exe_filename));
        val run_code: i32 = exec(exe_filename.data);
        println(concat(str("Exit code: "), i32_to_string(run_code)));
    }
    
    return true;
}

/// Replace file extension
def replace_extension(filename: string, new_ext: string): string {
    val len: i32 = str_len(filename);
    mut i: i32 = len - 1;
    
    loop {
        if i < 0 {
            break;
        }
        
        val ch: char = get_char(filename, i);
        if ch == '.' {
            val base: string = substring_se(filename, 0, i);
            return concat(base, new_ext);
        }
        
        i--;
    }
    
    return concat(filename, new_ext);
}

/// Get the output filename with platform-appropriate suffix
def get_output_filename(specified_output: string, input_filename: string): string {
    mut result: string = str("");
    
    if str_len(specified_output) > 0 {
        result = specified_output;
    } else {
        result = replace_extension(input_filename, str(".exe"));
    }
    
    platform windows {
        if !has_suffix(result, str(".exe")) {
            result = concat(result, str(".exe"));
        }
    }
    
    return result;
}

/// Return true if we should link against OpenMP.
///
/// Conditions:
///   - The AST contains parallel constructs (blocks/loops), or
///   - The root module imports std.parallelism, or
///   - We are compiling the parallelism.axec module itself.
def should_link_openmp(ast: ref ASTNode, filename: string): bool {
    if has_suffix(filename, str("parallelism.axec")) {
        return true;
    }

    if has_parallel_blocks(ast) {
        return true;
    }

    if ast == nil {
        return false;
    }

    val node_type: string = ast.node_type;
    if equals_c(node_type, "Use") {
        val mod_name: string = ast.data.use_node.module_name;
        if equals_c(mod_name, "std.parallelism") {
            return true;
        }
    }

    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            if should_link_openmp(addr(children.data[i]), filename) {
                return true;
            }
            i++;
        }
    }

    return false;
}

/// Check if AST contains parallel blocks
def has_parallel_blocks(ast: ref ASTNode): bool {
    if ast == nil {
        return false;
    }
    
    val node_type: string = ast.node_type;
    
    if equals_c(node_type, "ParallelFor") {
        return true;
    }
    
    if equals_c(node_type, "Parallel") {
        return true;
    }
    
    if equals_c(node_type, "ParallelLocal") {
        return true;
    }
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            
            if has_parallel_blocks(addr(children.data[i])) {
                return true;
            }
            
            i++;
        }
    }
    
    return false;
}

/// Collect model names from AST
def collect_model_names(ast: ref ASTNode) {
    if ast == nil {
        return;
    }
    
    val node_type: string = ast.node_type;
    
    // if equals_c(node_type, "Model") {
    //     val model_name: string = ast.data.model_node.name;
    //     println concat(str("Found model: "), model_name);
    // }
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            
            collect_model_names(addr(children.data[i]));
            i++;
        }
    }
}

/// Collect declared functions from AST
def collect_declared_functions(ast: ref ASTNode) {
    if ast == nil {
        return;
    }
    
    val node_type: string = ast.node_type;
    
    // if equals_c(node_type, "Function") {
    //     // TODO: Store function name in global map
    //     val func_name: string = ast.data.function.name;
    //     println concat(str("Found function: "), func_name);
    // }
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            
            collect_declared_functions(addr(children.data[i]));
            i++;
        }
    }
}

test {
    println "\nTest 1: Replace extension";
    
    assert equals_c(replace_extension(str("test.axe"), str(".c")), "test.c"), "Expected test.c";
    assert equals_c(replace_extension(str("file.txt"), str(".exe")), "file.exe"), "Expected file.exe";
    assert equals_c(replace_extension(str("noext"), str(".c")), "noext.c"), "Expected noext.c";
    
    println "\nTest 2: Has parallel blocks (negative)";
    mut simple_ast: ASTNode;
    simple_ast.node_type = str("Program");
    simple_ast.children = nil;

    assert !has_parallel_blocks(addr(simple_ast)), "Expected no parallel blocks";
    
    println "\nTest 3: Collect model names";
    mut model_ast: ASTNode;
    model_ast.node_type = str("Model");
    model_ast.data.model_node.name = str("TestModel");
    model_ast.children = nil;

    collect_model_names(addr(model_ast));
}
