/// String model representing a dynamic string with length tracking.
model String {
    data: char*;
    len: usize;
    cap: usize;

    /// Creates a new string from a char pointer.
    def create(data: char*): String {
        mut val result: String;
        raw {
            String* ptr = (String*)malloc(sizeof(String));
            if (ptr != NULL) {
                ptr->data = (char*)data;
                ptr->len = (uintptr_t)strlen((const char*)data);
                ptr->cap = ptr->len;
                result = *ptr;
            }
        }
        return result;
    }
}

/// Returns the length of a string.
def str_len(s: String): usize {
    return s.len;
}

/// Copies source string to destination. Modifies dest in place.
def str_copy(src: String, desta: mut String): void {
    for mut val i = 0; i < src.len; i++ {
        desta.data[i] = src.data[i];
    }
}

/// Compares two strings. Returns 0 if equal.
def str_cmp(a: String, b: String): i32 {
    mut val len: usize = 0;
    if a.len < b.len {
        len = a.len;
    } else {
        len = b.len;
    }
    for mut val i = 0; i < len; i++ {
        if a.data[i] < b.data[i] { return -1; }
        if a.data[i] > b.data[i] { return 1; }
    }
    if a.len < b.len { return -1; }
    if a.len > b.len { return 1; }
    return 0;
}

/// Concatenates source string to destination. Modifies dest in place.
def concat(dest: String, src: String): void {
    raw {
        strcat((char*)dest.data, (const char*)src.data);
    }
}

/// Finds first occurrence of character in string. Returns pointer or 0.
def first_occurrence(s: String, c: i32): char* {
    mut val result: char* = 0;
    raw {
        result = strchr((const char*)s.data, c);
    }
    return result;
}

/// Finds first occurrence of substring in string. Returns pointer or 0.
def substring(haystack: String, needle: String): char* {
    mut val result: char* = 0;
    raw {
        result = strstr((const char*)haystack.data, (const char*)needle.data);
    }
    return result;
}

/// Converts string to integer.
def str_to_int(s: String): i32 {
    mut val result: i32 = 0;
    raw {
        result = atoi((const char*)s.data);
    }
    return result;
}

/// Converts string to long integer.
def str_to_long(s: char*): i64 {
    mut val result: i64 = 0;
    raw {
        result = atol((const char*)s);
    }
    return result;
}

/// Checks if character is alphabetic.
def is_alpha(c: i32): i32 {
    mut val result: i32 = 0;
    raw {
        result = isalpha(c);
    }
    return result;
}

/// Checks if character is numeric.
def is_digit(c: i32): i32 {
    mut val result: i32 = 0;
    raw {
        result = isdigit(c);
    }
    return result;
}

/// Checks if character is alphanumeric.
def is_alnum(c: i32): i32 {
    mut val result: i32 = 0;
    raw {
        result = isalnum(c);
    }
    return result;
}

/// Converts character to uppercase.
def to_upper(c: i32): i32 {
    mut val result: i32 = 0;
    raw {
        result = toupper(c);
    }
    return result;
}

/// Converts character to lowercase.
def to_lower(c: i32): i32 {
    mut val result: i32 = 0;
    raw {
        result = tolower(c);
    }
    return result;
}

/// Allocates and copies a string. Caller must free the result.
def str_dup(s: char*): char* {
    mut val result: char* = 0;
    raw {
        int len = (int)strlen((const char*)s);
        result = (char*)malloc(len + 1);
        if (result != 0) {
            strcpy((char*)result, (const char*)s);
        }
    }
    return result;
}

/// Compares first n characters of two strings. Returns 0 if equal.
def str_ncmp(s1: char*, s2: char*, n: i32): i32 {
    mut val result: i32 = 0;
    raw {
        result = strncmp((const char*)s1, (const char*)s2, n);
    }
    return result;
}

/// Copies at most n characters from source to destination.
def str_ncopy(dest: char*, src: char*, n: i32): char* {
    mut val result: char* = 0;
    raw {
        result = strncpy((char*)dest, (const char*)src, n);
    }
    return result;
}

/// Converts an integer to a string. Buffer must be at least 12 bytes.
def int_to_str(value: i32, buffer: char*): char* {
    raw {
        sprintf(buffer, "%d", value);
    }
    return buffer;
}

/// Converts a long to a string. Buffer must be at least 21 bytes.
def long_to_str(value: i64, buffer: char*): char* {
    raw {
        sprintf(buffer, "%ld", value);
    }
    return buffer;
}

/// Converts a float to a string. Buffer must be at least 32 bytes.
def float_to_str(value: f32, buffer: char*): char* {
    raw {
        sprintf(buffer, "%f", value);
    }
    return buffer;
}

/// Converts a double to a string. Buffer must be at least 32 bytes.
def double_to_str(value: f64, buffer: char*): char* {
    raw {
        sprintf(buffer, "%lf", value);
    }
    return buffer;
}

test {    
    assert(is_alpha(65) != 0, "65 (A) should be alphabetic");
    assert(is_digit(48) != 0, "48 (0) should be a digit");
    assert(is_alnum(97) != 0, "97 (a) should be alphanumeric");
    assert(to_upper(97) == 65, "to_upper(a) should return A");
    assert(to_lower(65) == 97, "to_lower(A) should return a");
    assert(str_ncmp("hello", "help", 3) == 0, "first 3 chars of hello and help should match");
    
    mut val buffer: char[64];
    
    int_to_str(42, buffer);
    assert(str_ncmp(buffer, "42", 2) == 0, "int_to_str(42) should produce 42");
    
    int_to_str(-123, buffer);
    assert(str_ncmp(buffer, "-123", 4) == 0, "int_to_str(-123) should produce -123");
    
    int_to_str(0, buffer);
    assert(str_ncmp(buffer, "0", 1) == 0, "int_to_str(0) should produce 0");
    
    long_to_str(1000, buffer);
    assert(str_ncmp(buffer, "1000", 4) == 0, "long_to_str(1000) should produce 1000");
    
    long_to_str(-9999, buffer);
    assert(str_ncmp(buffer, "-9999", 5) == 0, "long_to_str(-9999) should produce -9999");
}
