use stdlib/arena (
    arena_create,
    arena_destroy,
    arena_alloc,
    arena_alloc_array,
    arena_reset,
    arena_get_used,
    arena_get_remaining,
);

model Point {
    x: int;
    y: int;
}

def process_points() {
    // Create an arena with 1MB of memory
    mut val arena = arena_create(1048576);
    
    println "Arena created";
    print "Available memory: ";
    println arena_get_remaining(ref_of(arena));
    
    // Allocate an array of 100 Points
    val points_ptr: long = arena_alloc_array(ref_of(arena), 8, 100);  // sizeof(Point) = 8
    
    print "Allocated 100 points, remaining: ";
    println arena_get_remaining(ref_of(arena));
    
    // Allocate a buffer for processing
    val buffer_ptr: long = arena_alloc(ref_of(arena), 4096);
    
    print "Allocated 4KB buffer, remaining: ";
    println arena_get_remaining(ref_of(arena));
    
    // Do some work with the allocations...
    println "Processing data...";
    
    // Clean up everything at once
    arena_destroy(ref_of(arena));
    println "Arena destroyed - all memory freed!";
}

def temporary_computation(): int {
    // Create a temporary arena for this computation
    mut val temp_arena = arena_create(65536);  // 64KB
    
    // Allocate temporary working memory
    val workspace: long = arena_alloc(ref_of(temp_arena), 10000);
    
    // Do computation...
    mut val result: int = 42;
    
    // Clean up
    arena_destroy(ref_of(temp_arena));
    
    return result;
}

main {
    println "=== Arena Allocator Example ===";
    println "";
    
    process_points();
    
    println "";
    
    val result: int = temporary_computation();
    print "Computation result: ";
    println result;
    
    println "";
    println "No memory leaks - everything cleaned up automatically!";
}
