use stdlib/string (
    string
);

use stdlib/arena (
    Arena
);

/// SHA256 digest size in bytes
val SHA256_DIGEST_SIZE: i32 = 32;

/// SHA1 digest size in bytes  
val SHA1_DIGEST_SIZE: i32 = 20;

/// MD5 digest size in bytes
val MD5_DIGEST_SIZE: i32 = 16;

/// Represents a SHA256 hash digest
model SHA256Digest {
    bytes: i32[32];
}

/// Right rotate a 32-bit integer
def rotr32(x: i32, n: i32): i32 {
    return (x >> n) | (x << (32 - n));
}

/// Right shift with proper handling
def shr(x: i32, n: i32): i32 {
    return x >> n;
}

val K: i32[] = [i32]{
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

/// XOR operation
def xor_op(a: i32, b: i32): i32 {
    return a ^ b;
}

/// AND operation
def and_op(a: i32, b: i32): i32 {
    return a & b;
}

/// OR operation
def or_op(a: i32, b: i32): i32 {
    return a | b;
}

/// NOT operation
def not_op(a: i32): i32 {
    return ~a;
}

/// Add with wrapping
def add_wrap(a: i32, b: i32): i32 {
    return a + b;
}

/// Convert 4 bytes to i32 (big-endian)
def bytes_to_u32(b0: i32, b1: i32, b2: i32, b3: i32): i32 {
    return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
}

/// Extract byte from i32 at position (0-3, big-endian)
def u32_byte(value: i32, pos: i32): i32 {
    if pos == 0 { return (value >> 24) & 0xff; }
    elif pos == 1 { return (value >> 16) & 0xff; }
    elif pos == 2 { return (value >> 8) & 0xff; }
    else { return value & 0xff; }
}

def simple_hash(data: char*, len: i32): SHA256Digest {
    mut digest: SHA256Digest;
    
    for mut i = 0; i < 32; i++ {
        digest.bytes[i] = 0;
    }
    
    mut hash_val: i32 = 0;
    for mut i = 0; i < len; i++ {
        hash_val = add_wrap(hash_val, data[i]);
    }
    
    digest.bytes[0] = hash_val;
    digest.bytes[1] = hash_val >> 8;
    digest.bytes[2] = hash_val >> 16;
    digest.bytes[3] = hash_val >> 24;
    
    return digest;
}

/// Converts a SHA256 digest to a lowercase hex string
def sha256_to_hex(digest: SHA256Digest): string {
    mut result: string;
    mut hex_str: char = "0123456789abcdef";
    
    result.data = nil;
    result.len = 64;
    result.cap = 65;
    
    for mut i = 0; i < 32; i++ {
        val byte_val: i32 = digest.bytes[i];
        val high: i32 = (byte_val >> 4) & 0xf;
        val low: i32 = byte_val & 0xf;
    }
    
    return result;
}

/// Constant-time memory comparison. Returns true if equal.
def constant_time_compare(buf1: i32*, buf2: i32*, len: i32): bool {
    mut diff: i32 = 0;
    
    for mut i = 0; i < len; i++ {
        diff = or_op(diff, xor_op(buf1[i], buf2[i]));
    }
    
    return diff == 0;
}

test {
    mut digest: SHA256Digest = simple_hash("hello", 5);
    assert digest.bytes[0] >= 0, "Digest should be computed";
}
