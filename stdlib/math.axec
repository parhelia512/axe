val PI: float           = 3.141592653589793;
val HALF_PI: float      = PI / 2.0;
val QUARTER_PI: float   = PI / 4.0;
val TWO_PI: float       = PI * 2.0;
val E: float            = 2.718281828459045;

/// Clamp integer
def clamp(value: int, min: int, max: int): int {
    if value < min { return min; }
    elif value > max { return max; }
    else { return value; }
}

/// Clamp float
def clamp_float(value: float, min: float, max: float): float {
    if value < min { return min; }
    elif value > max { return max; }
    else { return value; }
}

/// Absolute value
def absolute(value: float): float {
    if value < 0.0 { return -value; } else { return value; }
}

/// Approximately equal
def approx_equal(a: float, b: float, eps: float): bool {
    return absolute(a - b) <= eps;
}

/// Minimum
def minimum(a: float, b: float): float { if a < b { return a; } else { return b; } }

/// Maximum
def maximum(a: float, b: float): float { if a > b { return a; } else { return b; } }

/// Converts an integer to a float.
def int_to_float(x: int): float {
    return x + 0.0;
}

/// Floor of the number.
def floor(x: float): float {
    val xi: int = x;
    if x < 0.0 and (x - xi) != 0.0 {
        return (xi - 1);
    } else {
        return xi;
    }
}

/// Ceiling of the number.
def ceil(x: float): float {
    val xi: int = x;     
    val xf: float = xi;  
    if x > 0.0 and (x - xf) != 0.0 {
        val next: int = xi + 1;
        return next;
    } else {
        return xf;
    }
}

/// Round to the nearest float
def round(x: float): float {
    if x < 0.0 {
        return ceil(x - 0.5);
    } else {
        return floor(x + 0.5);
    }
}

/// Float modulus.
def mod_float(a: float, b: float): float {
    return a - b * floor(a / b);
}

/// Reduce angle to [0, 2PI]
def reduce_angle(x: float): float {
    return mod_float(x, TWO_PI);
}

/// Square root (Newton)
def sqrt(value: float): float {
    if value <= 0.0 { return 0.0; }
    if value < 0.0000001 { return 0.00001; }

    mut val x: float = 0.0;

    if value >= 1.0 {
        x = value * 0.5;
    } else {
        x = 1.0;
    }

    for mut val i = 0; i < 50; i++ {
        mut val last: float = x;
        x = 0.5 * (x + value / x);
        if approx_equal(last, x, 0.0000000000001) { break; }
    }
    return x;
}

/// Integer exponent (exponentiation by squaring)
def pow(base: float, exp: int): float {
    mut val result: float = 1.0;
    mut val b: float = base;
    mut val e: int = exp;

    if e < 0 {
        b = 1.0 / b;
        e = -e;
    }

    loop {
        if e == 0 { break; }

        if (e - (e / 2) * 2) == 1 {
            result = result * b;
        }

        b = b * b;
        e = e / 2;
    }

    return result;
}

/// Exponential series
def exp(x: float): float {
    mut val sum: float = 1.0;
    mut val term: float = 1.0;
    for mut val n = 1; n < 20; n++ {
        term = term * x / n;
        sum = sum + term;
    }
    return sum;
}

/// Natural logarithm
def ln(x: float): float {
    if x <= 0.0 { return 0.0; }

    mut val y: float = x - 1.0;
    for mut val i = 0; i < 25; i++ {
        mut val last: float = y;
        mut val ey: float = exp(y);
        y = y - (ey - x) / ey;
        if approx_equal(last, y, 0.0000001) { break; }
    }
    return y;
}

/// Sine (reduced angle)
def sin(x: float): float {
    x = reduce_angle(x);
    mut val term: float = x;
    mut val sum: float = x;
    mut val x2: float = x * x;
    mut val n: int = 1;
    for mut val i = 1; i < 10; i++ {
        term = -term * x2 / ((2 * n) * (2 * n + 1));
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

/// Cosine
def cos(x: float): float {
    x = reduce_angle(x);
    mut val term: float = 1.0;
    mut val sum: float = 1.0;
    mut val x2: float = x * x;
    mut val n: int = 1;
    for mut val i = 1; i < 10; i++ {
        term = -term * x2 / ((2 * n - 1) * (2 * n));
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

/// Tangent
def tan(x: float): float {
    return sin(x) / cos(x);
}

/// Arcsine
def asin(x: float): float {
    x = clamp_float(x, -1.0, 1.0);
    mut val term: float = x;
    mut val sum: float = x;
    mut val n: int = 1;
    mut val x2: float = x * x;
    for mut val i = 1; i < 10; i++ {
        term = term * x2 * (2 * n - 1) / (2 * n);
        sum = sum + term / (2 * n + 1);
        n = n + 1;
    }
    return sum;
}

/// Arccosine
def acos(x: float): float {
    return HALF_PI - asin(x);
}

/// Arctangent
def atan(x: float): float {
    mut val term: float = x;
    mut val sum: float = x;
    mut val x2: float = x * x;
    mut val sign: float = -1.0;
    for mut val n = 3; n < 20; n += 2 {
        term = term * x2;
        sum = sum + sign * term / n;
        sign = -sign;
    }
    return sum;
}

test {
    assert(approx_equal(sqrt(16.0), 4.0, 0.001), "sqrt(16) should be ~4");
    assert(approx_equal(sin(PI/2.0), 1.0, 0.01), "sin(pi/2) should be ~1");
    assert(approx_equal(cos(0.0), 1.0, 0.01), "cos(0) should be ~1");
    assert(approx_equal(tan(PI/4.0), 1.0, 0.05), "tan(pi/4) should be ~1");
    assert(approx_equal(asin(1.0), PI/2.0, 0.05), "asin(1) should be ~pi/2");
    assert(approx_equal(acos(0.0), PI/2.0, 0.05), "acos(0) should be ~pi/2");
    assert(approx_equal(atan(1.0), PI/4.0, 0.05), "atan(1) should be ~pi/4");
    assert(approx_equal(exp(1.0), E, 0.05), "exp(1) should be ~E");
    assert(approx_equal(ln(E), 1.0, 0.05), "ln(E) should be ~1");
    assert(clamp(5, 0, 10) == 5, "clamp mid");
    assert(clamp(-5, 0, 10) == 0, "clamp below");
    assert(clamp(50, 0, 10) == 10, "clamp above");
    assert(clamp_float(5.5, 0.0, 10.0) == 5.5, "clamp_float mid");
    assert(clamp_float(-1.0, 0.0, 10.0) == 0.0, "clamp_float below");
    assert(clamp_float(20.0, 0.0, 10.0) == 10.0, "clamp_float above");
    assert(absolute(-5.0) == 5.0, "absolute neg");
    assert(absolute(5.0) == 5.0, "absolute pos");
    assert(floor(5.2) == 5.0, "floor positive");
    assert(floor(-1.2) == -2.0, "floor negative fractional");
    assert(floor(-1.0) == -1.0, "floor negative exact");
    assert(ceil(5.2) == 6.0, "ceil positive");
    assert(ceil(-1.2) == -1.0, "ceil negative fractional");
    assert(ceil(2.0) == 2.0, "ceil exact");
    assert(round(5.4) == 5.0, "round down");
    assert(round(5.6) == 6.0, "round up");
    assert(round(-1.4) == -1.0, "round negative down");
    assert(round(-1.6) == -2.0, "round negative up");
    assert(approx_equal(sqrt(2.0), 1.4142, 0.01), "sqrt(2)");
    assert(approx_equal(sqrt(0.25), 0.5, 0.01), "sqrt(0.25)");
    assert(approx_equal(sqrt(10000.0), 100.0, 0.01), "sqrt(10000)");
    assert(approx_equal(reduce_angle(PI), PI, 0.001), "reduce pi");
    assert(approx_equal(reduce_angle(PI + TWO_PI), PI, 0.001), "reduce angle wrap");
    assert(approx_equal(reduce_angle(-PI), TWO_PI - PI, 0.001), "reduce negative");
    assert(approx_equal(mod_float(10.5, 2.0), 0.5, 0.001), "mod float basic");
    assert(approx_equal(mod_float(-1.0, 2.0), 1.0, 0.001), "mod float negative");
    println pow(2.0, 10); //shows 0.
    assert(approx_equal(pow(2.0, 10), 1024.0, 0.001), "pow positive exp");
    assert(approx_equal(pow(2.0, -3), 0.125, 0.001), "pow negative exp");
    assert(approx_equal(pow(5.0, 0), 1.0, 0.0001), "pow zero");
    assert(approx_equal(ln(exp(2.0)), 2.0, 0.05), "ln(exp(x)) ≈ x");
    assert(approx_equal(exp(ln(2.0)), 2.0, 0.05), "exp(ln(x)) ≈ x");
    assert(approx_equal(sin(0.0), 0.0, 0.01), "sin(0)");
    assert(approx_equal(cos(PI), -1.0, 0.05), "cos(pi)");

    val s: float = sin(1.0);
    val c: float = cos(1.0);

    assert(approx_equal(s*s + c*c, 1.0, 0.05), "sin^2 + cos^2 = 1");
    assert(approx_equal(atan(0.0), 0.0, 0.01), "atan(0)");
    assert(approx_equal(asin(0.0), 0.0, 0.05), "asin(0)");
    assert(approx_equal(acos(1.0), 0.0, 0.05), "acos(1)");
}
