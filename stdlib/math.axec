val PI: float           = 3.141592653589793;
val HALF_PI: float      = PI / 2.0;
val QUARTER_PI: float   = PI / 4.0;
val TWO_PI: float       = PI * 2.0;
val E: float            = 2.718281828459045;

/// Clamp integer
def clamp(value: int, min: int, max: int): int {
    if value < min { return min; }
    elif value > max { return max; }
    else { return value; }
}

/// Clamp float
def clamp_float(value: float, min: float, max: float): float {
    if value < min { return min; }
    elif value > max { return max; }
    else { return value; }
}

/// Absolute value
def absolute(value: float): float {
    if value < 0.0 { return -value; } else { return value; }
}

/// Approximately equal
def approx_equal(a: float, b: float, eps: float): bool {
    return absolute(a - b) <= eps;
}

/// Minimum
def minimum(a: float, b: float): float { if a < b { return a; } else { return b; } }

/// Maximum
def maximum(a: float, b: float): float { if a > b { return a; } else { return b; } }

/// Converts an integer to a float.
def int_to_float(x: int): float {
    return x + 0.0;
}

/// Floor of the number.
def floor(x: float): float {
    val xi: int = x;
    if x < 0.0 and (x - xi) != 0.0 {
        return (xi - 1);
    } else {
        return xi;
    }
}

/// Ceiling of the number.
def ceil(x: float): float {
    val xi: int = x;     
    val xf: float = xi;  
    if x > 0.0 and (x - xf) != 0.0 {
        val next: int = xi + 1;
        return next;
    } else {
        return xf;
    }
}

/// Round to the nearest float
def round(x: float): float {
    if x < 0.0 {
        return ceil(x - 0.5);
    } else {
        return floor(x + 0.5);
    }
}

/// Float modulus.
def mod_float(a: float, b: float): float {
    return a - b * floor(a / b);
}

/// Reduce angle to [0, 2PI]
def reduce_angle(x: float): float {
    return mod_float(x, TWO_PI);
}

/// Square root (Newton)
def sqrt(value: float): float {
    if value <= 0.0 { return 0.0; }
    if value < 0.0000001 { return 0.00001; }

    mut val x: float = 0.0;

    if value >= 1.0 {
        x = value * 0.5;
    } else {
        x = 1.0;
    }

    for mut val i = 0; i < 50; i++ {
        mut val last: float = x;
        x = 0.5 * (x + value / x);
        if approx_equal(last, x, 0.0000000000001) { break; }
    }
    return x;
}

/// Integer exponent
def pow(base: float, exp: int): float {
    mut val result: float = 1.0;
    mut val b: float = base;
    mut val e: int = exp;

    if e < 0 {
        b = 1.0 / b;
        e = -e;
    }

    for mut val i = 0; i < e; i++ {
        if e mod 2 == 1 {
            result = result * b;
        }
        b = b * b;
        e = e / 2;
    }

    return result;
}

/// Exponential series
def exp(x: float): float {
    mut val sum: float = 1.0;
    mut val term: float = 1.0;
    for mut val n = 1; n < 20; n++ {
        term = term * x / n;
        sum = sum + term;
    }
    return sum;
}

/// Natural logarithm
def ln(x: float): float {
    if x <= 0.0 { return 0.0; }

    mut val y: float = x - 1.0;
    for mut val i = 0; i < 25; i++ {
        mut val last: float = y;
        mut val ey: float = exp(y);
        y = y - (ey - x) / ey;
        if approx_equal(last, y, 0.0000001) { break; }
    }
    return y;
}

/// Sine (reduced angle)
def sin(x: float): float {
    x = reduce_angle(x);
    mut val term: float = x;
    mut val sum: float = x;
    mut val x2: float = x * x;
    mut val n: int = 1;
    for mut val i = 1; i < 10; i++ {
        term = -term * x2 / ((2 * n) * (2 * n + 1));
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

/// Cosine
def cos(x: float): float {
    x = reduce_angle(x);
    mut val term: float = 1.0;
    mut val sum: float = 1.0;
    mut val x2: float = x * x;
    mut val n: int = 1;
    for mut val i = 1; i < 10; i++ {
        term = -term * x2 / ((2 * n - 1) * (2 * n));
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

/// Tangent
def tan(x: float): float {
    return sin(x) / cos(x);
}

/// Arcsine
def asin(x: float): float {
    x = clamp_float(x, -1.0, 1.0);
    mut val term: float = x;
    mut val sum: float = x;
    mut val n: int = 1;
    mut val x2: float = x * x;
    for mut val i = 1; i < 10; i++ {
        term = term * x2 * (2 * n - 1) / (2 * n);
        sum = sum + term / (2 * n + 1);
        n = n + 1;
    }
    return sum;
}

/// Arccosine
def acos(x: float): float {
    return HALF_PI - asin(x);
}

/// Arctangent
def atan(x: float): float {
    mut val term: float = x;
    mut val sum: float = x;
    mut val x2: float = x * x;
    mut val sign: float = -1.0;
    for mut val n = 3; n < 20; n += 2 {
        term = term * x2;
        sum = sum + sign * term / n;
        sign = -sign;
    }
    return sum;
}

test {
    assert(approx_equal(sqrt(16.0), 4.0, 0.001), "sqrt(16) should be ~4");
    assert(approx_equal(sin(PI/2.0), 1.0, 0.01), "sin(pi/2) should be ~1");
    assert(approx_equal(cos(0.0), 1.0, 0.01), "cos(0) should be ~1");
    assert(approx_equal(tan(PI/4.0), 1.0, 0.05), "tan(pi/4) should be ~1");
    assert(approx_equal(asin(1.0), PI/2.0, 0.05), "asin(1) should be ~pi/2");
    assert(approx_equal(acos(0.0), PI/2.0, 0.05), "acos(0) should be ~pi/2");
    assert(approx_equal(atan(1.0), PI/4.0, 0.05), "atan(1) should be ~pi/4");
    assert(approx_equal(exp(1.0), E, 0.05), "exp(1) should be ~E");
    assert(approx_equal(ln(E), 1.0, 0.05), "ln(E) should be ~1");
}
