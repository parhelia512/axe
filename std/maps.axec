use std.lists;
use std.arena;
use std.string;

macro create_map(keytype_elem: untyped, valtype_elem: untyped, mapname: untyped, keytype: untyped, valtype: untyped) {
    model mapname {
        keys: ref keytype;
        values: ref valtype;
        
        def create(arena: ref Arena, capacity: i32): ref mapname {
            mut map: ref mapname;
            unsafe {
                map = Arena.alloc(arena, C.sizeof(mapname));
            }
            map.keys = keytype.create(arena, capacity);
            map.values = valtype.create(arena, capacity);
            return map;
        }
        
        def clear(map: ref mapname) {
            map.keys.len = 0;
            map.values.len = 0;
        }
        
        def append(map: ref mapname, arena: ref Arena, key: keytype_elem, value: valtype_elem) {
            keytype.push(map.keys, arena, key);
            valtype.push(map.values, arena, value);
        }
        
        def add(map: ref mapname, arena: ref Arena, key: keytype_elem, value: valtype_elem) {
            keytype.push(map.keys, arena, key);
            valtype.push(map.values, arena, value);
        }
        
        def get(map: ref mapname, key: keytype_elem): valtype_elem {
            mut i: i32 = 0;
            val keys: ref keytype = map.keys;
            val values: ref valtype = map.values;
            loop {
                if i >= keys.len {
                    break;
                }
                unsafe {
                    if C.memcmp(&(keys*.data[i]), &key, C.sizeof(key)) == 0 {
                        return values*.data[i];
                    }
                }
                i = i + 1;
            }
            mut default_val: valtype_elem;
            unsafe {
                C.memset(&default_val, 0, C.sizeof(default_val));
            }
            return default_val;
        }
        
        def contains(map: ref mapname, key: keytype_elem): bool {
            mut i: i32 = 0;
            val keys: ref keytype = map.keys;
            loop {
                if i >= keys.len {
                    break;
                }
                unsafe {
                    if C.memcmp(&(keys*.data[i]), &key, C.sizeof(key)) == 0 {
                        return true;
                    }
                }
                i = i + 1;
            }
            return false;
        }
        
        def size(map: ref mapname): i32 {
            val keys: ref keytype = map.keys;
            return keys.len;
        }
        
        def pop(map: ref mapname, key: keytype_elem): valtype_elem {
            mut i: i32 = 0;
            mut keys: ref keytype = map.keys;
            mut values: ref valtype = map.values;
            mut result: valtype_elem;
            mut found: bool = false;
            loop {
                if i >= keys.len {
                    break;
                }
                unsafe {
                    if C.memcmp(&(keys*.data[i]), &key, C.sizeof(key)) == 0 {
                        found = true;
                    }
                }
                if found {
                    result = values.data[i];
                    unsafe {
                        for mut j = i; j < keys.len - 1; j++ {
                            keys*.data[j] = keys*.data[j + 1];
                            values*.data[j] = values*.data[j + 1];
                        }
                        keys*.len--;
                        values*.len--;
                    }
                    return result;
                }
                i = i + 1;
            }
            mut default_val: valtype_elem;
            unsafe {
                C.memset(&default_val, 0, C.sizeof(default_val));
            }
            return default_val;
        }
    }
}

create_map(string, string, StringStringMap, StringList, StringList);
create_map(string, i32, StringIntMap, StringList, IntList);
create_map(i32, string, IntStringMap, IntList, StringList);
create_map(i32, i32, IntIntMap, IntList, IntList);
create_map(string, f32, StringFloatMap, StringList, FloatList);
create_map(f32, string, FloatStringMap, FloatList, StringList);
create_map(i32, f32, IntFloatMap, IntList, FloatList);
create_map(f32, i32, FloatIntMap, FloatList, IntList);
create_map(string, bool, StringBoolMap, StringList, BoolList);
create_map(bool, string, BoolStringMap, BoolList, StringList);
create_map(i32, bool, IntBoolMap, IntList, BoolList);
create_map(bool, i32, BoolIntMap, BoolList, IntList);
create_map(f32, bool, FloatBoolMap, FloatList, BoolList);
create_map(bool, f32, BoolFloatMap, BoolList, FloatList);

test {
    mut arena: Arena = Arena.create(1024);
    
    val int_map: ref IntIntMap = IntIntMap.create(ref_of(arena), 10);
    
    IntIntMap.add(int_map, ref_of(arena), 1, 100);
    IntIntMap.add(int_map, ref_of(arena), 2, 200);
    IntIntMap.add(int_map, ref_of(arena), 3, 300);
    
    assert(IntIntMap.get(int_map, 1) == 100, "IntIntMap should return 100 for key 1");
    assert(IntIntMap.get(int_map, 2) == 200, "IntIntMap should return 200 for key 2");
    assert(IntIntMap.get(int_map, 3) == 300, "IntIntMap should return 300 for key 3");
    assert(IntIntMap.contains(int_map, 1), "IntIntMap should contain key 1");
    assert(IntIntMap.contains(int_map, 2), "IntIntMap should contain key 2");
    assert(!IntIntMap.contains(int_map, 999), "IntIntMap should not contain key 999");
    assert(IntIntMap.size(int_map) == 3, "IntIntMap size should be 3");
    
    val str_int_map: ref StringIntMap = StringIntMap.create(ref_of(arena), 10);
    
    StringIntMap.add(str_int_map, ref_of(arena), str("foo"), 42);
    StringIntMap.add(str_int_map, ref_of(arena), str("bar"), 99);
    StringIntMap.add(str_int_map, ref_of(arena), str("baz"), 77);
    
    assert(StringIntMap.get(str_int_map, str("foo")) == 42, "StringIntMap should return 42 for key 'foo'");
    assert(StringIntMap.get(str_int_map, str("bar")) == 99, "StringIntMap should return 99 for key 'bar'");
    assert(StringIntMap.get(str_int_map, str("baz")) == 77, "StringIntMap should return 77 for key 'baz'");
    assert(StringIntMap.contains(str_int_map, str("foo")), "StringIntMap should contain key 'foo'");
    assert(!StringIntMap.contains(str_int_map, str("missing")), "StringIntMap should not contain key 'missing'");
    assert(StringIntMap.size(str_int_map) == 3, "StringIntMap size should be 3");
    
    val float_map: ref FloatIntMap = FloatIntMap.create(ref_of(arena), 10);
    
    FloatIntMap.add(float_map, ref_of(arena), 3.14, 314);
    FloatIntMap.add(float_map, ref_of(arena), 2.71, 271);
    
    assert(FloatIntMap.get(float_map, 3.14) == 314, "FloatIntMap should return 314 for key 3.14");
    assert(FloatIntMap.get(float_map, 2.71) == 271, "FloatIntMap should return 271 for key 2.71");
    assert(FloatIntMap.contains(float_map, 3.14), "FloatIntMap should contain key 3.14");
    assert(!FloatIntMap.contains(float_map, 1.23), "FloatIntMap should not contain key 1.23");
    assert(FloatIntMap.size(float_map) == 2, "FloatIntMap size should be 2");
}
