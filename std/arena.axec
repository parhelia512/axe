use std.io (
    println,
    print
);
use std.errors (
    error,
    panic
);

/// Arena for memory allocation.
model Arena {
    buffer: usize;
    capacity: i32;
    offset: i32;

    /// Creates a new arena with the specified size.
    def create(size: i32): Arena {
        mut arena: Arena;
        
        raw {
            arena.buffer = (uintptr_t)malloc(size);
            arena.capacity = size;
            arena.offset = 0;
        }
        
        return arena;
    }

    /// Destroys the arena and frees its memory.
    def destroy(arena: ref Arena) {
        raw {
            free((void*)arena->buffer);
            arena->buffer = 0;
            arena->offset = 0;
            arena->capacity = 0;
        }
    }

    /// Allocates memory from the arena, returns a proper reference pointer.
    def alloc(arena: ref Arena, size: i32): ref void {
        mut result: ref void = nil;

        raw {
            if (arena->offset + size > arena->capacity) {
                std_errors_panic(std_errors_error_create("Arena out of memory!\n"));
                return nil;
            }
            result = (void *)(arena->buffer + arena->offset);
            arena->offset += size;
            arena->offset = (arena->offset + 7) & ~7;
        }

        return result;
    }

    /// Allocates memory for an array from the arena.
    def alloc_array(arena: ref Arena, element_size: i32, count: i32): ref void {
        mut total_size: i32 = element_size * count;
        return Arena.alloc(arena, total_size);
    }

    /// Resets the arena, clearing all allocated memory.
    def reset(arena: ref Arena) {
        raw {
            arena->offset = 0;
            memset((void*)arena->buffer, 0, arena->capacity);
        }
    }

    /// Returns the amount of memory used by the arena.
    def used(arena: ref Arena): i32 {
        mut result: i32 = 0;
        raw {
            result = arena->offset;
        }
        return result;
    }

    /// Returns the amount of remaining memory in the arena.
    def remaining(arena: ref Arena): i32 {
        mut result: i32 = 0;
        raw {
            result = arena->capacity - arena->offset;
        }
        return result;
    }
}

test {
    assert(Arena.create(1024).capacity == 1024, "Arena.create should set capacity correctly");
    assert(Arena.create(2048).offset == 0, "new arena should have offset 0");
}
