use std/lists (
    StringList
);

use std/typecons (
    Any,
    AnyKind
);

/// string model representing a dynamic string with length tracking.
model string {
    data: char*;
    len: usize;
    cap: usize;

    /// Creates a new string from a char pointer.
    def create(data: char*): string {
        mut result: string;
        raw {
            result.data = NULL;
            result.len  = 0;
            result.cap  = 0;
            size_t len = strlen((const char*)data);
            result.data = (char*)malloc(len + 1);

            if (result.data != NULL) {
                memcpy(result.data, data, len + 1);
                result.len = len;
                result.cap = len + 1;
            }
        }
        return result;
    }

    /// Creates a new empty string with specified capacity.
    /// Note: arena parameter is currently ignored, uses malloc instead
    def create_with_capacity(arena: char*, capacity: i32): string {
        mut result: string;
        raw {
            result.data = NULL;
            result.len  = 0;
            result.cap  = 0;
            
            if (capacity > 0) {
                result.data = (char*)malloc(capacity + 1);
                if (result.data != NULL) {
                    result.data[0] = '\0';
                    result.len = 0;
                    result.cap = capacity + 1;
                }
            }
        }
        return result;
    }
}

/// Returns the length of a string.
def str_len(s: string): usize {
    return s.len;
}

/// Convert some string to titlecase.
def to_title_case(s: string): string {
    mut result: string;
    raw {
        result.data = NULL;
        result.len  = 0;
        result.cap  = 0;

        uintptr_t len = (uintptr_t)s.len;
        result.data = (char*)malloc(len + 1);

        if (result.data != NULL) {
            for (uintptr_t i = 0; i < len; i++) {
                if (i == 0 || isalpha((int)s.data[i - 1]) == 0) {
                    result.data[i] = (char)toupper((int)s.data[i]);
                } else {
                    result.data[i] = (char)tolower((int)s.data[i]);
                }
            }
            result.data[len] = '\0';
            result.len = len;
            result.cap = len;
        }
    }
    return result;
}

/// Converts string to uppercase.
def to_upper(s: string): string {
    mut result: string;
    raw {
        result.data = NULL;
        result.len  = 0;
        result.cap  = 0;

        uintptr_t len = (uintptr_t)s.len;
        result.data = (char*)malloc(len + 1);

        if (result.data != NULL) {
            for (uintptr_t i = 0; i < len; i++) {
                result.data[i] = (char)toupper((int)s.data[i]);
            }
            result.data[len] = '\0';
            result.len = len;
            result.cap = len;
        }
    }
    return result;
}

/// Converts string to lowercase.
def to_lower(s: string): string {
    mut result: string;
    raw {
        result.data = NULL;
        result.len  = 0;
        result.cap  = 0;

        uintptr_t len = (uintptr_t)s.len;
        result.data = (char*)malloc(len + 1);

        if (result.data != NULL) {
            for (uintptr_t i = 0; i < len; i++) {
                result.data[i] = (char)tolower((int)s.data[i]);
            }
            result.data[len] = '\0';
            result.len = len;
            result.cap = len;
        }
    }
    return result;
}

/// Copies source string to destination. Modifies dest in place.
def str_copy(src: string, desta: mut string): void {
    for mut i = 0; i < src.len; i++ {
        desta.data[i] = src.data[i];
    }
}

/// Compares two strings. Returns 0 if equal.
def compare(a: string, b: string): i32 {
    mut len: usize = 0;

    if a.len < b.len {
        len = a.len;
    } else {
        len = b.len;
    }

    for mut i = 0; i < len; i++ {
        if a.data[i] < b.data[i] { return -1; }
        if a.data[i] > b.data[i] { return 1; }
    }

    if a.len < b.len { return -1; }
    if a.len > b.len { return 1; }

    return 0;
}

/// Concatenates source string to destination. Returns a new string.
def concat(dest: string, src: string): string {
    mut result: string;
    raw {
        result.data = NULL;
        result.len  = 0;
        result.cap  = 0;

        size_t new_len = (size_t)(dest.len + src.len);
        result.data = (char*)malloc(new_len + 1);

        if (result.data != NULL) {
            if (dest.len > 0) {
                memcpy(result.data, dest.data, dest.len);
            }
            if (src.len > 0) {
                memcpy(result.data + dest.len, src.data, src.len);
            }
            ((char*)result.data)[new_len] = '\0';
            result.len = new_len;
            result.cap = new_len + 1;
        }
    }

    return result;
}

/// Finds first occurrence of character in string. Returns pointer or 0.
def first_occurrence(s: string, c: i32): char* {
    mut result: char* = 0;
    raw {
        result = strchr((const char*)s.data, c);
    }
    return result;
}

/// Finds first occurrence of substring in string. Returns pointer or 0.
def substring(haystack: string, needle: string): char* {
    mut result: char* = 0;
    raw {
        result = strstr((const char*)haystack.data, (const char*)needle.data);
    }
    return result;
}

/// Converts string to integer.
def str_to_int(s: string): i32 {
    mut result: i32 = 0;
    raw {
        result = atoi((const char*)s.data);
    }
    return result;
}

/// Converts string to long integer.
def str_to_long(s: char*): i64 {
    mut result: i64 = 0;
    raw {
        result = atol((const char*)s);
    }
    return result;
}

/// Checks if character is alphabetic.
def is_alpha(c: i32): i32 {
    mut result: i32 = 0;
    raw {
        result = isalpha(c);
    }
    return result;
}

/// Checks if character is numeric.
def is_digit(c: i32): i32 {
    mut result: i32 = 0;
    raw {
        result = isdigit(c);
    }
    return result;
}

/// Checks if character is alphanumeric.
def is_alnum(c: i32): i32 {
    mut result: i32 = 0;
    raw {
        result = isalnum(c);
    }
    return result;
}

/// Converts char* to uppercase.
def to_upper_chrptr(s: char*): char* {
    mut result: char* = 0;
    raw {
        result = (char*)malloc(strlen((const char*)s) + 1);
        if (result != 0) {
            strcpy((char*)result, (const char*)s);
            for (int i = 0; i < strlen((const char*)result); i++) {
                result[i] = toupper(result[i]);
            }
        }
    }
    return result;
}

/// Converts char* to lowercase.
def to_lower_chrptr(s: char*): char* {
    mut result: char* = 0;
    raw {
        result = (char*)malloc(strlen((const char*)s) + 1);
        if (result != 0) {
            strcpy((char*)result, (const char*)s);
            for (int i = 0; i < strlen((const char*)result); i++) {
                result[i] = tolower(result[i]);
            }
        }
    }
    return result;
}

/// Converts character to uppercase.
def to_upper_chr(c: i32): i32 {
    mut result: i32 = 0;
    raw {
        result = toupper(c);
    }
    return result;
}

/// Converts character to lowercase.
def to_lower_chr(c: i32): i32 {
    mut result: i32 = 0;
    raw {
        result = tolower(c);
    }
    return result;
}

/// Allocates and copies a string. Caller must free the result.
def str_dup(s: char*): char* {
    mut result: char* = 0;
    raw {
        int len = (int)strlen((const char*)s);
        result = (char*)malloc(len + 1);
        if (result != 0) {
            strcpy((char*)result, (const char*)s);
        }
    }
    return result;
}

/// Compares first n characters of two strings. Returns 0 if equal.
def str_ncmp(s1: char*, s2: char*, n: i32): i32 {
    mut result: i32 = 0;
    raw {
        result = strncmp((const char*)s1, (const char*)s2, n);
    }
    return result;
}

/// Copies at most n characters from source to destination.
def str_ncopy(dest: char*, src: char*, n: i32): char* {
    mut result: char* = 0;
    raw {
        result = strncpy((char*)dest, (const char*)src, n);
    }
    return result;
}

/// Converts an integer to a string. Buffer must be at least 12 bytes.
def int_to_str(value: i32, buffer: char*): char* {
    raw {
        sprintf(buffer, "%d", value);
    }
    return buffer;
}

/// Converts a long to a string. Buffer must be at least 21 bytes.
def long_to_str(value: i64, buffer: char*): char* {
    raw {
        sprintf(buffer, "%ld", value);
    }
    return buffer;
}

/// Converts a float to a string. Buffer must be at least 32 bytes.
def float_to_str(value: f32, buffer: char*): char* {
    raw {
        sprintf(buffer, "%f", value);
    }
    return buffer;
}

/// Converts a double to a string. Buffer must be at least 32 bytes.
def double_to_str(value: f64, buffer: char*): char* {
    raw {
        sprintf(buffer, "%lf", value);
    }
    return buffer;
}

/// Formats a string using a format string and arguments.
/// Each `{}` placeholder in `fmt_string` is replaced by the next string in `args`.
def fmt(fmt_string: string, args: string[]): string {
    mut result: string = string.create("");
    mut arg_index: i32 = 0;
    mut i: i32 = 0;

    loop {
        if i >= fmt_string.len {
            break;
        }
        if fmt_string.data[i] == '{' and fmt_string.data[i+1] == '}' {
            mut s: string = args[arg_index];
            arg_index = arg_index + 1;
            result = concat(result, s);
            i = i + 2;
        } else {
            raw {
                char tmp[2];
                tmp[0] = fmt_string.data[i];
                tmp[1] = '\0';
                strcat((char*)result.data, tmp);
                result.len = (uintptr_t)strlen((const char*)result.data);
                result.cap = result.len;
            }
            i = i + 1;
        }
    }
    return result;
}

/// Returns the index of the first occurrence of character `c` in `s` at or after `start`.
/// Returns -1 if the character is not found.
def find_char_from(s: string, c: char, start: usize): i32 {
    mut index: i32 = -1;
    raw {
        if (start >= s.len) {
            index = -1;
        } else {
            for (size_t i = (size_t)start; i < (size_t)s.len; i++) {
                if (s.data[i] == c) {
                    index = (int)i;
                    break;
                }
            }
        }
    }
    return index;
}

/// Returns a substring of `s` starting at `start` with the given `length`.
/// If `start` is beyond the end of the string or `length` is zero, an empty string is returned.
/// The function clamps the requested range to the bounds of the source string.
def substr(s: string, start: usize, length: usize): string {
    mut result: string = string.create("");
    raw {
        if (start >= s.len || length == 0) {
            return result;
        }
        size_t max_len = (size_t)(s.len - start);
        size_t copy_len = (size_t)length;
        if (copy_len > max_len) {
            copy_len = max_len;
        }
        char *buf = (char*)malloc(copy_len + 1);
        if (!buf) {
            return result;
        }
        memcpy(buf, s.data + start, copy_len);
        buf[copy_len] = '\0';
        result = std_string_string_create(buf);
        free(buf);
    }
    return result;
}

/// Checks if string has prefix.
def has_prefix(s: string, prefix: string): bool {
    if prefix.len == 0 {
        return true;
    }
    if prefix.len > s.len {
        return false;
    }

    mut i: usize = 0;
    loop {
        if i >= prefix.len {
            break;
        }
        if s.data[i] != prefix.data[i] {
            return false;
        }
        i = i + 1;
    }

    return true;
}

/// Checks if string has suffix.
def has_suffix(s: string, suffix: string): bool {
    if suffix.len == 0 {
        return true;
    }
    if suffix.len > s.len {
        return false;
    }

    mut i: usize = 0;
    mut start: usize = s.len - suffix.len;
    loop {
        if i >= suffix.len {
            break;
        }
        if s.data[start + i] != suffix.data[i] {
            return false;
        }
        i = i + 1;
    }

    return true;
}

/// Removes prefix from string.
def trim_prefix(s: string, prefix: string): string {
    if prefix.len == 0 or prefix.len > s.len {
        return s;
    }

    mut i: usize = 0;
    loop {
        if i >= prefix.len {
            break;
        }
        if s.data[i] != prefix.data[i] {
            return s;
        }
        i = i + 1;
    }

    return substr(s, prefix.len, s.len - prefix.len);
}

/// Removes suffix from string.
def trim_suffix(s: string, suffix: string): string {
    if suffix.len == 0 or suffix.len > s.len {
        return s;
    }

    mut i: usize = 0;
    mut start: usize = s.len - suffix.len;
    loop {
        if i >= suffix.len {
            break;
        }
        if s.data[start + i] != suffix.data[i] {
            return s;
        }
        i = i + 1;
    }

    return substr(s, 0, s.len - suffix.len);
}

/// Strip leading whitespace from a string.
def lstrip(s: string): string {
    if s.len == 0 {
        return s;
    }

    mut start: usize = 0;
    loop {
        if start >= s.len {
            break;
        }
        val ch: char = s.data[start];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            start++;
        } else {
            break;
        }
    }

    if start >= s.len {
        return string.create("");
    }

    return substr(s, start, s.len - start);
}

/// Strip trailing whitespace from a string.
def rstrip(s: string): string {
    if s.len == 0 {
        return s;
    }

    mut end: usize = s.len;
    loop {
        if end == 0 {
            break;
        }
        val ch: char = s.data[end - 1];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            end--;
        } else {
            break;
        }
    }

    if end == 0 {
        return string.create("");
    }

    return substr(s, 0, end);
}

/// String trailing and leading whitespace.
def strip(s: string): string {
    if s.len == 0 {
        return s;
    }

    mut start: usize = 0;
    loop {
        if start >= s.len {
            break;
        }
        val ch: char = s.data[start];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            start++;
        } else {
            break;
        }
    }

    if start >= s.len {
        return string.create("");
    }

    mut end: usize = s.len;
    loop {
        if end == 0 {
            break;
        }
        val ch: char = s.data[end - 1];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            end--;
        } else {
            break;
        }
    }
    return substr(s, start, end - start);
}

/// Convenience function to convert a char* to a string.
def str(data: char*): string {
    return string.create(data);
}

test {    
    assert(is_alpha(65) != 0, "65 (A) should be alphabetic");
    assert(is_digit(48) != 0, "48 (0) should be a digit");
    assert(is_alnum(97) != 0, "97 (a) should be alphanumeric");
    assert(to_upper_chr(97) == 65, "to_upper_chr('a') should return A");
    assert(to_lower_chr(65) == 97, "to_lower_chr('A') should return a");
    assert(str_ncmp("hello", "help", 3) == 0, "first 3 chars of hello and help should match");
    
    mut buffer: char[64];
    
    int_to_str(42, buffer);
    assert(str_ncmp(buffer, "42", 2) == 0, "int_to_str(42) should produce 42");
    
    int_to_str(-123, buffer);
    assert(str_ncmp(buffer, "-123", 4) == 0, "int_to_str(-123) should produce -123");
    
    int_to_str(0, buffer);
    assert(str_ncmp(buffer, "0", 1) == 0, "int_to_str(0) should produce 0");
    
    long_to_str(1000, buffer);
    assert(str_ncmp(buffer, "1000", 4) == 0, "long_to_str(1000) should produce 1000");
    
    long_to_str(-9999, buffer);
    assert(str_ncmp(buffer, "-9999", 5) == 0, "long_to_str(-9999) should produce -9999");

    val lower_case_string: string = string.create("hello, world");
    val upper_case_string: string = to_upper(lower_case_string);
    assert(compare(upper_case_string, string.create("HELLO, WORLD")) == 0, "to_upper should convert to uppercase");

    val test_string: string = string.create("hello, world");
    val test_string2: string = string.create("hello, world");

    assert(compare(test_string, test_string2) == 0, "test_string and test_string2 should be equal");
    assert(compare(to_lower(string.create("HELLO WORLD")), string.create("hello world")) == 0, "to_lower should convert to lowercase");

    
    val str1: string = string.create("hello");
    val str2: string = string.create(" world");
    val str3: string = concat(str1, str2);
    assert(compare(str3, string.create("hello world")) == 0, "concat should concatenate strings");

    val str4: string = string.create("hello world");
    val str5: string = trim_prefix(str4, string.create("hello "));
    assert(compare(str5, string.create("world")) == 0, "trim_prefix should remove prefix");

    val str6: string = string.create("hello world");
    val str7: string = trim_suffix(str6, string.create(" world"));
    assert(compare(str7, string.create("hello")) == 0, "trim_suffix should remove suffix");

    val str8: string = string.create("  \thello world   ");
    val str9: string = strip(str8);
    assert(compare(str9, string.create("hello world")) == 0, "strip should remove leading and trailing whitespace");

    val str10: string = string.create("  \thello world   ");
    val str11: string = lstrip(str10);
    assert(compare(str11, string.create("hello world   ")) == 0, "lstrip should remove leading whitespace only");

    val str12: string = string.create("  hello world   \t\n");
    val str13: string = rstrip(str12);
    assert(compare(str13, string.create("  hello world")) == 0, "rstrip should remove trailing whitespace only");

    val base: string = string.create("foobar");
    assert(has_prefix(base, string.create("foo")), "has_prefix should detect valid prefix");
    assert(!has_prefix(base, string.create("bar")), "has_prefix should reject non-prefix");
    assert(has_suffix(base, string.create("bar")), "has_suffix should detect valid suffix");
    assert(!has_suffix(base, string.create("foo")), "has_suffix should reject non-suffix");
    assert(has_prefix(base, string.create("")), "empty prefix should always match");
    assert(has_suffix(base, string.create("")), "empty suffix should always match");
    assert(!has_prefix(base, string.create("foobarbaz")), "longer prefix should not match");
    assert(!has_suffix(base, string.create("foobarbaz")), "longer suffix should not match");

    // TODO: Array literal syntax needs parser fix
    // assert compare(
    //         fmt(str("Hello, {}! Today is {}."), [string]{str("Alice"), str("Monday")}), 
    //         str("Hello, Alice! Today is Monday.")
    //     ) == 0, 
    //     "fmt should format strings correctly";
    
    // TODO: Array literal syntax needs parser fix
    // print_str(fmt(str("Hello, {}! Today is {}."), [string]{str("Alice"), str("Monday")}));
    
    val y = 10;
    
    print_str(str($"{y}"));
}