use stdlib/string (string, concat, find_char_from, substr, trim_prefix, trim_suffix);
use stdlib/os (read_file, write_file, is_file, get_cmdline_args);
use stdlib/regex (match);
use stdlib/io (println_str, print_str, println_i32);

def trim_leading_whitespace(s: string): string {
    mut i: usize = 0;
    loop {
        if i >= s.len {
            break;
        }
        if s.data[i] == ' ' or s.data[i] == '\t' {
            i++;
        } else {
            break;
        }
    }
    return substr(s, i, s.len - i);
}

def make_markdown_path(path: string): string {
    mut dot_index: i32 = -1;
    mut i: usize = 0;
    loop {
        if i >= path.len {
            break;
        }
        if path.data[i] == '.' {
            dot_index = (i32)i;
        }
        i++;
    }

    mut base: string;
    if dot_index == -1 {
        base = path;
    } else {
        base = substr(path, 0, (usize)dot_index);
    }

    return concat(base, string.create(".md"));
}

def append_line(target: string, line: string): string {
    mut result: string = target;
    result = concat(result, line);
    result = concat(result, string.create("\n"));
    return result;
}

def generate_docs_for_file(path: string): bool {
    if !is_file(path) {
        print_str(string.create("axedoc: not a file: "));
        println_str(path);
        return false;
    }

    val source: string = read_file(path);
    val def_pattern: string = string.create("^\\s*def ");
    val model_pattern: string = string.create("^\\s*model ");
    val doc_pattern: string = string.create("^\\s*///");

    mut markdown: string = string.create("");

    markdown = append_line(markdown, concat(string.create("# "), path));

    mut current_doc: string = string.create("");
    mut pos: usize = 0;

    loop {
        if pos >= source.len {
            break;
        }

        mut nl_index: i32 = find_char_from(source, '\n', pos);
        mut line: string;

        if nl_index == -1 {
            line = substr(source, pos, source.len - pos);
            pos = source.len;
        } else {
            line = substr(source, pos, (usize)nl_index - pos);
            pos = (usize)nl_index + 1;
        }

        val trimmed: string = trim_leading_whitespace(line);

        mut is_doc: bool = false;
        if trimmed.len >= 3 {
            if trimmed.data[0] == '/' and trimmed.data[1] == '/' and trimmed.data[2] == '/' {
                is_doc = true;
            }
        }

        if is_doc {
            mut content_start: usize = 3;
            loop {
                if content_start >= trimmed.len {
                    break;
                }
                if trimmed.data[content_start] == ' ' or trimmed.data[content_start] == '\t' {
                    content_start = content_start + 1;
                } else {
                    break;
                }
            }

            val doc_line: string = substr(trimmed, content_start, trimmed.len - content_start);

            if current_doc.len == 0 {
                current_doc = doc_line;
            } else {
                current_doc = append_line(current_doc, doc_line);
            }

            continue;
        }

        mut is_def_sig: bool = false;
        mut is_model_sig: bool = false;

        if match(def_pattern, trimmed) {
            is_def_sig = true;
        } elif match(model_pattern, trimmed) {
            is_model_sig = true;
        }

        if is_def_sig or is_model_sig {
            markdown = append_line(markdown, string.create(""));

            mut heading_prefix: string;
            if is_model_sig {
                heading_prefix = string.create("## model ");
            } else {
                heading_prefix = string.create("## def ");
            }

            mut signature_text: string = trimmed;

            if is_model_sig and trimmed.len > 6 {
                signature_text = substr(trimmed, 6, trimmed.len - 6);
            } elif is_def_sig and trimmed.len > 4 {
                signature_text = substr(trimmed, 4, trimmed.len - 4);
            }

            mut end: usize = signature_text.len;
            loop {
                if end == 0 {
                    break;
                }
                val ch: char = signature_text.data[end - 1];
                if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
                    end = end - 1;
                } else {
                    break;
                }
            }
            if end != signature_text.len {
                signature_text = substr(signature_text, 0, end);
            }

            signature_text = trim_suffix(signature_text, string.create(" {"));
            signature_text = trim_suffix(signature_text, string.create("{"));

            mut heading: string = heading_prefix;
            heading = concat(heading, signature_text);
            markdown = append_line(markdown, heading);

            if current_doc.len > 0 {
                markdown = append_line(markdown, string.create(""));
                markdown = concat(markdown, current_doc);
                markdown = append_line(markdown, string.create(""));
                current_doc = string.create("");
            }

            continue;
        }
    }

    val out_path: string = make_markdown_path(path);
    val ok: bool = write_file(out_path, markdown);

    if !ok {
        print_str(string.create("axedoc: failed to write: "));
        println_str(out_path);
    }

    return ok;
}

main {
    val arena: Arena = Arena.create(65536);
    val args: ref StringList = get_cmdline_args(ref arena);
    if args.len < 2 {
        println_str(string.create("Usage: axedoc <file>"));
        return 1;
    }
    val path: string = StringList.get(args, 1);
    if !generate_docs_for_file(path) {
        return 1;
    }
    Arena.destroy(ref_of(arena));
}
