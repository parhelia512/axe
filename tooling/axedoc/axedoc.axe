use std.string (string, concat, find_char_from, substr, trim_prefix, trim_suffix, strip, lstrip, compare);
use std.os (read_file, write_file, is_file, get_cmdline_args, list_files_recursive);
use std.regex (match);
use std.io (println_str, print_str, println_i32);
use std.arena;

def make_markdown_path(path: string): string {
    mut dot_index: i32 = -1;
    mut i: usize = 0;
    loop {
        if i >= path.len {
            break;
        }
        if path.data[i] == '.' {
            dot_index = (i32)i;
        }
        i++;
    }

    mut base: string;
    if dot_index == -1 {
        base = path;
    } else {
        base = substr(path, 0, (usize)dot_index);
    }

    return concat(base, string.create(".md"));
}

def append_line(target: string, line: string): string {
    mut result: string = target;
    result = concat(result, line);
    result = concat(result, string.create("\n"));
    return result;
}

def has_suffix(value: string, suffix: string): bool {
    if suffix.len == 0 or suffix.len > value.len {
        return false;
    }

    mut i: usize = 0;
    mut start: usize = value.len - suffix.len;
    loop {
        if i >= suffix.len {
            break;
        }
        if value.data[start + i] != suffix.data[i] {
            return false;
        }
        i = i + 1;
    }

    return true;
}

def is_source_file(path: string): bool {
    val ext_axe: string = string.create(".axe");
    val ext_axec: string = string.create(".axec");

    if has_suffix(path, ext_axe) {
        return true;
    }

    if has_suffix(path, ext_axec) {
        return true;
    }

    return false;
}

def generate_docs_for_file(path: string): bool {
    if !is_file(path) {
        print_str(string.create("axedoc: not a file: "));
        println_str(path);
        return false;
    }

    val source: string = read_file(path);
    val def_pattern: string = string.create("^\\s*def ");
    val model_pattern: string = string.create("^\\s*model ");
    val doc_pattern: string = string.create("^\\s*///");

    mut markdown: string = string.create("");

    markdown = append_line(markdown, concat(string.create("# "), path));

    mut current_doc: string = string.create("");
    mut pos: usize = 0;

    loop {
        if pos >= source.len {
            break;
        }

        mut nl_index: i32 = find_char_from(source, '\n', pos);
        mut line: string;

        if nl_index == -1 {
            line = substr(source, pos, source.len - pos);
            pos = source.len;
        } else {
            line = substr(source, pos, (usize)nl_index - pos);
            pos = (usize)nl_index + 1;
        }

        val trimmed: string = lstrip(line);

        mut is_doc: bool = false;
        if trimmed.len >= 3 {
            if trimmed.data[0] == '/' and trimmed.data[1] == '/' and trimmed.data[2] == '/' {
                is_doc = true;
            }
        }

        if is_doc {
            mut content_start: usize = 3;
            loop {
                if content_start >= trimmed.len {
                    break;
                }
                if trimmed.data[content_start] == ' ' or trimmed.data[content_start] == '\t' {
                    content_start = content_start + 1;
                } else {
                    break;
                }
            }

            val doc_line: string = substr(trimmed, content_start, trimmed.len - content_start);

            if current_doc.len == 0 {
                current_doc = doc_line;
            } else {
                current_doc = append_line(current_doc, doc_line);
            }

            continue;
        }

        mut is_def_sig: bool = false;
        mut is_model_sig: bool = false;

        if match(def_pattern, trimmed) {
            is_def_sig = true;
        } elif match(model_pattern, trimmed) {
            is_model_sig = true;
        }

        if is_def_sig or is_model_sig {
            markdown = append_line(markdown, string.create(""));

            mut heading_prefix: string;
            if is_model_sig {
                heading_prefix = string.create("## model ");
            } else {
                heading_prefix = string.create("## def ");
            }

            mut signature_text: string = trimmed;

            if is_model_sig and trimmed.len > 6 {
                signature_text = substr(trimmed, 6, trimmed.len - 6);
            } elif is_def_sig and trimmed.len > 4 {
                signature_text = substr(trimmed, 4, trimmed.len - 4);
            }

            signature_text = strip(signature_text);
            signature_text = trim_suffix(signature_text, string.create(" {"));
            signature_text = trim_suffix(signature_text, string.create("{"));

            mut heading: string = heading_prefix;
            heading = concat(heading, signature_text);
            markdown = append_line(markdown, heading);

            if current_doc.len > 0 {
                markdown = append_line(markdown, string.create(""));
                markdown = concat(markdown, current_doc);
                markdown = append_line(markdown, string.create(""));
                current_doc = string.create("");
            }

            continue;
        }
    }

    val out_path: string = make_markdown_path(path);
    val ok: bool = write_file(out_path, markdown);

    if !ok {
        print_str(string.create("axedoc: failed to write: "));
        println_str(out_path);
    }

    return ok;
}

main {
    val arena: Arena = Arena.create(65536);
    val args: ref StringList = get_cmdline_args(ref arena);
    if args.len < 2 {
        println_str(string.create("Usage: axedoc <file> | --all"));
        Arena.destroy(ref_of(arena));
        return 1;
    }
    val first_arg: string = StringList.get(args, 1);
    val all_flag: string = string.create("--all");
    if compare(first_arg, all_flag) == 0 {
        val root: string = string.create(".");
        val files: ref StringList = list_files_recursive(root, ref arena);
        mut all_ok: bool = true;
        for mut val i = 0; i < files.len; i = i + 1 {
            val p: string = StringList.get(files, i);
            if !is_source_file(p) {
                continue;
            }
            if !generate_docs_for_file(p) {
                all_ok = false;
            }
        }
        Arena.destroy(ref_of(arena));
        if !all_ok {
            return 1;
        }
        return 0;
    } else {
        val path: string = first_arg;
        if !generate_docs_for_file(path) {
            Arena.destroy(ref_of(arena));
            return 1;
        }
        Arena.destroy(ref_of(arena));
        return 0;
    }
}
