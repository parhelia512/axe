/// Author: Navid Momtahen (C) 2025
/// License: GPL-3.0
/// 
/// Handles build process orchestration.

use gstate;

use structs (
    ASTNode
);
use lexer (
    lex,
    Token
);
use parser (
    parse,
    initialize_all
);
use imports (
    reset_processed_modules,
    process_imports,
    has_imported_module
);
use renderer (
    has_external_header, 
    initialize_renderer, 
    set_source_file, 
    set_emit_line_directives,
    generate_c,
    renderer_add_prefix
);
use std.os (
    ExecResult, 
    exec_capture, 
    exec, 
    delete_file, 
    get_executable_dir,
    file_exists
);

use std.io;
use std.string;
use std.lists (
    StringList
);

/// Check if a command exists in PATH
def command_exists(cmd: string): bool {
    mut check_cmd: string;
    platform windows {
        check_cmd = concat(str("where "), cmd);
        check_cmd = concat_c(check_cmd, " >nul 2>&1");
    }
    platform posix {
        check_cmd = concat(str("command -v "), cmd);
        check_cmd = concat_c(check_cmd, " >/dev/null 2>&1");
    }
    
    val result: ExecResult = exec_capture(check_cmd);
    return result.exit_code == 0;
}

/// Print all errors if there are any.
def filter_and_print_errors(output: string) {
    if str_len(output) == 0 {
        return;
    }
    println output;
}

/// Detect if a name already has a module-style "__" prefix.
def has_double_underscore(name: string): bool {
    val nlen: i32 = str_len(name);
    mut k: i32 = 0;
    loop {
        if k + 1 >= nlen {
            break;
        }
        val c1: char = get_char(name, k);
        val c2: char = get_char(name, k + 1);
        if c1 == '_' and c2 == '_' {
            return true;
        }
        k++;
    }
    return false;
}

/// Prefix only root enums (those without an existing module-style prefix)
/// so that their C enums and members become unique symbols like:
///   - tests__enums__State
///   - tests__enums__State_RUNNING
def prefix_root_enums(node: ref ASTNode, mprefix: string) {
    if node == nil {
        return;
    }

    val nt: string = node.node_type;
    if equals_c(nt, "Enum") {
        val ename: string = node.data.enum_node.name;
        if str_len(mprefix) > 0 and !has_double_underscore(ename) {
            mut new_name: string = to_c_identifier(mprefix);
            new_name = concat_c(new_name, "__");
            new_name = concat(new_name, ename);
            node.data.enum_node.name = new_name;
        }
    }

    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut ci: i32 = 0;
        loop {
            if ci >= len(deref(chs)) {
                break;
            }
            prefix_root_enums(addr(chs.data[ci]), mprefix);
            ci++;
        }
    }
}

/// Prefix root functions (those without an existing module-style prefix)
/// and register them in the renderer so that calls are rewritten.
def prefix_root_functions(node: ref ASTNode, mprefix: string) {
    if node == nil {
        return;
    }

    val nt: string = node.node_type;
    if equals_c(nt, "Function") {
        val fname: string = node.data.function.name;
        if !equals_c(fname, "main") {
             if str_len(mprefix) > 0 and !has_double_underscore(fname) {
                mut new_name: string = to_c_identifier(mprefix);
                new_name = concat(new_name, str("__"));
                new_name = concat(new_name, fname);
                
                node.data.function.name = new_name;
                renderer_add_prefix(fname, new_name);
            }
        }
    }

    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut ci: i32 = 0;
        loop {
            if ci >= len(deref(chs)) {
                break;
            }
            prefix_root_functions(addr(chs.data[ci]), mprefix);
            ci = ci + 1;
        }
    }
}

/// If identifier starts with a digit, prepend an underscore
/// Replace special characters with '_'
def to_c_identifier(identifier: string): string {
    val len: i32 = str_len(identifier);
    mut sb: StringBuilder = StringBuilder.init(len + 1);
    
    if is_digit(cast[i32](get_char(identifier, 0))) {
        StringBuilder.append_char(addr(sb), '_');
    }

    mut i: i32 = 0;
    loop {
        if i >= len {
            break;
        }
        val c: char = get_char(identifier, i);
        if is_alphanum(cast[i32](c)) {
            StringBuilder.append_char(addr(sb), c);
        } else {
            StringBuilder.append_char(addr(sb), '_');
        }
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Print AST node with indentation for debugging
def print_ast_node(node: ref ASTNode, prefix: string, is_last: bool) {
    if node == nil {
        return;
    }

    mut line: string = str("");
    
    if is_last {
        line = concat(prefix, str("└─ "));
    } else {
        line = concat(prefix, str("├─ "));
    }

    println(concat(line, node.node_type));

    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut ci: i32 = 0;
        val total: i32 = len(deref(chs));
        loop {
            if ci >= total {
                break;
            }
            val child_is_last: bool = (ci == total - 1);
                mut new_prefix: string;
                if is_last {
                    new_prefix = concat(prefix, str("   "));
                } else {
                    new_prefix = concat(prefix, str("│  "));
                }

            print_ast_node(addr(chs.data[ci]), new_prefix, child_is_last);
            ci++;
        }
    }
}

/// Check if a function has the [entry] tag
def has_entry_tag(tags: ref list(string)): bool {
    if tags == nil { return false; }
    mut i: i32 = 0;
    loop {
        if i >= len(deref(tags)) { break; }
        if equals_c(tags.data[i], "entry") { return true; }
        i++;
    }
    return false;
}

/// Recursively count entry points (main or [entry]) and test blocks
def count_entry_points(node: ref ASTNode, main_count: ref i32, custom_entry_count: ref i32, test_count: ref i32) {
    if node == nil { return; }

    val nt: string = node.node_type;
    
    if equals_c(nt, "Test") {
        deref(test_count) = deref(test_count) + 1;
    }
    
    if equals_c(nt, "Function") {
        val fname: string = node.data.function.name;
        if equals_c(fname, "main") {
             deref(main_count) = deref(main_count) + 1;
        } elif has_entry_tag(node.data.function.tags) {
             deref(custom_entry_count) = deref(custom_entry_count) + 1;
        }
    }
    
    if node.children != nil {
        val children: ref list(ASTNode) = node.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) { break; }
            count_entry_points(addr(children.data[i]), main_count, custom_entry_count, test_count);
            i++;
        }
    }
}

/// Validate that there is exactly one entry point (or tests)
def validate_entry_points(node: ref ASTNode, filename: string): bool {
    mut main_count: i32 = 0;
    mut custom_entry_count: i32 = 0;
    mut test_count: i32 = 0;
    
    count_entry_points(node, addr(main_count), addr(custom_entry_count), addr(test_count));
    
    val total_entries: i32 = main_count + custom_entry_count;
    
    if total_entries > 1 {
        println(concat(str("error: multiple entry points defined in compilation unit '"), filename));
        println "Only one function can be the entry point (either 'main' or marked with '[entry]').";
        return false;
    }
    
    if total_entries == 0 and test_count == 0 {
        println(concat(str("error: no entry point in compilation unit '"), filename));
        println ". add either 'test { }' or 'def main() { }' (or use [entry] tag) to the file.";
        return false;
    }
    
    if custom_entry_count > 0 {
        val is_shared: bool = ::build_shared_lib;
        val compile_only: bool = get_compile_only();
        
        if !is_shared and !compile_only {
            println(concat(str("error: custom entry point in '"), filename));
            println " requires compiling with -dll (shared library) or -c (compile only) flag.";
            return false;
        }
    }
    
    return true;
}

/// Compile an Axe source file to an executable
def compile_file(filename: string, is_axec: bool, output_filename: string): bool {
    if !::quiet_mode {
        println(concat(str("Compiling: "), filename));
        println "1 | IO";
    }

    val source: string = read_file(filename);
    if str_len(source) == 0 {
        println "Error: Could not read source file";
        return false;
    }
    
    if !::quiet_mode {
        println "2 | Lex";
    }
    val tokens: list(Token) = lex(source);
    if len(tokens) == 0 {
        println "Error: No tokens generated";
        return false;
    }
    
    val do_print_tokens: bool = ::print_tokens;

    if do_print_tokens {
        mut ti: i32 = 0;
        loop {
            if ti >= len(tokens) {
                break;
            }
            val cur_tok: ref Token = addr(tokens.data[ti]);
            val tok_type_str: string = i32_to_string(cur_tok.token_type);
            val tok_val: string = cur_tok.value;
            print(concat(str("["), tok_type_str));
            print "] ";
            println tok_val;
            ti++;
        }
    }
    
    if !::quiet_mode {
        println "3 | Parse";
    }
    initialize_all();
    mut ast: ASTNode = parse(addr(tokens), is_axec, true, str(""), filename);
    if len(ast.children) == 0 {
        println "Error: Failed to parse";
        return false;
    }
    
    if !::quiet_mode {
        println "4 | Imports";
    }
    reset_processed_modules();

    mut base_dir: string = str(".");
    val lenf: i32 = str_len(filename);
    mut idx: i32 = lenf - 1;

    loop {
        if idx < 0 {
            break;
        }
        val ch: char = get_char(filename, idx);
        if ch == '/' or ch == '\\' {
            base_dir = substring_se(filename, 0, idx);
            break;
        }
        idx--;
    }

    val module_name: string = str("");
    ast = process_imports(addr(ast), base_dir, is_axec, filename, true, module_name);

    if !validate_entry_points(addr(ast), filename) {
        return false;
    }
    
    val syntax_only: bool = ::syntax_check_only;
    if syntax_only {
        return true;
    }
    
    val do_print_ast: bool = ::print_ast;
    if do_print_ast {
        print_ast_node(addr(ast), str(""), true);
        quit(0);
    }

    if !::quiet_mode {
        println "5 | Lowering";
    }

    mut dir_name: string = str("");
    mut file_stem: string = str("");
    val flen: i32 = str_len(filename);
    mut last_dot: i32 = -1;
    mut i_ext: i32 = flen - 1;

    if !::quiet_mode {
        println "6 | PFCCG I";
    }

    loop {
        if i_ext < 0 {
            break;
        }
        val ch_ext: char = get_char(filename, i_ext);
        if ch_ext == '.' {
            last_dot = i_ext;
            break;
        }
        i_ext--;
    }

    if last_dot < 0 {
        last_dot = flen;
    }

    if !::quiet_mode {
        println "7 | PFCCG II";
    }

    mut last_sep: i32 = -1;
    mut i_sep: i32 = flen - 1;
    loop {
        if i_sep < 0 {
            break;
        }
        val ch_sep: char = get_char(filename, i_sep);
        if ch_sep == '/' or ch_sep == '\\' {
            last_sep = i_sep;
            break;
        }
        i_sep = i_sep - 1;
    }

    if last_sep >= 0 {
        file_stem = substring_se(filename, last_sep + 1, last_dot);
    } else {
        file_stem = substring_se(filename, 0, last_dot);
    }

    if !::quiet_mode {
        println "8 | PFCCG III";
    }
    if last_sep > 0 {
        mut dir_sep2: i32 = -1;
        mut j: i32 = last_sep - 1;
        loop {
            if j < 0 {
                break;
            }
            val ch2: char = get_char(filename, j);
            if ch2 == '/' or ch2 == '\\' {
                dir_sep2 = j;
                break;
            }
            j--;
        }
        if dir_sep2 >= 0 {
            dir_name = substring_se(filename, dir_sep2 + 1, last_sep);
        } else {
            dir_name = substring_se(filename, 0, last_sep);
        }
    }

    if equals_c(dir_name, ".") {
        dir_name = str("");
    }

    if !::quiet_mode {
        println "9 | PFCCG IV";
    }

    mut module_prefix: string = str("");
    if str_len(dir_name) > 0 {
        module_prefix = dir_name;
        module_prefix = concat(module_prefix, str("__"));
        module_prefix = concat(module_prefix, file_stem);
    } else {
        module_prefix = file_stem;
    }

    if !::quiet_mode {
        println "10| PFCCG V";
    }

    prefix_root_enums(addr(ast), module_prefix);
    initialize_renderer();
    prefix_root_functions(addr(ast), module_prefix);
    set_source_file(filename);

    if ::bootstrap_mode {
        set_emit_line_directives(false);
    }

    if !::quiet_mode {
        println "11| GEN";
    }

    val c_code: string = generate_c(addr(ast));

    if str_len(c_code) == 0 {
        println "Error: Failed to generate C code";
        return false;
    }

    val c_filename: string = replace_extension(filename, str(".c"));
    write_file(c_filename, c_code);
    
    if !::quiet_mode {
        println "12| Last compilation pass";
    }

    val exe_filename: string = get_output_filename(output_filename, filename);
    val needs_omp: bool = should_link_openmp(addr(ast), filename);
    val homebrew_llvm_path: string = str("/opt/homebrew/opt/llvm/bin/clang");
    mut compiler: string = str("");

    platform macos {
        if file_exists(homebrew_llvm_path) {
            compiler = homebrew_llvm_path;
        }
    }

    if str_len(compiler) == 0 {
        if command_exists(str("clang")) {
            compiler = str("clang");
        } else {
            if command_exists(str("cc")) {
                compiler = str("cc");
                if !::quiet_mode {
                    println "\ncc: Linking.";
                }
            }
            
            if str_len(compiler) == 0 {
                println "\nYou do not have the LLVM C toolchain installed.";
                println "Install clang from https://releases.llvm.org/ or via your package manager.";
                println "Alternatively, ensure 'cc' is available in your PATH.";
                platform macos {
                    println "For parallel features to work, run 'brew install llvm' first (requires installing Homebrew).";
                }
                return false;
            }
        }
    }
    
    mut compile_cmd: string = concat(compiler, str(" "));
    
    val target_triple: string = get_target_triple();
    if str_len(target_triple) > 0 {
        if !::quiet_mode {
            println(concat(str("Cross-compiling for target: "), target_triple));
            val sysroot: string = get_sysroot_path();
            if str_len(sysroot) == 0 {
                println "\nWarning: No --sysroot specified. Cross-compilation may fail without target SDK.";
            }
        }
        compile_cmd = concat_c(compile_cmd, "--target=");
        compile_cmd = concat(compile_cmd, target_triple);
        compile_cmd = concat_c(compile_cmd, " ");
    }
    
    val sysroot_path: string = get_sysroot_path();
    if str_len(sysroot_path) > 0 {
        compile_cmd = concat_c(compile_cmd, "--sysroot=");
        compile_cmd = concat(compile_cmd, sysroot_path);
        compile_cmd = concat_c(compile_cmd, " ");
    }
    
    compile_cmd = concat(compile_cmd, c_filename);
    
    val is_shared: bool = ::build_shared_lib;
    if is_shared {
        platform windows {
            compile_cmd = concat_c(compile_cmd, " -shared");
        }
        platform posix {
            compile_cmd = concat_c(compile_cmd, " -shared -fPIC");
        }
    }
    
    if needs_omp {
        compile_cmd = concat(compile_cmd, str(" -fopenmp"));
    }
    
    val inc_paths: ref StringList = get_include_paths();
    if inc_paths != nil {
        mut ip_idx: i32 = 0;
        loop {
            if ip_idx >= len(deref(inc_paths)) {
                break;
            }
            compile_cmd = concat_c(compile_cmd, " -I");
            compile_cmd = concat(compile_cmd, inc_paths.data[ip_idx]);
            ip_idx++;
        }
    }
    
    val lib_paths: ref StringList = get_library_paths();
    if lib_paths != nil {
        mut lp_idx: i32 = 0;
        loop {
            if lp_idx >= len(deref(lib_paths)) {
                break;
            }
            compile_cmd = concat_c(compile_cmd, " -L");
            compile_cmd = concat(compile_cmd, lib_paths.data[lp_idx]);
            lp_idx++;
        }
    }
    
    val toolchain_root: string = get_executable_dir();
    
    if has_external_header(str("pcre.h")) {
        compile_cmd = concat_c(compile_cmd, " -DPCRE_STATIC");
        platform windows {
            compile_cmd = concat_c(compile_cmd, " -I");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/pcre/include ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/x64-windows/pcre.lib");
        }
        platform linux {
            compile_cmd = concat_c(compile_cmd, " -I");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/pcre/include ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/lib-linux/libpcre.a");
        }
        platform macos {
            compile_cmd = concat_c(compile_cmd, " -I");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/pcre/include ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/lib-macos/libpcre.a");
        }
    }
    
    if has_imported_module(str("std/net")) or has_imported_module(str("net.axe")) or find_substr(filename, str("net.axe")) >= 0 {
        compile_cmd = concat_c(compile_cmd, " -DCURL_STATICLIB -I");
        compile_cmd = concat(compile_cmd, toolchain_root);
        compile_cmd = concat_c(compile_cmd, "/external/curl/include");
        platform windows {
            compile_cmd = concat_c(compile_cmd, " ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/x64-windows/libcurl.lib ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/x64-windows/zlib.lib");
            compile_cmd = concat_c(compile_cmd, " -lws2_32 -lwldap32 -ladvapi32 -lcrypt32");
            compile_cmd = concat_c(compile_cmd, " -lnormaliz -liphlpapi -lsecur32 -lbcrypt");
        }
        platform posix {
            compile_cmd = concat_c(compile_cmd, " -lcurl -lz");
        }
    }
    
    if has_imported_module(str("std/json")) or has_imported_module(str("json.axe")) or find_substr(filename, str("json.axe")) >= 0 {
        compile_cmd = concat_c(compile_cmd, " -I");
        compile_cmd = concat(compile_cmd, toolchain_root);
        compile_cmd = concat_c(compile_cmd, "/external/yyjson/include");
        platform windows {
            compile_cmd = concat_c(compile_cmd, " ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/x64-windows/yyjson.lib");
        }
        platform linux {
            compile_cmd = concat_c(compile_cmd, " ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/lib-linux/libyyjson.a");
        }
        platform macos {
            compile_cmd = concat_c(compile_cmd, " ");
            compile_cmd = concat(compile_cmd, toolchain_root);
            compile_cmd = concat_c(compile_cmd, "/external/lib-macos/libyyjson.a");
        }
    }
    
    val link_libs: ref StringList = get_link_libraries();
    if link_libs != nil {
        mut ll_idx: i32 = 0;
        loop {
            if ll_idx >= len(deref(link_libs)) {
                break;
            }
            compile_cmd = concat_c(compile_cmd, " -l");
            compile_cmd = concat(compile_cmd, link_libs.data[ll_idx]);
            ll_idx++;
        }
    }
    
    if !::is_release_build {
        platform windows {
            compile_cmd = concat_c(compile_cmd, " -gcodeview -fuse-ld=lld -Xlinker /debug -ldbghelp");
        }
        platform posix {
            compile_cmd = concat_c(compile_cmd, " -g");
        }
    }
    
    val compile_only: bool = get_compile_only();
    if compile_only {
        compile_cmd = concat(compile_cmd, str(" -Wno-everything -O0 -c -o "));
    } else {
        compile_cmd = concat(compile_cmd, str(" -Wno-everything -O0 -o "));
    }
    compile_cmd = concat(compile_cmd, exe_filename);
    
    val result: ExecResult = exec_capture(compile_cmd);
    val exit_code: i32 = result.exit_code;

    if exit_code != 0 {
        filter_and_print_errors(result.output);
        return false;
    }

    val keep_file: bool = ::keep_emitted_file;

    if keep_file {
        if !::quiet_mode {
            println "Keeping emitted C.";
        }
    } else {
        delete_file(c_filename);
    }
    
    if !::quiet_mode {
        println "Compiled.";
    }
    
    val do_run: bool = ::run_after_compile;
    if do_run {
        mut run_cmd: string = exe_filename;
        if !str_contains_c(exe_filename, "/") and !has_prefix(exe_filename, str("./")) {
            run_cmd = concat(str("./"), exe_filename);
        }

        if !::quiet_mode {
            println(concat(str("Running: "), run_cmd));
            println("");
        }

        val run_code: i32 = exec(run_cmd.data);
        if !::quiet_mode {
            println(concat(str("Exit code: "), i32_to_string(run_code)));
        }
    }
    
    return true;
}

/// Replace file extension
def replace_extension(filename: string, new_ext: string): string {
    val len: i32 = str_len(filename);
    mut i: i32 = len - 1;
    
    loop {
        if i < 0 {
            break;
        }
        
        val ch: char = get_char(filename, i);
        if ch == '.' {
            val base: string = substring_se(filename, 0, i);
            return concat(base, new_ext);
        }
        
        i--;
    }
    
    return concat(filename, new_ext);
}

/// Get the output filename with platform-appropriate suffix
def get_output_filename(specified_output: string, input_filename: string): string {
    mut result: string = str("");
    val is_shared: bool = ::build_shared_lib;
    val compile_only: bool = get_compile_only();
    
    if str_len(specified_output) > 0 {
        result = specified_output;
    } else {
        if compile_only {
            platform windows {
                result = replace_extension(input_filename, str(".obj"));
            }
            platform posix {
                result = replace_extension(input_filename, str(".o"));
            }
        } elif is_shared {
            platform windows {
                result = replace_extension(input_filename, str(".dll"));
            }
            platform posix {
                result = replace_extension(input_filename, str(".so"));
            }
        } else {
            platform windows {
                result = replace_extension(input_filename, str(".exe"));
            }
            platform posix {
                result = replace_extension(input_filename, str(""));
            }
        }
    }
    
    platform windows {
        if compile_only {
            if !has_suffix(result, str(".obj")) {
                result = concat(result, str(".obj"));
            }
        } elif is_shared {
            if !has_suffix(result, str(".dll")) {
                result = concat(result, str(".dll"));
            }
        } else {
            if !has_suffix(result, str(".exe")) {
                result = concat(result, str(".exe"));
            }
        }
    }
    
    platform posix {
        if compile_only {
            if !has_suffix(result, str(".o")) {
                result = concat(result, str(".o"));
            }
        } elif is_shared and !has_suffix(result, str(".so")) {
            result = concat(result, str(".so"));
        }
    }
    
    platform windows {
        result = replace_all(result, str("/"), str("\\"));
    }
    return result;
}

/// Return true if we should link against OpenMP.
///
/// Conditions:
///   - The AST contains parallel constructs (blocks/loops), or
///   - The root module imports std.parallelism, or
///   - We are compiling the parallelism.axe module itself.
def should_link_openmp(ast: ref ASTNode, filename: string): bool {
    if has_suffix(filename, str("parallelism.axe")) {
        return true;
    }

    if has_parallel_blocks(ast) {
        return true;
    }

    if ast == nil {
        return false;
    }

    val node_type: string = ast.node_type;
    if equals_c(node_type, "Use") {
        val mod_name: string = ast.data.use_node.module_name;
        if equals_c(mod_name, "std.parallelism") {
            return true;
        }
    }

    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            if should_link_openmp(addr(children.data[i]), filename) {
                return true;
            }
            i++;
        }
    }

    return false;
}

/// Check if AST contains parallel blocks
def has_parallel_blocks(ast: ref ASTNode): bool {
    if ast == nil {
        return false;
    }
    
    val node_type: string = ast.node_type;
    
    if equals_c(node_type, "ParallelFor") {
        return true;
    }
    
    if equals_c(node_type, "Parallel") {
        return true;
    }
    
    if equals_c(node_type, "ParallelLocal") {
        return true;
    }
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            } 
            if has_parallel_blocks(addr(children.data[i])) {
                return true;
            }       
            i++;
        }
    }
    
    return false;
}

/// Collect model names from AST
def collect_model_names(ast: ref ASTNode) {
    if ast == nil {
        return;
    }
    
    val node_type: string = ast.node_type;
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            
            collect_model_names(addr(children.data[i]));
            i++;
        }
    }
}

/// Collect declared functions from AST
def collect_declared_functions(ast: ref ASTNode) {
    if ast == nil {
        return;
    }
    
    val node_type: string = ast.node_type;
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            
            collect_declared_functions(addr(children.data[i]));
            i++;
        }
    }
}

test {
    println "\nTest 1: Replace extension";
    
    assert equals_c(replace_extension(str("test.axe"), str(".c")), "test.c"), "Expected test.c";
    assert equals_c(replace_extension(str("file.txt"), str(".exe")), "file.exe"), "Expected file.exe";
    assert equals_c(replace_extension(str("noext"), str(".c")), "noext.c"), "Expected noext.c";
    
    println "\nTest 2: Has parallel blocks (negative)";
    mut simple_ast: ASTNode;
    simple_ast.node_type = str("Program");
    simple_ast.children = nil;

    assert !has_parallel_blocks(addr(simple_ast)), "Expected no parallel blocks";
    
    println "\nTest 3: Collect model names";
    mut model_ast: ASTNode;
    model_ast.node_type = str("Model");
    model_ast.data.model_node.name = str("TestModel");
    model_ast.children = nil;

    collect_model_names(addr(model_ast));

    println "\nTest 4: to_c_identifier for root function and enum prefixes";
    assert string_equals(str("_1__test"), to_c_identifier(str("1-_test"))), "Expected 1-_test to normalize to _1__test";
}
