use std.io (
    println,
    print
);

use std.string (
    concat,
    i32_to_string,
    str
);

use std.errors (
    error,
    panic
);

/// Arena for memory allocation.
pub model Arena {
    buffer: usize;
    capacity: usize;
    offset: usize;

    /// Creates a new arena with the specified size.
    pub def create(size: usize): Arena {
        mut arena: Arena;
        
        unsafe {
            arena.buffer = C.malloc(size * 100);
            if arena.buffer == 0 {
                panic(error.create(
                    concat(str("Arena: failed to allocate "),
                    i32_to_string(cast[i32](size * 100))).data
                ));
            }
            arena.capacity = size * 100;
            arena.offset = 0;
        }
        
        return arena;
    }

    /// Destroys the arena and frees its memory.
    pub def destroy(arena: ref Arena) {
        unsafe {
            C.free(cast[ref void](arena*.buffer));
            arena*.buffer = 0;
            arena*.offset = 0;
            arena*.capacity = 0;
        }
    }

    /// Allocates memory from the arena, returns a proper reference pointer.
    pub def alloc(arena: ref Arena, size: usize): ref void {
        mut result: ref void = nil;

        unsafe {
            if (arena*.offset + size > arena*.capacity) {
                mut msg: string = str("Arena out of memory! cap=");
                msg = concat(msg, i32_to_string(arena*.capacity));
                msg = concat_c(msg, " used=");
                msg = concat(msg, i32_to_string(arena*.offset));
                msg = concat_c(msg, " req=");
                msg = concat(msg, i32_to_string(size));
                msg = concat_c(msg, "\n");
                panic(error.create(msg.data));
                return nil;
            }
            result = cast[ref void](arena*.buffer + arena*.offset);
            arena*.offset = arena*.offset + size;
            arena*.offset = (arena*.offset + 7) & ~7;
        }

        return result;
    }

    /// Allocates memory for an array from the arena.
    pub def alloc_array(arena: ref Arena, element_size: usize, count: usize): ref void {
        val total_size: usize = element_size * count;
        return Arena.alloc(arena, total_size);
    }

    /// Resets the arena, clearing all allocated memory.
    pub def reset(arena: ref Arena) {
        unsafe {
            arena*.offset = 0;
            C.memset(cast[ref void](arena*.buffer), 0, arena*.capacity);
        }
    }

    /// Returns the amount of memory used by the arena.
    pub def used(arena: ref Arena): i32 {
        mut result: i32 = 0;
        unsafe {
            result = arena*.offset;
        }
        return result;
    }

    /// Returns the amount of remaining memory in the arena.
    pub def remaining(arena: ref Arena): usize {
        mut result: usize = 0;
        unsafe {
            result = (arena*.capacity) - (arena*.offset);
        }
        return result;
    }
}

test {
    assert(Arena.create(1024).capacity == 102400, "Arena.create should set capacity correctly");
    assert(Arena.create(2048).offset == 0, "new arena should have offset 0");
}
