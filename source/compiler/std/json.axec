use std.string (
    string
);

use external("yyjson.h");

pub val JSON_TYPE_NULL: i32 = 0;
pub val JSON_TYPE_BOOL: i32 = 1;
pub val JSON_TYPE_NUM: i32 = 2;
pub val JSON_TYPE_STR: i32 = 3;
pub val JSON_TYPE_ARR: i32 = 4;
pub val JSON_TYPE_OBJ: i32 = 5;

extern def yyjson_read(json: char*, size: size_t, flags: i32): char*;
extern def yyjson_doc_free(doc: char*);
extern def yyjson_doc_get_root(doc: char*): char*;
extern def yyjson_is_null(value: char*): bool;
extern def yyjson_is_bool(value: char*): bool;
extern def yyjson_is_num(value: char*): bool;
extern def yyjson_is_str(value: char*): bool;

/// Parse a JSON string and return a document
pub def parse_json(json_str: string): ref char {
    mut doc: ref char = nil;
    doc = cast[ref char](yyjson_read(json_str.data, json_str.len, 0));
    return doc;
}

/// Free a JSON document
pub def free_json_doc(doc: ref char) {
    if doc != nil {
        yyjson_doc_free(cast[ref yyjson_doc](doc));
    }
}

/// Get the root value from a JSON document
pub def json_get_root(doc: ref char): ref char {
    mut root: ref char = nil;
    if doc != nil {
        root = cast[ref char](yyjson_doc_get_root(cast[ref yyjson_doc](doc)));
    }
    return root;
}

/// Check if a value is null
pub def is_null(value: ref char): bool {
    mut result: bool = false;
    if value != nil {
        result = yyjson_is_null(cast[ref yyjson_val](value));
    }
    return result;
}

/// Check if a value is a boolean
pub def json_is_bool(value: ref char): bool {
    mut result: bool = false;
    if value != nil {
        result = yyjson_is_bool(cast[ref yyjson_val](value));
    }
    return result;
}

/// Check if a value is a number
pub def json_is_num(value: ref char): bool {
    mut result: bool = false;
    if value != nil {
        result = yyjson_is_num(cast[ref yyjson_val](value));
    }
    return result;
}

/// Check if a value is a string
pub def json_is_str(value: ref char): bool {
    mut result: bool = false;
    if value != nil {
        result = yyjson_is_str(cast[ref yyjson_val](value));
    }
    return result;
}

extern def yyjson_is_arr(value: ref char): bool;

/// Check if a value is an array
pub def json_is_array(value: ref char): bool {
    mut result: bool = false;
    if value != nil {
        result = yyjson_is_arr(cast[ref yyjson_val](value));
    }
    return result;
}

extern def yyjson_is_obj(value: ref char): bool;

/// Check if a value is an object
pub def json_is_object(value: ref char): bool {
    mut result: bool = false;
    if value != nil {
        result = yyjson_is_obj(cast[ref yyjson_val](value));
    }
    return result;
}

extern def yyjson_get_bool(value: ref char): bool;

/// Get boolean value
pub def json_get_bool(value: ref char): bool {
    mut result: bool = false;
    if value != nil {
        result = yyjson_get_bool(cast[ref yyjson_val](value));
    }
    return result;
}

extern def yyjson_get_int(value: ref char): i32;

/// Get integer value
pub def json_get_int(value: ref char): i32 {
    mut result: i32 = 0;
    if value != nil {
        result = yyjson_get_int(cast[ref yyjson_val](value));
    }
    return result;
}

extern def yyjson_get_sint(value: ref char): i64;

/// Get 64-bit integer value
pub def json_get_int64(value: ref char): i64 {
    mut result: i64 = 0;
    if result != nil {
        result = yyjson_get_sint(cast[ref yyjson_val](value));
    }
    return result;
}

extern def yyjson_get_real(value: ref char): f64;

/// Get floating point value
pub def json_get_real(value: ref char): f64 {
    mut result: f64 = 0.0;
    if value != nil {
        result = yyjson_get_real(cast[ref yyjson_val](value));
    }
    return result;
}

extern def yyjson_get_str(value: ref char): ref char;
extern def yyjson_get_len(value: ref char): usize;
extern def yyjson_arr_get_first(arr: ref char): ref char;

/// Get string value
pub def json_get_str(value: ref char): string {
    mut result: string;

    result.data = nil;
    result.len = 0;
    result.cap = 0;

    if value != nil {
        val str: ref char = yyjson_get_str(cast[ref yyjson_val](value));
        if str != nil {
            mut length: usize = yyjson_get_len(cast[ref yyjson_val](value));
            result.data = cast[ref char](C.malloc(length + 1));
            if result.data != nil {
                C.memcpy(result.data, str, length);
                result.data[length] = '\0';
                result.len = length;
                result.cap = length + 1;
            }
        }
    }
    return result;
}

/// Get the length of an array or object
pub def json_get_len(value: ref char): usize {
    mut result: usize = 0;
    if value != nil {
        result = yyjson_get_len(cast[ref yyjson_val](value));
    }
    return result;
}

/// Get a value from an object by key
pub def json_obj_get(obj: ref char, key: string): ref char {
    mut result: ref char = nil;
    if obj != nil && key.data != nil {
        result = yyjson_obj_get(cast[ref yyjson_val](obj), key.data);
    }
    return result;
}

/// Get a value from an array by index
pub def json_arr_get(arr: ref char, idx: usize): ref char {
    mut result: ref char = nil;
    if arr != nil {
        result = yyjson_arr_get(cast[ref yyjson_val](arr), idx);
    }
    return result;
}

/// Get the first element in an array
pub def json_arr_get_first(arr: ref char): ref char {
    mut result: ref char = nil;
    if arr != nil {
        result = yyjson_arr_get_first(cast[ref yyjson_val](arr));
    }
    return result;
}

/// Get the last element in an array
pub def json_arr_get_last(arr: ref char): ref char {
    mut result: ref char = nil;
    if arr != nil {
        result = yyjson_arr_get_last(cast[ref yyjson_val](arr));
    }
    return result;
}

/// Serialize a JSON document to a string
pub def stringify(doc: ref char): string {
    mut result: string;
    result.data = nil;
    result.len = 0;
    result.cap = 0;
    if doc != nil {
        mut len: usize;
        val json: ref char = yyjson_write(cast[ref yyjson_doc](doc), 0, addr(len));
        if json != nil {
            result.data = json;
            result.len = len;
            result.cap = len + 1;
        }
    }
    return result;
}

/// Serialize a JSON value to a string
pub def stringify_val(value: ref char): string {
    mut result: string;

    result.data = nil;
    result.len = 0;
    result.cap = 0;
    
    if value != nil {
        mut len: usize;
        val json: ref char = yyjson_val_write(cast[ref yyjson_val](value), 0, addr(len));
        if json != nil {
            result.data = json;
            result.len = len;
            result.cap = len + 1;
        }
    }
    return result;
}

/// Serialize with pretty formatting
pub def stringify_pretty(doc: ref char): string {
    mut result: string;
    result.data = nil;
    result.len = 0;
    result.cap = 0;

    foreign {YYJSON_WRITE_PRETTY};

    if doc != nil {
        mut len: usize;
        val json: ref char = yyjson_write(cast[ref yyjson_doc](doc), YYJSON_WRITE_PRETTY, addr(len));
        if json != nil {
            result.data = json;
            result.len = len;
            result.cap = len + 1;
        }
    }
    return result;
}

/// Read JSON from a file
pub def read_json_file(path: string): ref char {
    mut doc: ref char = nil;
    if path.data != nil {
        doc = cast[ref char](yyjson_read_file(path.data, 0, nil, nil));
    }
    return doc;
}

/// Write JSON to a file
pub def write_json_file(path: string, doc: ref char): bool {
    mut success: bool = false;
    if path.data != nil and doc != nil {
        success = yyjson_write_file(path.data, cast[ref yyjson_doc](doc), 0, nil, nil);
    }
    return success;
}

test {
    mut json_str: string = string.create("{\"name\":\"John\",\"age\":30,\"active\":true}");
    mut doc: ref char = parse_json(json_str);
    
    assert doc != nil, "Should parse valid JSON";
    
    if doc != nil {
        mut root: ref char = json_get_root(doc);
        assert root != nil, "Should get root value";
        assert json_is_object(root), "Root should be an object";
        
        mut name_val: ref char = json_obj_get(root, string.create("name"));
        assert name_val != nil, "Should find 'name' key";
        assert json_is_str(name_val), "name should be a string";
        
        mut name: string = json_get_str(name_val);
        assert name.len > 0, "Should get string value";
        
        mut age_val: ref char = json_obj_get(root, string.create("age"));
        assert age_val != nil, "Should find 'age' key";
        assert json_is_num(age_val), "age should be a number";
        
        mut age: i32 = json_get_int(age_val);
        assert age == 30, "age should be 30";
        
        mut active_val: ref char = json_obj_get(root, string.create("active"));
        assert active_val != nil, "Should find 'active' key";
        assert json_is_bool(active_val), "active should be a boolean";
        
        mut active: bool = json_get_bool(active_val);
        assert active, "active should be true";
        
        free_json_doc(doc);
    }
    
    mut arr_str: string = string.create("[1,2,3,4,5]");
    mut arr_doc: ref char = parse_json(arr_str);
    
    assert arr_doc != nil, "Should parse JSON array";
    
    if arr_doc != nil {
        mut arr_root: ref char = json_get_root(arr_doc);
        assert json_is_array(arr_root), "Root should be an array";
        
        mut len: usize = json_get_len(arr_root);
        assert len == 5, "Array should have 5 elements";
        
        mut first: ref char = json_arr_get(arr_root, cast[usize](0));
        assert json_is_num(first), "First element should be a number";
        assert json_get_int(first) == 1, "First element should be 1";
        
        free_json_doc(arr_doc);
    }
}
