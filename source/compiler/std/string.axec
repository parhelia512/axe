use std.lists (
    StringList
);

use std.typecons (
    Any,
    AnyKind
);

use std.arena (
    Arena
);

use std.io;

/// StringBuilder for efficient string concatenation.
/// Instead of O(n²) repeated allocations, uses amortized O(1) appends.
pub model StringBuilder {
    data: char*;
    len: usize;
    cap: usize;

    /// Creates a new StringBuilder with the specified initial capacity.
    pub def init(initial_capacity: usize): StringBuilder {
        mut sb: StringBuilder;
        unsafe {
            sb.cap = initial_capacity;
            if sb.cap < 64 {
                sb.cap = 64;
            }
            sb.data = C.malloc(sb.cap);
            sb.len = 0;
            if sb.data != nil {
                sb.data[0] = '\0';
            }
        }
        return sb;
    }

    /// Ensures the StringBuilder has enough capacity for additional bytes.
    pub def ensure_capacity(sb: ref StringBuilder, additional: usize): void {
        val needed: usize = sb*.len + additional + 1;
        if needed <= sb*.cap {
            return;
        }
        mut new_cap: usize = sb*.cap;
        loop {
            if new_cap >= needed {
                break;
            }
            new_cap = new_cap * 2;
        }
        unsafe {
            val new_data: char* = C.realloc(sb*.data, new_cap);
            if new_data != nil {
                sb*.data = new_data;
                sb*.cap = new_cap;
            }
        }
    }

    /// Appends a string to the StringBuilder.
    pub def append(sb: ref StringBuilder, s: string): void {
        if s.len == 0 {
            return;
        }
        StringBuilder.ensure_capacity(sb, s.len);
        unsafe {
            C.memcpy(sb*.data + sb*.len, s.data, s.len);
            sb*.len = sb*.len + s.len;
            sb*.data[sb*.len] = '\0';
        }
    }

    /// Appends a C string literal to the StringBuilder.
    pub def append_c(sb: ref StringBuilder, s: ref char): void {
        unsafe {
            val s_len: usize = C.strlen(s);
            if s_len == 0 {
                return;
            }
            StringBuilder.ensure_capacity(sb, s_len);
            C.memcpy(sb*.data + sb*.len, s, s_len);
            sb*.len = sb*.len + s_len;
            sb*.data[sb*.len] = '\0';
        }
    }

    /// Appends a single character to the StringBuilder.
    /// Inlined capacity check for performance.
    pub def append_char(sb: ref StringBuilder, c: char): void {
        unsafe {
            val needed: usize = sb*.len + 2;
            if needed > sb*.cap {
                mut new_cap: usize = sb*.cap;
                loop {
                    if new_cap >= needed {
                        break;
                    }
                    new_cap = new_cap * 2;
                }
                val new_data: char* = C.realloc(sb*.data, new_cap);
                if new_data != nil {
                    sb*.data = new_data;
                    sb*.cap = new_cap;
                }
            }
            sb*.data[sb*.len] = c;
            sb*.len = sb*.len + 1;
            sb*.data[sb*.len] = '\0';
        }
    }

    /// Converts the StringBuilder to a string.
    /// The StringBuilder remains valid and can continue to be used.
    pub def to_string(sb: ref StringBuilder): string {
        mut result: string;
        unsafe {
            result.data = C.malloc(sb*.len + 1);
            if result.data != nil {
                C.memcpy(result.data, sb*.data, sb*.len + 1);
                result.len = sb*.len;
                result.cap = sb*.len + 1;
            } else {
                result.data = nil;
                result.len = 0;
                result.cap = 0;
            }
        }
        return result;
    }

    /// Clears the StringBuilder without deallocating memory.
    pub def clear(sb: ref StringBuilder): void {
        sb*.len = 0;
        if sb*.data != nil {
            sb*.data[0] = '\0';
        }
    }

    /// Destroys the StringBuilder and frees memory.
    pub def destroy(sb: ref StringBuilder): void {
        unsafe {
            C.free(sb*.data);
            sb*.data = nil;
            sb*.len = 0;
            sb*.cap = 0;
        }
    }
}

/// string model representing a dynamic string with length tracking.
pub model string {
    data: char*;
    len: usize;
    cap: usize;

    /// Creates a new string from a char pointer.
    pub def create(data: char*): string {
        mut result: string;
        unsafe {
            result.data = nil;
            result.len  = 0;
            result.cap  = 0;
            val len: usize = C.strlen(data);
            result.data = C.malloc(len + 1);

            if result.data != nil {
                C.memcpy(result.data, data, len + 1);
                result.len = len;
                result.cap = len + 1;
            }
        }
        return result;
    }

    /// Creates a new empty string with specified capacity using arena allocation.
    pub def create_with_capacity(arena: ref Arena, capacity: i32): string {
        mut result: string = str("");
        result.data = nil;
        result.len = 0;
        result.cap = 0;

        if capacity > 0 {
            result.data = cast[char*](Arena.alloc(arena, capacity + 1));
            if result.data != nil {
                result.data[0] = '\0';
                result.len = 0;
                result.cap = capacity + 1;
            }
        }
        return result;
    }

    pub def destroy(s: ref string) {
        unsafe {
            C.free((void*)s*.data);
            s*.data = nil;
            s*.len = 0;
            s*.cap = 0;
        }
    }
}

/// Replace all non-overlapping occurrences of `from` in `s` with `to`.
/// Optimized to use StringBuilder instead of O(n²) repeated concatenations.
pub def replace_all(s: string, from: string, dest: string): string {
    if str_len(from) == 0 {
        return substring_se(s, 0, str_len(s));
    }

    mut sb: StringBuilder = StringBuilder.init(s.len + 64);
    mut i: i32 = 0;
    val n: i32 = cast[i32](str_len(s));
    val from_len: i32 = cast[i32](str_len(from));

    loop {
        if i >= n {
            break;
        }

        mut j: i32 = 0;
        mut match: bool = true;

        loop {
            if j >= from_len {
                break;
            }
            if i + j >= n {
                match = false;
                break;
            }
            val ch_s: char = get_char(s, i + j);
            val ch_f: char = get_char(from, j);
            if ch_s != ch_f {
                match = false;
                break;
            }
            j++;
        }

        if match {
            StringBuilder.append(addr(sb), dest);
            i += from_len;
        } else {
            StringBuilder.append_char(addr(sb), get_char(s, i));
            i++;
        }
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Convert some i32 to a string.
pub def i32_to_string(value: i32): string {
    unsafe {
        mut buffer: char* = C.malloc(12);
        C.sprintf(buffer, "%d", value);
        return string.create(buffer);
    }
}

/// Returns the length of a string.
pub def str_len(s: string): usize {
    return s.len;
}

/// Convert some string to titlecase.
pub def to_title_case(s: string): string {
    mut result: string;
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;

        val len: usize = s.len;
        result.data = C.malloc(len + 1);

        if result.data != nil {
            mut i: usize = 0;
            loop {
                if i >= len {
                    break;
                }
                val ch: i32 = cast[i32](s.data[i]);
                if i == 0 or C.isalpha(cast[i32](s.data[i - 1])) == 0 {
                    result.data[i] = cast[char](C.toupper(ch));
                } else {
                    result.data[i] = cast[char](C.tolower(ch));
                }
                i++;
            }
            result.data[len] = '\0';
            result.len = len;
            result.cap = len + 1;
        }
    }
    return result;
}

/// Converts string to uppercase.
pub def to_upper(s: string): string {
    mut result: string;
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;

        val len: usize = s.len;
        result.data = C.malloc(len + 1);

        if result.data != nil {
            mut i: usize = 0;
            loop {
                if i >= len {
                    break;
                }
                val ch: i32 = cast[i32](s.data[i]);
                result.data[i] = cast[char](C.toupper(ch));
                i++;
            }
            result.data[len] = '\0';
            result.len = len;
            result.cap = len + 1;
        }
    }
    return result;
}

/// Converts string to lowercase.
pub def to_lower(s: string): string {
    mut result: string;
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;

        val len: usize = s.len;
        result.data = C.malloc(len + 1);

        if result.data != nil {
            mut i: usize = 0;
            loop {
                if i >= len {
                    break;
                }
                val ch: i32 = cast[i32](s.data[i]);
                result.data[i] = cast[char](C.tolower(ch));
                i++;
            }
            result.data[len] = '\0';
            result.len = len;
            result.cap = len + 1;
        }
    }
    return result;
}

/// Copies source string to destination. Modifies dest in place.
pub def str_copy(src: string, desta: mut string): void {
    for mut i = 0; i < src.len; i++ {
        desta.data[i] = src.data[i];
    }
}

/// Concatenates a character to the end of a string. Returns the modified string.
/// Mut here just means that the stack instance is mutable, not that the string data itself is modified in place.
def concat_chr(a: mut string, b: char): string {
    unsafe {
        mut new_len: usize = a.len + 1;
        mut new_data: char* = C.malloc(new_len + 1);
        if (new_data != NULL) {
            if (a.len > 0) {
                C.memcpy(new_data, a.data, a.len);
            }
            new_data[a.len] = b;
            new_data[new_len] = '\0';
            C.free(a.data);
            a.data = new_data;
            a.len = new_len;
            a.cap = new_len + 1;
        }
    }
    return a;
}

/// Returns a substring from start to end (exclusive).
///
/// Optimized to use direct memory allocation instead of O(n²) concat_chr calls.
pub def substring_se(s: string, start: i32, end: i32): string {
    mut result: string;
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;
        
        if start >= end or start < 0 {
            return result;
        }
        
        val s_len: i32 = cast[i32](s.len);
        mut actual_end: i32 = end;
        if actual_end > s_len {
            actual_end = s_len;
        }
        if start >= actual_end {
            return result;
        }
        
        val len: usize = cast[usize](actual_end - start);
        result.data = C.malloc(len + 1);
        if result.data != nil {
            C.memcpy(result.data, s.data + start, len);
            result.data[len] = '\0';
            result.len = len;
            result.cap = len + 1;
        }
    }
    return result;
}

/// Returns a substring from start to end (exclusive).
pub def substring_scse(s: string, start: i32, end: i32): char* {
    unsafe {
        mut len: i32 = end - start;
        mut result: char* = C.malloc(len + 1);
        if (result != nil) {
            C.memcpy(result, s.data + start, len);
            result[len] = '\0';
        }
        return result;
    }
}

/// Returns a substring from char* s from start to end (exclusive). 
/// Caller must free the result.
pub def substring_cse(s: char*, start: i32, end: i32): char* {
    unsafe {
        mut len: i32 = end - start;
        mut result: char* = C.malloc(len + 1);
        if (result != nil) {
            C.memcpy(result, s + start, len);
            result[len] = '\0';
        }
        return result;
    }
}

/// Compares string with char*. Returns 0 if equal.
pub def equals_c(a: string, b: ref char): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.strcmp((char*)a.data, (char*)b);
    }
    return result == 0;
}

/// Compares two strings. Returns 0 if equal.
pub def compare(a: string, b: string): i32 {
    mut len: usize = 0;

    if a.len < b.len {
        len = a.len;
    } else {
        len = b.len;
    }

    for mut i = 0; i < len; i++ {
        if a.data[i] < b.data[i] { return -1; }
        if a.data[i] > b.data[i] { return 1; }
    }

    if a.len < b.len { return -1; }
    if a.len > b.len { return 1; }

    return 0;
}

/// Checks if two strings are equal. Returns true if equal.
pub def string_equals(a: string, b: string): bool {
    return compare(a, b) == 0;
}

/// Concatenates a char pointer to a string
pub def concat_c(original: string, addon: ref char): string {
    mut result: string = str("");
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;
        
        val addon_len: usize = C.strlen(addon);
        val new_len: usize = original.len + addon_len;
        
        result.data = C.malloc(new_len + 1);
        if result.data != nil {
            if original.len > 0 {
                C.memcpy(result.data, original.data, original.len);
            }
            if addon_len > 0 {
                C.memcpy(result.data + original.len, addon, addon_len);
            }
            result.data[new_len] = '\0';
            result.len = new_len;
            result.cap = new_len + 1;
        }
    }
    return result;
}

/// Concatenates source string to destination. Returns a new string.
pub def concat(dest: string, src: string): string {
    mut result: string;
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;

        val new_len: usize = dest.len + src.len;
        result.data = C.malloc(new_len + 1);

        if result.data != nil {
            if dest.len > 0 {
                C.memcpy(result.data, dest.data, dest.len);
            }
            if src.len > 0 {
                C.memcpy(result.data + dest.len, src.data, src.len);
            }
            result.data[new_len] = '\0';
            result.len = new_len;
            result.cap = new_len + 1;
        }
    }
    return result;
}

/// Finds first occurrence of character in string. Returns pointer or 0.
pub def first_occurrence(s: string, c: i32): char* {
    mut result: char* = nil;
    unsafe {
        result = C.strchr(s.data, c);
    }
    return result;
}

/// Finds first occurrence of substring in string. Returns pointer or 0.
pub def substring(haystack: string, needle: string): char* {
    mut result: char* = nil;
    unsafe {
        result = C.strstr(haystack.data, needle.data);
    }
    return result;
}

/// Checks if string contains substring.
pub def str_contains(s: string, substr: string): bool {
    return substring(s, substr) != 0;
}

/// Checks if string contains substring.
pub def str_contains_c(s: string, substr: char*): bool {
    return substring(s, str(substr)) != 0;
}

/// Converts string to integer.
pub def str_to_int(s: string): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.atoi(s.data);
    }
    return result;
}

/// Converts string to long integer.
pub def str_to_long(s: char*): i64 {
    mut result: i64 = 0;
    unsafe {
        result = C.atol(s);
    }
    return result;
}

/// Checks if character is alphabetic.
pub def is_alpha(c: i32): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.isalpha(c);
    }
    return result;
}

/// Checks if character is numeric.
pub def is_digit(c: i32): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.isdigit(c);
    }
    return result;
}

/// Checks if character is alphanumeric.
pub def is_alphanum(c: i32): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.isalnum(c);
    }
    return result;
}

/// Converts char* to uppercase.
pub def to_upper_chrptr(s: char*): char* {
    mut result: char* = nil;
    unsafe {
        val len: usize = C.strlen(s);
        result = C.malloc(len + 1);
        if result != nil {
            C.strcpy(result, s);
            mut i: usize = 0;
            loop {
                if i >= len {
                    break;
                }
                val ch: i32 = cast[i32](result[i]);
                result[i] = cast[char](C.toupper(ch));
                i++;
            }
        }
    }
    return result;
}

/// Converts char* to lowercase.
pub def to_lower_chrptr(s: char*): char* {
    mut result: char* = nil;
    unsafe {
        val len: usize = C.strlen(s);
        result = C.malloc(len + 1);
        if result != nil {
            C.strcpy(result, s);
            mut i: usize = 0;
            loop {
                if i >= len {
                    break;
                }
                val ch: i32 = cast[i32](result[i]);
                result[i] = cast[char](C.tolower(ch));
                i++;
            }
        }
    }
    return result;
}

/// Converts character to uppercase.
pub def to_upper_chr(c: i32): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.toupper(c);
    }
    return result;
}

/// Converts character to lowercase.
pub def to_lower_chr(c: i32): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.tolower(c);
    }
    return result;
}

/// Allocates and copies a string. Caller must free the result.
pub def str_dup(s: char*): char* {
    mut result: char* = nil;
    unsafe {
        val len: usize = C.strlen(s);
        result = C.malloc(len + 1);
        if result != nil {
            C.strcpy(result, s);
        }
    }
    return result;
}

/// Compares first n characters of two strings. Returns 0 if equal.
pub def str_ncmp(s1: char*, s2: char*, n: i32): i32 {
    mut result: i32 = 0;
    unsafe {
        result = C.strncmp(s1, s2, cast[usize](n));
    }
    return result;
}

/// Copies at most n characters from source to destination.
pub def str_ncopy(dest: char*, src: char*, n: i32): char* {
    mut result: char* = nil;
    unsafe {
        result = C.strncpy(dest, src, cast[usize](n));
    }
    return result;
}

/// Converts an integer to a string. Buffer must be at least 12 bytes.
pub def int_to_str(value: i32, buffer: ref char): char* {
    unsafe {
        C.sprintf(buffer, "%d", value);
    }
    return buffer;
}

/// Converts a long to a string. Buffer must be at least 21 bytes.
pub def long_to_str(value: i64, buffer: char*): char* {
    unsafe {
        C.sprintf(buffer, "%ld", value);
    }
    return buffer;
}

/// Converts a float to a string. Buffer must be at least 32 bytes.
pub def float_to_str(value: f32, buffer: char*): char* {
    unsafe {
        C.sprintf(buffer, "%f", value);
    }
    return buffer;
}

/// Converts a double to a string. Buffer must be at least 32 bytes.
pub def double_to_str(value: f64, buffer: char*): char* {
    unsafe {
        C.sprintf(buffer, "%lf", value);
    }
    return buffer;
}

/// Returns the character at position `pos` in string `s`.
pub def get_char(s: string, pos: i32): char {
    return s.data[pos];
}

/// Returns the index of the first occurrence of character `c` in `s` at or after `start`.
/// Returns -1 if the character is not found.
pub def find_char_from(s: string, c: char, start: usize): i32 {
    if start >= s.len {
        return -1;
    }
    mut i: usize = start;
    loop {
        if i >= s.len {
            break;
        }
        if s.data[i] == c {
            return cast[i32](i);
        }
        i++;
    }
    return -1;
}

/// Returns the index of the last occurrence of character `c` in `s`.
/// Returns -1 if the character is not found.
pub def find_last_char(s: string, c: char): i32 {
    if s.len == 0 {
        return -1;
    }
    mut i: usize = s.len - 1;
    loop {
        if s.data[i] == c {
            return cast[i32](i);
        }
        if i == 0 {
            break;
        }
        i--;
    }
    return -1;
}

/// Returns the index of the first occurrence of `substr` inside `s`, or -1 if not found.
pub def find_substr(s: string, substr: string): i32 {
    if substr.len == 0 {
        return 0;
    }

    if substr.len > s.len {
        return -1;
    }

    mut i: usize = 0;
    loop {
        if i + substr.len > s.len {
            break;
        }
        mut j: usize = 0;
        mut match_found: bool = true;
        loop {
            if j >= substr.len {
                break;
            }
            if s.data[i + j] != substr.data[j] {
                match_found = false;
                break;
            }
            j++;
        }
        if match_found {
            return cast[i32](i);
        }
        i++;
    }
    return -1;
}

/// Returns a substring of `s` starting at `start` with the given `length`.
/// If `start` is beyond the end of the string or `length` is zero, an empty string is returned.
/// The function clamps the requested range to the bounds of the source string.
pub def substr(s: string, start: i32, length: i32): string {
    mut result: string;
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;

        if start >= s.len or length == 0 {
            return result;
        }
        val max_len: usize = s.len - start;
        mut copy_len: usize = length;
        if copy_len > max_len {
            copy_len = max_len;
        }
        result.data = C.malloc(copy_len + 1);
        if result.data == nil {
            return result;
        }
        C.memcpy(result.data, s.data + start, copy_len);
        result.data[copy_len] = '\0';
        result.len = copy_len;
        result.cap = copy_len + 1;
    }
    return result;
}

/// Checks if string has prefix.
pub def has_prefix(s: string, prefix: string): bool {
    if prefix.len == 0 {
        return true;
    }
    if prefix.len > s.len {
        return false;
    }

    mut i: usize = 0;
    loop {
        if i >= prefix.len {
            break;
        }
        if s.data[i] != prefix.data[i] {
            return false;
        }
        i = i + 1;
    }

    return true;
}

/// Checks if string has suffix.
pub def has_suffix(s: string, suffix: string): bool {
    if suffix.len == 0 {
        return true;
    }
    if suffix.len > s.len {
        return false;
    }

    mut i: usize = 0;
    val start: usize = s.len - suffix.len;
    loop {
        if i >= suffix.len {
            break;
        }
        if s.data[start + i] != suffix.data[i] {
            return false;
        }
        i = i + 1;
    }

    return true;
}

/// Removes prefix from string.
pub def trim_prefix(s: string, prefix: string): string {
    if prefix.len == 0 or prefix.len > s.len {
        return s;
    }

    mut i: usize = 0;
    loop {
        if i >= prefix.len {
            break;
        }
        if s.data[i] != prefix.data[i] {
            return s;
        }
        i = i + 1;
    }

    return substr(s, prefix.len, s.len - prefix.len);
}

/// Removes suffix from string.
pub def trim_suffix(s: string, suffix: string): string {
    if suffix.len == 0 or suffix.len > s.len {
        return s;
    }

    mut i: usize = 0;
    val start: usize = s.len - suffix.len;
    loop {
        if i >= suffix.len {
            break;
        }
        if s.data[start + i] != suffix.data[i] {
            return s;
        }
        i = i + 1;
    }

    return substr(s, 0, s.len - suffix.len);
}

/// Strip leading whitespace from a string.
pub def lstrip(s: string): string {
    if s.len == 0 {
        return s;
    }

    mut start: usize = 0;
    loop {
        if start >= s.len {
            break;
        }
        val ch: char = s.data[start];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            start++;
        } else {
            break;
        }
    }

    if start >= s.len {
        return string.create("");
    }

    return substr(s, start, s.len - start);
}

/// Strip trailing whitespace from a string.
pub def rstrip(s: string): string {
    if s.len == 0 {
        return s;
    }

    mut end: usize = s.len;
    loop {
        if end == 0 {
            break;
        }
        val ch: char = s.data[end - 1];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            end--;
        } else {
            break;
        }
    }

    if end == 0 {
        return string.create("");
    }

    return substr(s, 0, end);
}

/// String trailing and leading whitespace.
pub def strip(s: string): string {
    if s.len == 0 {
        return s;
    }

    mut start: usize = 0;
    loop {
        if start >= s.len {
            break;
        }
        val ch: char = s.data[start];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            start++;
        } else {
            break;
        }
    }

    if start >= s.len {
        return string.create("");
    }

    mut end: usize = s.len;
    loop {
        if end == 0 {
            break;
        }
        val ch: char = s.data[end - 1];
        if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n' {
            end--;
        } else {
            break;
        }
    }
    return substr(s, start, end - start);
}

/// Convenience function to convert a char* to a string.
pub def str(data: char*): string {
    return string.create(data);
}

test {    
    assert(is_alpha(65) != 0, "65 (A) should be alphabetic");
    assert(is_digit(48) != 0, "48 (0) should be a digit");
    assert(is_alphanum(97) != 0, "97 (a) should be alphanumeric");
    assert(to_upper_chr(97) == 65, "to_upper_chr('a') should return A");
    assert(to_lower_chr(65) == 97, "to_lower_chr('A') should return a");
    assert(str_ncmp("hello", "help", 3) == 0, "first 3 chars of hello and help should match");
    
    mut arena: Arena = Arena.create(100);
    mut buffer: char* = cast[ref char](Arena.alloc(addr(arena), 52));
    
    int_to_str(42, buffer);
    assert(str_ncmp(buffer, "42", 2) == 0, "int_to_str(42) should produce 42");
    
    int_to_str(-123, buffer);
    assert(str_ncmp(buffer, "-123", 4) == 0, "int_to_str(-123) should produce -123");
    
    int_to_str(0, buffer);
    assert(str_ncmp(buffer, "0", 1) == 0, "int_to_str(0) should produce 0");
    
    long_to_str(cast[i64](1000), buffer);
    assert(str_ncmp(buffer, "1000", 4) == 0, "long_to_str(1000) should produce 1000");
    
    long_to_str(cast[i64](-9999), buffer);
    assert(str_ncmp(buffer, "-9999", 5) == 0, "long_to_str(-9999) should produce -9999");

    val lower_case_string: string = string.create("hello, world");
    val upper_case_string: string = to_upper(lower_case_string);
    assert(compare(upper_case_string, string.create("HELLO, WORLD")) == 0, "to_upper should convert to uppercase");

    val test_string: string = string.create("hello, world");
    val test_string2: string = string.create("hello, world");

    assert(compare(test_string, test_string2) == 0, "test_string and test_string2 should be equal");
    assert(compare(to_lower(string.create("HELLO WORLD")), string.create("hello world")) == 0, "to_lower should convert to lowercase");

    
    val str1: string = string.create("hello");
    val str2: string = string.create(" world");
    val str3: string = concat(str1, str2);
    assert(compare(str3, string.create("hello world")) == 0, "concat should concatenate strings");

    val str4: string = string.create("hello world");
    val str5: string = trim_prefix(str4, string.create("hello "));
    assert(compare(str5, string.create("world")) == 0, "trim_prefix should remove prefix");

    val str6: string = string.create("hello world");
    val str7: string = trim_suffix(str6, string.create(" world"));
    assert(compare(str7, string.create("hello")) == 0, "trim_suffix should remove suffix");

    val str8: string = string.create("  \thello world   ");
    val str9: string = strip(str8);
    assert(compare(str9, string.create("hello world")) == 0, "strip should remove leading and trailing whitespace");

    val str10: string = string.create("  \thello world   ");
    val str11: string = lstrip(str10);
    assert(compare(str11, string.create("hello world   ")) == 0, "lstrip should remove leading whitespace only");

    val str12: string = string.create("  hello world   \t\n");
    val str13: string = rstrip(str12);
    assert(compare(str13, string.create("  hello world")) == 0, "rstrip should remove trailing whitespace only");

    val base: string = string.create("foobar");
    assert(has_prefix(base, string.create("foo")), "has_prefix should detect valid prefix");
    assert(!has_prefix(base, string.create("bar")), "has_prefix should reject non-prefix");
    assert(has_suffix(base, string.create("bar")), "has_suffix should detect valid suffix");
    assert(!has_suffix(base, string.create("foo")), "has_suffix should reject non-suffix");
    assert(has_prefix(base, string.create("")), "empty prefix should always match");
    assert(has_suffix(base, string.create("")), "empty suffix should always match");
    assert(!has_prefix(base, string.create("foobarbaz")), "longer prefix should not match");
    assert(!has_suffix(base, string.create("foobarbaz")), "longer suffix should not match");

    assert get_char(string.create("hello"), 1) == 'e', "get_char should return correct character";
    assert equals_c(string.create("test"), "test"), "equals_c should return 0 for equal strings";
    assert !equals_c(string.create("test"), "TEST"), "equals_c should return non-zero for different strings";
    assert concat_chr(string.create("Price: "), '$').data != nil, "concat_chr should append character to string";

    assert str_to_int(string.create("12345")) == 12345, "str_to_int should convert string to integer";

    val y = 10;
    
    assert(find_substr(string.create("hello world"), string.create("world")) == 6, "find_substr should find 'world' at index 6");
    assert(find_substr(string.create("hello world"), string.create("hello")) == 0, "find_substr should find 'hello' at index 0");
    assert(find_substr(string.create("abc"), string.create("")) == 0, "find_substr of empty substring should return 0");
    assert(find_substr(string.create("aaaa"), string.create("aa")) == 0, "find_substr should find the first occurrence");
    assert(find_substr(string.create("abc"), string.create("x")) == -1, "find_substr should return -1 when not found");

    // StringBuilder tests
    mut sb: StringBuilder = StringBuilder.init(64);
    StringBuilder.append_c(addr(sb), "Hello");
    StringBuilder.append_c(addr(sb), ", ");
    StringBuilder.append_c(addr(sb), "World!");
    val sb_result: string = StringBuilder.to_string(addr(sb));
    assert(compare(sb_result, string.create("Hello, World!")) == 0, "StringBuilder should concatenate strings");
    
    StringBuilder.clear(addr(sb));
    assert(sb.len == 0, "StringBuilder clear should reset length to 0");
    
    StringBuilder.append(addr(sb), string.create("Test"));
    StringBuilder.append_char(addr(sb), '!');
    val sb_result2: string = StringBuilder.to_string(addr(sb));
    assert(compare(sb_result2, string.create("Test!")) == 0, "StringBuilder append_char should work");
    
    StringBuilder.destroy(addr(sb));
    Arena.destroy(addr(arena));
    print_str(str($"This should be 10 dollars: $ {y}"));
}
