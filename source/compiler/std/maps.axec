use std.lists;
use std.arena;
use std.string;

/// Generic Map using memcmp for key comparison
macro make_map(keytype_elem: untyped, valtype_elem: untyped, mapname: untyped, keytype: untyped, valtype: untyped) {
    pub model mapname {
        keys: ref keytype;
        values: ref valtype;

        pub def create(arena: ref Arena, capacity: i32): ref mapname {
            mut map: ref mapname;
            unsafe {
                map = Arena.alloc(arena, C.sizeof(mapname));
            }
            map.keys = keytype.create(arena, capacity);
            map.values = valtype.create(arena, capacity);
            return map;
        }

        pub def clear(map: ref mapname) {
            map.keys.len = 0;
            map.values.len = 0;
        }
        
        pub def append(map: ref mapname, arena: ref Arena, key: keytype_elem, value: valtype_elem) {
            keytype.push(map.keys, arena, key);
            valtype.push(map.values, arena, value);
        }
        
        pub def add(map: ref mapname, arena: ref Arena, key: keytype_elem, value: valtype_elem) {
            keytype.push(map.keys, arena, key);
            valtype.push(map.values, arena, value);
        }
        
        pub def set(map: ref mapname, arena: ref Arena, key: keytype_elem, value: valtype_elem) {
            mut i: i32 = 0;
            val keys: ref keytype = map.keys;
            mut values: ref valtype = map.values;
            loop {
                if i >= keys.len {
                    break;
                }
                unsafe {
                    if C.memcmp(&(keys*.data[i]), &key, C.sizeof(key)) == 0 {
                        values*.data[i] = value;
                        return;
                    }
                }
                i = i + 1;
            }
            keytype.push(map.keys, arena, key);
            valtype.push(map.values, arena, value);
        }
        
        pub def get(map: ref mapname, key: keytype_elem): valtype_elem {
            mut i: i32 = 0;
            val keys: ref keytype = map.keys;
            val values: ref valtype = map.values;
            loop {
                if i >= keys.len {
                    break;
                }
                unsafe {
                    if C.memcmp(&(keys*.data[i]), &key, C.sizeof(key)) == 0 {
                        return values*.data[i];
                    }
                }
                i = i + 1;
            }
            mut default_val: valtype_elem;
            unsafe {
                C.memset(&default_val, 0, C.sizeof(default_val));
            }
            return default_val;
        }
        
        pub def contains(map: ref mapname, key: keytype_elem): bool {
            mut i: i32 = 0;
            val keys: ref keytype = map.keys;
            loop {
                if i >= keys.len {
                    break;
                }
                unsafe {
                    if C.memcmp(&(keys*.data[i]), &key, C.sizeof(key)) == 0 {
                        return true;
                    }
                }
                i = i + 1;
            }
            return false;
        }
        
        pub def size(map: ref mapname): i32 {
            val keys: ref keytype = map.keys;
            return keys.len;
        }
        
        pub def pop(map: ref mapname, key: keytype_elem): valtype_elem {
            mut i: i32 = 0;
            mut keys: ref keytype = map.keys;
            mut values: ref valtype = map.values;
            mut result: valtype_elem;
            mut found: bool = false;
            loop {
                if i >= keys.len {
                    break;
                }
                unsafe {
                    if C.memcmp(&(keys*.data[i]), &key, C.sizeof(key)) == 0 {
                        found = true;
                    }
                }
                if found {
                    result = values.data[i];
                    unsafe {
                        for mut j = i; j < keys.len - 1; j++ {
                            keys*.data[j] = keys*.data[j + 1];
                            values*.data[j] = values*.data[j + 1];
                        }
                        keys*.len--;
                        values*.len--;
                    }
                    return result;
                }
                i = i + 1;
            }
            mut default_val: valtype_elem;
            unsafe {
                C.memset(&default_val, 0, C.sizeof(default_val));
            }
            return default_val;
        }
    }
}

/// Generic StringHashMap with proper string comparison
macro make_string_map(valtype_elem: untyped, mapname: untyped, valtype: untyped) {
    pub model mapname {
        keys: ref StringList;
        values: ref valtype;

        pub def create(arena: ref Arena, capacity: i32): ref mapname {
            mut map: ref mapname;
            unsafe {
                map = Arena.alloc(arena, C.sizeof(mapname));
            }
            map.keys = StringList.create(arena, capacity);
            map.values = valtype.create(arena, capacity);
            return map;
        }

        pub def clear(map: ref mapname) {
            map.keys.len = 0;
            map.values.len = 0;
        }
        
        pub def add(map: ref mapname, arena: ref Arena, key: string, value: valtype_elem) {
            StringList.push(map.keys, arena, key);
            valtype.push(map.values, arena, value);
        }
        
        pub def set(map: ref mapname, arena: ref Arena, key: string, value: valtype_elem) {
            mut i: i32 = 0;
            val keys: ref StringList = map.keys;
            mut values: ref valtype = map.values;
            loop {
                if i >= keys.len {
                    break;
                }
                val current_key: string = keys.data[i];
                unsafe {
                    if current_key.len == key.len {
                        if C.strncmp(current_key.data, key.data, key.len) == 0 {
                            values*.data[i] = value;
                            return;
                        }
                    }
                }
                i = i + 1;
            }
            StringList.push(map.keys, arena, key);
            valtype.push(map.values, arena, value);
        }
        
        pub def get(map: ref mapname, key: string): valtype_elem {
            mut i: i32 = 0;
            val keys: ref StringList = map.keys;
            val values: ref valtype = map.values;
            loop {
                if i >= keys.len {
                    break;
                }
                val current_key: string = keys.data[i];
                unsafe {
                    if current_key.len == key.len {
                        if C.strncmp(current_key.data, key.data, key.len) == 0 {
                            return values*.data[i];
                        }
                    }
                }
                i = i + 1;
            }
            mut default_val: valtype_elem;
            unsafe {
                C.memset(&default_val, 0, C.sizeof(default_val));
            }
            return default_val;
        }
        
        pub def contains(map: ref mapname, key: string): bool {
            mut i: i32 = 0;
            val keys: ref StringList = map.keys;
            loop {
                if i >= keys.len {
                    break;
                }
                val current_key: string = keys.data[i];
                unsafe {
                    if current_key.len == key.len {
                        if C.strncmp(current_key.data, key.data, key.len) == 0 {
                            return true;
                        }
                    }
                }
                i = i + 1;
            }
            return false;
        }
        
        pub def size(map: ref mapname): i32 {
            val keys: ref StringList = map.keys;
            return keys.len;
        }
        
        pub def pop(map: ref mapname, key: string): valtype_elem {
            mut i: i32 = 0;
            mut keys: ref StringList = map.keys;
            mut values: ref valtype = map.values;
            mut result: valtype_elem;
            mut found: bool = false;
            loop {
                if i >= keys.len {
                    break;
                }
                val current_key: string = keys.data[i];
                unsafe {
                    if current_key.len == key.len {
                        if C.strncmp(current_key.data, key.data, key.len) == 0 {
                            found = true;
                        }
                    }
                }
                if found {
                    result = values.data[i];
                    unsafe {
                        for mut j = i; j < keys.len - 1; j++ {
                            keys*.data[j] = keys*.data[j + 1];
                            values*.data[j] = values*.data[j + 1];
                        }
                        keys*.len--;
                        values*.len--;
                    }
                    return result;
                }
                i = i + 1;
            }
            mut default_val: valtype_elem;
            unsafe {
                C.memset(&default_val, 0, C.sizeof(default_val));
            }
            return default_val;
        }
    }
}

make_string_map(i32, StringIntMap, IntList);
make_string_map(f32, StringFloatMap, FloatList);
make_string_map(bool, StringBoolMap, BoolList);
make_string_map(string, StringStringMap, StringList);

make_map(i32, i32, IntIntMap, IntList, IntList);
make_map(f32, i32, FloatIntMap, FloatList, IntList);
make_map(i32, f32, IntFloatMap, IntList, FloatList);
make_map(f32, f32, FloatFloatMap, FloatList, FloatList);
make_map(i32, bool, IntBoolMap, IntList, BoolList);
make_map(bool, i32, BoolIntMap, BoolList, IntList);
make_map(f32, bool, FloatBoolMap, FloatList, BoolList);
make_map(bool, f32, BoolFloatMap, BoolList, FloatList);
make_map(bool, bool, BoolBoolMap, BoolList, BoolList);

test {
    mut arena: Arena = Arena.create(1024);
    
    val int_map: ref IntIntMap = IntIntMap.create(addr(arena), 10);
    
    IntIntMap.add(int_map, addr(arena), 1, 100);
    IntIntMap.add(int_map, addr(arena), 2, 200);
    IntIntMap.add(int_map, addr(arena), 3, 300);
    
    assert(IntIntMap.get(int_map, 1) == 100, "IntIntMap should return 100 for key 1");
    assert(IntIntMap.get(int_map, 2) == 200, "IntIntMap should return 200 for key 2");
    assert(IntIntMap.get(int_map, 3) == 300, "IntIntMap should return 300 for key 3");
    assert(IntIntMap.contains(int_map, 1), "IntIntMap should contain key 1");
    assert(IntIntMap.contains(int_map, 2), "IntIntMap should contain key 2");
    assert(!IntIntMap.contains(int_map, 999), "IntIntMap should not contain key 999");
    assert(IntIntMap.size(int_map) == 3, "IntIntMap size should be 3");
    
    val str_int_map: ref StringIntMap = StringIntMap.create(addr(arena), 10);
    
    StringIntMap.add(str_int_map, addr(arena), str("foo"), 42);
    StringIntMap.add(str_int_map, addr(arena), str("bar"), 99);
    StringIntMap.add(str_int_map, addr(arena), str("baz"), 77);
    
    assert(StringIntMap.get(str_int_map, str("foo")) == 42, "StringIntMap should return 42 for key 'foo'");
    assert(StringIntMap.get(str_int_map, str("bar")) == 99, "StringIntMap should return 99 for key 'bar'");
    assert(StringIntMap.get(str_int_map, str("baz")) == 77, "StringIntMap should return 77 for key 'baz'");
    assert(StringIntMap.contains(str_int_map, str("foo")), "StringIntMap should contain key 'foo'");
    assert(!StringIntMap.contains(str_int_map, str("missing")), "StringIntMap should not contain key 'missing'");
    assert(StringIntMap.size(str_int_map) == 3, "StringIntMap size should be 3");
    
    val float_map: ref FloatIntMap = FloatIntMap.create(addr(arena), 10);
    
    FloatIntMap.add(float_map, addr(arena), cast[f32](3.14), 314);
    FloatIntMap.add(float_map, addr(arena), cast[f32](2.71), 271);
    
    assert(FloatIntMap.get(float_map, 3.14) == 314, "FloatIntMap should return 314 for key 3.14");
    assert(FloatIntMap.get(float_map, 2.71) == 271, "FloatIntMap should return 271 for key 2.71");
    assert(FloatIntMap.contains(float_map, 3.14), "FloatIntMap should contain key 3.14");
    assert(!FloatIntMap.contains(float_map, 1.23), "FloatIntMap should not contain key 1.23");
    assert(FloatIntMap.size(float_map) == 2, "FloatIntMap size should be 2");
}
