use std.arena (
    Arena
);

use std.io (
    print_i32,
    print_str,
    print_char,
    println
);

use std.string (
    string,
    string_equals
);

use std.errors (
    panic,
    error
);

macro make_list(
    name: string, 
    type: string, 
    nullval: untyped, 
    cep: untyped, 
    printer: untyped
) {
    pub model name {
        data: ref type;
        len: i32;
        cap: i32;

        pub def create(arena: ref Arena, capacity: i32): ref name {
            mut lst: ref name;
            unsafe {
                lst = Arena.alloc(arena, C.sizeof(name));
                lst*.data = Arena.alloc_array(arena, C.sizeof(type), capacity);
            }
            if lst == nil {
                panic(error.create("List: failed to allocate list header"));
            }
            if lst*.data == nil {
                panic(error.create("List: failed to allocate list data"));
            }
            lst.len = 0;
            lst.cap = capacity;
            return lst;
        }

        pub def push(lst: ref name, arena: ref Arena, value: type) {
            if lst.len >= lst.cap {
                val new_cap: i32 = lst.cap * 2;
                mut new_data: ref type;
                unsafe {
                    new_data = Arena.alloc_array(arena, C.sizeof(type), new_cap);
                    for mut i = 0; i < lst*.len; i++ {
                        C.memcpy(&(new_data[i]), &(lst*.data[i]), C.sizeof(type));
                    }
                }
                lst.data = new_data;
                lst.cap = new_cap;
            }
            lst.data[lst.len] = value;
            lst.len = lst.len + 1;
        }

        pub def get(lst: ref name, index: i32): type {
            if index < 0 or index >= lst.len {
                panic(error.create("Index out of bounds for list."));
                return nullval;
            }
            return lst.data[index];
        }

        pub def clear(lst: ref name) {
            lst.len = 0;
        }

        pub def contains(lst: ref name, value: type): bool {
            for mut i = 0; i < lst.len; i++ {
                if cep(lst.data[i], value) {
                    return true;
                }
            }
            return false;
        }

        pub def print_all(lst: ref name) {
            for mut i = 0; i < lst.len; i++ {
                printer(lst.data[i]);
                print " ";
            }
            println "";
        }
    }
}

def int_eq(a: i32, b: i32): bool { return a == b; }
def long_eq(a: i64, b: i64): bool { return a == b; }
def float_eq(a: f32, b: f32): bool { return a == b; }
def double_eq(a: f64, b: f64): bool { return a == b; }
def char_eq(a: char, b: char): bool { return a == b; }
def bool_eq(a: bool, b: bool): bool { return a == b; }

make_list(IntList, i32, 0, int_eq, print_i32);
make_list(FloatList, f32, 0.0, float_eq, print_i32);
make_list(CharList, char, "", char_eq, print_char);
make_list(LongList, i64, 0, long_eq, print_i32);
make_list(DoubleList, f64, 0.0, double_eq, print_i32);
make_list(StringList, std__string__string, string.create(""), string_equals, print_str);
make_list(BoolList, bool, false, bool_eq, print_i32);

test {
    mut arena: Arena = Arena.create(65536);
    mut my_list: ref IntList = IntList.create(addr(arena), 4);

    IntList.push(my_list, addr(arena), 10);
    IntList.push(my_list, addr(arena), 20);
    IntList.push(my_list, addr(arena), 30);
    IntList.push(my_list, addr(arena), 40);
    IntList.push(my_list, addr(arena), 50);

    println "IntList contents:";

    IntList.print_all(my_list);

    println "Element at index 2:";
    println IntList.get(my_list, 2);

    Arena.destroy(addr(arena));
}
