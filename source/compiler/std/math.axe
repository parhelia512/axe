pub val PI: f64           = 3.141592653589793;
pub val HALF_PI: f64      = PI / 2.0;
pub val QUARTER_PI: f64   = PI / 4.0;
pub val TWO_PI: f64       = PI * 2.0;
pub val E: f64            = 2.718281828459045;

/// Clamp integer
pub def clamp(value: i32, min: i32, max: i32): i32 {
    if value < min { return min; }
    elif value > max { return max; }
    else { return value; }
}

/// Clamp float
pub def clamp_float(value: f64, min: f64, max: f64): f64 {
    if value < min { return min; }
    elif value > max { return max; }
    else { return value; }
}

/// Absolute value
pub def absolute(value: f64): f64 {
    if value < 0.0 { return -value; } else { return value; }
}

/// Approximately equal
pub def approx_equal(a: f64, b: f64, eps: f64): bool {
    return absolute(a - b) <= eps;
}

/// Minimum
pub def minimum(a: f64, b: f64): f64 { if a < b { return a; } else { return b; } }

/// Maximum
pub def maximum(a: f64, b: f64): f64 { if a > b { return a; } else { return b; } }

/// Converts an integer to a float.
pub def int_to_float(x: i32): f64 {
    return x + 0.0;
}

/// Floor of the number.
pub def floor(x: f64): f64 {
    val xi: i32 = cast[i32](x);
    if x < 0.0 and (x - xi) != 0.0 {
        return (xi - 1);
    } else {
        return xi;
    }
}

/// Ceiling of the number.
pub def ceil(x: f64): f64 {
    val xi: i32 = cast[i32](x);
    val xf: f64 = cast[f64](xi);
    if x > 0.0 and (x - xf) != 0.0 {
        val next: i32 = xi + 1;
        return next;
    } else {
        return xf;
    }
}

/// Round to the nearest float
pub def round(x: f64): f64 {
    if x < 0.0 {
        return ceil(x - 0.5);
    } else {
        return floor(x + 0.5);
    }
}

/// Float modulus.
pub def mod_float(a: f64, b: f64): f64 {
    return a - b * floor(a / b);
}

/// Reduce angle to [0, 2PI]
pub def reduce_angle(x: f64): f64 {
    return mod_float(x, TWO_PI);
}

/// Square root (Newton)
pub def sqrt(value: f64): f64 {
    if value <= 0.0 { return 0.0; }
    if value < 0.0000001 { return 0.00001; }

    mut x: f64 = 0.0;

    if value >= 1.0 {
        x = value * 0.5;
    } else {
        x = 1.0;
    }

    for mut i = 0; i < 50; i++ {
        val last: f64 = x;
        x = 0.5 * (x + value / x);
        if approx_equal(last, x, 0.0000000000001) { break; }
    }
    return x;
}

/// Integer exponent (exponentiation by squaring)
pub def pow(base: f64, exp: i32): f64 {
    mut result: f64 = 1.0;
    mut b: f64 = base;
    mut e: i32 = exp;

    if e < 0 {
        b = 1.0 / b;
        e = -e;
    }

    loop {
        if e == 0 { break; }

        if e - (e / 2) * 2 == 1 {
            result = result * b;
        }

        b = b * b;
        e = e / 2;
    }

    return result;
}

/// Exponential series
pub def exp(x: f64): f64 {
    if x < 0.0 {
        return 1.0 / exp(cast[f64](-x));
    }

    mut n: i32 = 0;
    loop {
        if x > 1.0 {
            x = x * 0.5;
            n = n + 1;
        } else {
            break;
        }
    }

    mut sum: f64 = 1.0;
    mut term: f64 = 1.0;
    for mut k = 1; k < 25; k++ {
        term = term * x / k;
        sum = sum + term;
    }

    for mut i = 0; i < n; i++ {
        sum = sum * sum;
    }
    return sum;
}


/// Natural logarithm
pub def ln(x: f64): f64 {
    if x <= 0.0 { return 0.0; }

    mut y: f64 = x - 1.0;
    for mut i = 0; i < 25; i++ {
        val last: f64 = y;
        val ey: f64 = exp(y);
        y = y - (ey - x) / ey;
        if approx_equal(last, y, 0.0000001) { break; }
    }
    return y;
}

/// Sine (reduced angle)
pub def sin(x: f64): f64 {
    x = reduce_angle(x);
    mut term: f64 = x;
    mut sum: f64 = x;
    val x2: f64 = x * x;
    mut n: i32 = 1;
    for mut i = 1; i < 10; i++ {
        term = -term * x2 / ((2 * n) * (2 * n + 1));
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

/// Cosine
pub def cos(x: f64): f64 {
    x = reduce_angle(x);
    mut term: f64 = 1.0;
    mut sum: f64 = 1.0;
    val x2: f64 = x * x;
    mut n: i32 = 1;
    for mut i = 1; i < 10; i++ {
        term = -term * x2 / ((2 * n - 1) * (2 * n));
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

/// Tangent
pub def tan(x: f64): f64 {
    return sin(x) / cos(x);
}

/// Arcsine
pub def asin(x: f64): f64 {
    x = clamp_float(x, -1.0, 1.0);

    if x > 0.7071067811865476 {
        return HALF_PI - asin(sqrt(1.0 - x*x));
    } elif x < -0.7071067811865476 {
        return -HALF_PI + asin(sqrt(1.0 - x*x));
    }

    mut term: f64 = x;
    mut sum: f64 = x;
    val x2: f64 = x * x;

    for mut n = 0; n < 15; n++ {
        term = term * ((2.0*n + 1.0)*(2.0*n + 1.0))/((2.0*n + 2.0)*(2.0*n + 3.0)) * x2;
        sum = sum + term;
    }

    return sum;
}

/// Arccosine
pub def acos(x: f64): f64 {
    return HALF_PI - asin(x);
}

/// Arctangent
pub def atan(x: f64): f64 {
    mut term: f64 = x;
    mut sum: f64 = x;
    val x2: f64 = x * x;
    mut sign: f64 = -1.0;
    for mut n = 3; n < 20; n += 2 {
        term = term * x2;
        sum = sum + sign * term / n;
        sign = -sign;
    }
    return sum;
}

/// Float power: base^exp for non-integer exponents
pub def powf(base: f64, expp: f64): f64 {
    if base <= 0.0 {
        // avoid log(0) or negative base issues
        return 0.0;
    }
    return exp(ln(base) * expp);
}

/// Two-argument arctangent: returns angle in radians between [-PI, PI]
pub def atan2(y: f64, x: f64): f64 {
    if x > 0.0 {
        return atan(y / x);
    } elif x < 0.0 and y >= 0.0 {
        return atan(y / x) + PI;
    } elif x < 0.0 and y < 0.0 {
        return atan(y / x) - PI;
    } elif x == 0.0 and y > 0.0 {
        return HALF_PI;
    } elif x == 0.0 and y < 0.0 {
        return -HALF_PI;
    } else {
        return 0.0;
    }
}

/// Sorts a list of numeric values in ascending order
pub def sorted[T](lst: ref T): T {
    when T is list(i32) {
        val length = len(lst);
        if length <= 1 {
            return deref(lst);
        }

        mut result: list(i32);
        for mut i = 0; i < length; i++ {
            append(result, lst.data[i]);
        }

        for mut i = 0; i < length - 1; i++ {
            for mut j = 0; j < length - i - 1; j++ {
                if result.data[j] > result.data[j + 1] {
                    val temp:i32 = result.data[j];
                    result.data[j] = result.data[j + 1];
                    result.data[j + 1] = temp;
                }
            }
        }
        return result;
    }
    when T is list(f32) {
        val length = len(lst);
        if length <= 1 {
            return deref(lst);
        }

        mut result: list(f32);
        for mut i = 0; i < length; i++ {
            append(result, lst.data[i]);
        }

        for mut i = 0; i < length - 1; i++ {
            for mut j = 0; j < length - i - 1; j++ {
                if result.data[j] > result.data[j + 1] {
                    val temp = result.data[j];
                    result.data[j] = result.data[j + 1];
                    result.data[j + 1] = temp;
                }
            }
        }
        return result;
    }
    when T is list(f64) {
        val length = len(lst);
        if length <= 1 {
            return deref(lst);
        }

        mut result: list(f64);
        for mut i = 0; i < length; i++ {
            append(result, lst.data[i]);
        }

        for mut i = 0; i < length - 1; i++ {
            for mut j = 0; j < length - i - 1; j++ {
                if result.data[j] > result.data[j + 1] {
                    val temp = result.data[j];
                    result.data[j] = result.data[j + 1];
                    result.data[j + 1] = temp;
                }
            }
        }
        return result;
    }
    when T is list(i64) {
        val length = len(lst);
        if length <= 1 {
            return deref(lst);
        }

        mut result: list(i64);
        for mut i = 0; i < length; i++ {
            append(result, lst.data[i]);
        }

        for mut i = 0; i < length - 1; i++ {
            for mut j = 0; j < length - i - 1; j++ {
                if result.data[j] > result.data[j + 1] {
                    val temp = result.data[j];
                    result.data[j] = result.data[j + 1];
                    result.data[j + 1] = temp;
                }
            }
        }
        return result;
    }
    when T is list(u32) {
        val length = len(lst);
        if length <= 1 {
            return deref(lst);
        }

        mut result: list(u32);
        for mut i = 0; i < length; i++ {
            append(result, lst.data[i]);
        }

        for mut i = 0; i < length - 1; i++ {
            for mut j = 0; j < length - i - 1; j++ {
                if result.data[j] > result.data[j + 1] {
                    val temp = result.data[j];
                    result.data[j] = result.data[j + 1];
                    result.data[j + 1] = temp;
                }
            }
        }
        return result;
    }
    when T is list(u64) {
        val length = len(lst);
        if length <= 1 {
            return deref(lst);
        }

        mut result: list(u64);
        for mut i = 0; i < length; i++ {
            append(result, lst.data[i]);
        }

        for mut i = 0; i < length - 1; i++ {
            for mut j = 0; j < length - i - 1; j++ {
                if result.data[j] > result.data[j + 1] {
                    val temp = result.data[j];
                    result.data[j] = result.data[j + 1];
                    result.data[j + 1] = temp;
                }
            }
        }
        return result;
    }
}

/// Hyperbolic tangent inverse
pub def atanh(x: f64): f64 {
    if x <= -1.0 or x >= 1.0 {
        return 0.0;
    }
    return 0.5 * ln((1.0 + x) / (1.0 - x));
}

test {
    assert(approx_equal(sqrt(16.0), 4.0, 0.001), "sqrt(16) should be ~4");
    assert(approx_equal(sin(PI/2.0), 1.0, 0.01), "sin(pi/2) should be ~1");
    assert(approx_equal(cos(0.0), 1.0, 0.01), "cos(0) should be ~1");
    assert(approx_equal(tan(PI/4.0), 1.0, 0.05), "tan(pi/4) should be ~1");
    assert(approx_equal(asin(1.0), PI/2.0, 0.05), "asin(1) should be ~pi/2");
    assert(approx_equal(acos(0.0), PI/2.0, 0.05), "acos(0) should be ~pi/2");
    assert(approx_equal(atan(1.0), PI/4.0, 0.05), "atan(1) should be ~pi/4");
    assert(approx_equal(exp(1.0), E, 0.05), "exp(1) should be ~E");
    assert(approx_equal(ln(E), 1.0, 0.05), "ln(E) should be ~1");
    assert(clamp(5, 0, 10) == 5, "clamp mid");
    assert(clamp(-5, 0, 10) == 0, "clamp below");
    assert(clamp(50, 0, 10) == 10, "clamp above");
    assert(clamp_float(5.5, 0.0, 10.0) == 5.5, "clamp_float mid");
    assert(clamp_float(-1.0, 0.0, 10.0) == 0.0, "clamp_float below");
    assert(clamp_float(20.0, 0.0, 10.0) == 10.0, "clamp_float above");
    assert(absolute(-5.0) == 5.0, "absolute neg");
    assert(absolute(5.0) == 5.0, "absolute pos");
    assert(floor(5.2) == 5.0, "floor positive");
    assert(floor(-1.2) == -2.0, "floor negative fractional");
    assert(floor(-1.0) == -1.0, "floor negative exact");
    assert(ceil(5.2) == 6.0, "ceil positive");
    assert(ceil(-1.2) == -1.0, "ceil negative fractional");
    assert(ceil(2.0) == 2.0, "ceil exact");
    assert(round(5.4) == 5.0, "round down");
    assert(round(5.6) == 6.0, "round up");
    assert(round(-1.4) == -1.0, "round negative down");
    assert(round(-1.6) == -2.0, "round negative up");
    assert(approx_equal(sqrt(2.0), 1.4142, 0.01), "sqrt(2)");
    assert(approx_equal(sqrt(0.25), 0.5, 0.01), "sqrt(0.25)");
    assert(approx_equal(sqrt(10000.0), 100.0, 0.01), "sqrt(10000)");
    assert(approx_equal(reduce_angle(PI), PI, 0.001), "reduce pi");
    assert(approx_equal(reduce_angle(PI + TWO_PI), PI, 0.001), "reduce angle wrap");
    assert(approx_equal(reduce_angle(-PI), TWO_PI - PI, 0.001), "reduce negative");
    assert(approx_equal(mod_float(10.5, 2.0), 0.5, 0.001), "mod float basic");
    assert(approx_equal(mod_float(-1.0, 2.0), 1.0, 0.001), "mod float negative");
    assert(approx_equal(pow(2.0, 10), 1024.0, 0.001), "pow positive exp");
    assert(approx_equal(pow(2.0, -3), 0.125, 0.001), "pow negative exp");
    assert(approx_equal(pow(5.0, 0), 1.0, 0.0001), "pow zero");
    assert(approx_equal(ln(exp(2.0)), 2.0, 0.05), "ln(exp(x)) ≈ x");
    assert(approx_equal(exp(ln(2.0)), 2.0, 0.05), "exp(ln(x)) ≈ x");
    assert(approx_equal(sin(0.0), 0.0, 0.01), "sin(0)");
    assert(approx_equal(cos(PI), -1.0, 0.05), "cos(pi)");

    val s: f64 = sin(1.0);
    val c: f64 = cos(1.0);

    assert(approx_equal(s*s + c*c, 1.0, 0.05), "sin^2 + cos^2 = 1");
    assert(approx_equal(atan(0.0), 0.0, 0.01), "atan(0)");
    assert(approx_equal(asin(0.0), 0.0, 0.05), "asin(0)");
    assert(approx_equal(acos(1.0), 0.0, 0.05), "acos(1)");
    assert(approx_equal(powf(2.0, 10.0), 1024.0, 0.01), "powf 2^10");
    assert(approx_equal(powf(9.0, 0.5), 3.0, 0.01), "powf sqrt via powf");
    assert(approx_equal(powf(E, 1.0), E, 0.01), "powf e^1");
    assert(approx_equal(powf(E, 2.0), E*E, 0.05), "powf e^2");
    assert(approx_equal(powf(10.0, -1.0), 0.1, 0.01), "powf 10^-1");

    mut int_list: list(i32) = [3, 1, 4, 1, 5];
    mut sorted_int_list: list(i32) = sorted[list(i32)](addr(int_list));
    assert(len(sorted_int_list) == 5, "sorted int list has same length");
    assert(sorted_int_list.data[0] == 1, "first element is smallest");
    assert(sorted_int_list.data[4] == 5, "last element is largest");
}
