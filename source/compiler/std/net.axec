use std.string (
    string
);

use std.errors (
    error,
    panic
);

use std.io (
    println_str
);

use external("curl/curl.h");

platform windows {
    use external("winsock2.h");
    use external("ws2tcpip.h");
}

platform posix {
    use external("sys/socket.h");
    use external("netinet/in.h");
    use external("arpa/inet.h");
    use external("unistd.h");
    use external("fcntl.h");
}

/// HTTP response model containing status code, headers, and body
model HttpResponse {
    status_code: i32;
    body: string;
    headers: string;
    success: bool;
}

/// Memory struct for curl write callback
model MemoryStruct {
    memory: ref char;
    size: usize;
}

/// Internal write callback function for curl - grows buffer as needed
def write_callback(contents: ref char, size: usize, nmemb: usize, userp: ref char): usize {
    mut realsize: usize = 0;
    realsize = size * nmemb;
    mut mem: ref MemoryStruct = cast[ref MemoryStruct](userp);
    unsafe {
        mut ptr: ref char = cast[ref char](C.realloc(mem*.memory, mem*.size + realsize + 1));
        if ptr == nil {
            return 0;
        }

        mem*.memory = ptr;
        C.memcpy(addr(mem*.memory[mem*.size]), contents, realsize);
        mem*.size += realsize;
        mem*.memory[mem*.size] = 0;
    }
    return realsize;
}

/// Initialize the cURL library globally
def curl_init() {
    foreign {CURL_GLOBAL_ALL};
    unsafe {
        C.curl_global_init(CURL_GLOBAL_ALL);
    }
}

/// Cleanup the cURL library globally
def curl_cleanup() {
    unsafe {
        C.curl_global_cleanup();
    }
}

foreign {
    CURLOPT_URL,
    CURLOPT_WRITEFUNCTION,
    CURLOPT_WRITEDATA,
    CURLOPT_NOBODY,
    CURLOPT_HEADERFUNCTION,
    CURLOPT_HEADERDATA,
    CURLOPT_FOLLOWLOCATION,
    CURLOPT_USERAGENT,
    CURLOPT_POST,
    CURLOPT_POSTFIELDS,
    CURLINFO_RESPONSE_CODE,
    CURL,
    FILE,
    CURLcode,
    CURLOPT_CUSTOMREQUEST
}

/// Perform an HTTP GET request
def http_get(url: string): HttpResponse {
    mut response: HttpResponse;
    
    response.status_code = 0;
    response.success = false;
    response.body.data = nil;
    response.body.len = 0;
    response.body.cap = 0;
    response.headers.data = nil;
    response.headers.len = 0;
    response.headers.cap = 0;

    unsafe {
        mut curl: ref CURL = C.curl_easy_init();

        if curl != nil {
            mut body_chunk: MemoryStruct;
            body_chunk.memory = cast[ref char](C.malloc(1));
            body_chunk.size = 0;
            mut header_chunk: MemoryStruct;
            header_chunk.memory = cast[ref char](C.malloc(1));
            header_chunk.size = 0;

            C.curl_easy_setopt(curl, CURLOPT_URL, url.data);
            C.curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_WRITEDATA, cast[ref void](addr(body_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_HEADERDATA, cast[ref void](addr(header_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
            C.curl_easy_setopt(curl, CURLOPT_USERAGENT, "axe-std.1.0");

            val res: CURLcode = C.curl_easy_perform(curl);
            if res == CURLE_OK {
                mut response_code: i64 = 0;
                C.curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, addr(response_code));
                response.status_code = cast[i32](response_code);
                response.success = true;
                response.body.data = body_chunk.memory;
                response.body.len = body_chunk.size;
                response.body.cap = body_chunk.size + 1;
                response.headers.data = header_chunk.memory;
                response.headers.len = header_chunk.size;
                response.headers.cap = header_chunk.size + 1;
            } else {
                C.free(cast[ref void](body_chunk.memory));
                C.free(cast[ref void](header_chunk.memory));
            }
            C.curl_easy_cleanup(curl);
        }
    }
   
    return response;
}

/// Perform an HTTP POST request with data
def http_post(url: string, data: string): HttpResponse {
    mut response: HttpResponse;
    
    response.status_code = 0;
    response.success = false;
    response.body.data = nil;
    response.body.len = 0;
    response.body.cap = 0;
    response.headers.data = nil;
    response.headers.len = 0;
    response.headers.cap = 0;
    
    unsafe {
        mut curl: ref CURL = C.curl_easy_init();

        if curl != nil {
            mut body_chunk: MemoryStruct;
            body_chunk.memory = cast[ref char](C.malloc(1));
            body_chunk.size = 0;
            mut header_chunk: MemoryStruct;
            header_chunk.memory = cast[ref char](C.malloc(1));
            header_chunk.size = 0;
        
            C.curl_easy_setopt(curl, CURLOPT_URL, url.data);
            C.curl_easy_setopt(curl, CURLOPT_POST, 1);
            C.curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.data);
            C.curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_WRITEDATA, cast[ref void](addr(body_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_HEADERDATA, cast[ref void](addr(header_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
            C.curl_easy_setopt(curl, CURLOPT_USERAGENT, "axe-std.1.0");

            val res: CURLcode = C.curl_easy_perform(curl);

            if curl != nil {
                mut response_code: i64 = 0;
                C.curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, addr(response_code));
                response.status_code = cast[i32](response_code);
                response.success = true;
                response.body.data = body_chunk.memory;
                response.body.len = body_chunk.size;
                response.body.cap = body_chunk.size + 1;
                response.headers.data = header_chunk.memory;
                response.headers.len = header_chunk.size;
                response.headers.cap = header_chunk.size + 1;
            } else {
                C.free(cast[ref void](body_chunk.memory));
                C.free(cast[ref void](header_chunk.memory));
            }
            C.curl_easy_cleanup(curl);
        }
    }  
    return response;
}

/// Perform an HTTP PUT request with data
def http_put(url: string, data: string): HttpResponse {
    mut response: HttpResponse;
    
    response.status_code = 0;
    response.success = false;
    response.body.data = nil;
    response.body.len = 0;
    response.body.cap = 0;
    response.headers.data = nil;
    response.headers.len = 0;
    response.headers.cap = 0;

    unsafe {
        mut curl: ref CURL = C.curl_easy_init();
        if curl != nil {
            mut body_chunk: MemoryStruct;
            body_chunk.memory = cast[ref char](C.malloc(1));
            body_chunk.size = 0;
            mut header_chunk: MemoryStruct;
            header_chunk.memory = cast[ref char](C.malloc(1));
            header_chunk.size = 0;

            C.curl_easy_setopt(curl, CURLOPT_URL, url.data);
            C.curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
            C.curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.data);
            C.curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_WRITEDATA, cast[ref void](addr(body_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_HEADERDATA, cast[ref void](addr(header_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
            C.curl_easy_setopt(curl, CURLOPT_USERAGENT, "axe-std.1.0");

            val res: CURLcode = C.curl_easy_perform(curl);
            if res == CURLE_OK {
                mut response_code: i64 = 0;
                C.curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, addr(response_code));
                response.status_code = cast[i32](response_code);
                response.success = true;
                response.body.data = body_chunk.memory;
                response.body.len = body_chunk.size;
                response.body.cap = body_chunk.size + 1;
                response.headers.data = header_chunk.memory;
                response.headers.len = header_chunk.size;
                response.headers.cap = header_chunk.size + 1;
            } else {
                C.free(cast[ref void](body_chunk.memory));
                C.free(cast[ref void](header_chunk.memory));
            }
            C.curl_easy_cleanup(curl);
        }
    }
    return response;
}

/// Perform an HTTP DELETE request
def http_delete(url: string): HttpResponse {
    mut response: HttpResponse;
    
    response.status_code = 0;
    response.success = false;
    response.body.data = nil;
    response.body.len = 0;
    response.body.cap = 0;
    response.headers.data = nil;
    response.headers.len = 0;
    response.headers.cap = 0;

    unsafe {
        mut curl: ref CURL = C.curl_easy_init();
        if curl != nil {
            mut body_chunk: MemoryStruct;
            body_chunk.memory = cast[ref char](C.malloc(1));
            body_chunk.size = 0;
            mut header_chunk: MemoryStruct;
            header_chunk.memory = cast[ref char](C.malloc(1));
            header_chunk.size = 0;

            C.curl_easy_setopt(curl, CURLOPT_URL, url.data);
            C.curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
            C.curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_WRITEDATA, cast[ref void](addr(body_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_HEADERDATA, cast[ref void](addr(header_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
            C.curl_easy_setopt(curl, CURLOPT_USERAGENT, "axe-std.1.0");

            val res: CURLcode = C.curl_easy_perform(curl);
            if res == CURLE_OK {
                mut response_code: i64 = 0;
                C.curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, addr(response_code));
                response.status_code = cast[i32](response_code);
                response.success = true;
                response.body.data = body_chunk.memory;
                response.body.len = body_chunk.size;
                response.body.cap = body_chunk.size + 1;
                response.headers.data = header_chunk.memory;
                response.headers.len = header_chunk.size;
                response.headers.cap = header_chunk.size + 1;
            } else {
                C.free(body_chunk.memory);
                C.free(header_chunk.memory);
            }
            C.curl_easy_cleanup(curl);
        }
    }
    return response;
}

/// Perform an HTTP PATCH request with data
def http_patch(url: string, data: string): HttpResponse {
    mut response: HttpResponse;
    
    response.status_code = 0;
    response.success = false;
    response.body.data = nil;
    response.body.len = 0;
    response.body.cap = 0;
    response.headers.data = nil;
    response.headers.len = 0;
    response.headers.cap = 0;

    mut curl: ref CURL = C.curl_easy_init();

    unsafe {
        if curl != nil {
            mut body_chunk: MemoryStruct;
            body_chunk.memory = cast[ref char](C.malloc(1));
            body_chunk.size = 0;

            mut header_chunk: MemoryStruct;
            header_chunk.memory = cast[ref char](C.malloc(1));
            header_chunk.size = 0;

            C.curl_easy_setopt(curl, CURLOPT_URL, url.data);
            C.curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PATCH");
            C.curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.data);
            C.curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_WRITEDATA, cast[ref void](addr(body_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_HEADERDATA, cast[ref void](addr(header_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
            C.curl_easy_setopt(curl, CURLOPT_USERAGENT, "axe-std.1.0");

            val res: CURLcode = C.curl_easy_perform(curl);
            if res == CURLE_OK {
                mut response_code: i64 = 0;
                C.curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, addr(response_code));
                response.status_code = cast[i32](response_code);
                response.success = true;
                response.body.data = body_chunk.memory;
                response.body.len = body_chunk.size;
                response.body.cap = body_chunk.size + 1;
                response.headers.data = header_chunk.memory;
                response.headers.len = header_chunk.size;
                response.headers.cap = header_chunk.size + 1;
            } else {
                C.free(cast[ref void](body_chunk.memory));
                C.free(cast[ref void](header_chunk.memory));
            }
            C.curl_easy_cleanup(curl);
        }
    }
   
    return response;
}

/// Perform an HTTP HEAD request (retrieves headers only)
def http_head(url: string): HttpResponse {
    mut response: HttpResponse;
    
    response.status_code = 0;
    response.success = false;
    response.body.data = nil;
    response.body.len = 0;
    response.body.cap = 0;
    response.headers.data = nil;
    response.headers.len = 0;
    response.headers.cap = 0;

    unsafe {
        mut curl: ref CURL = C.curl_easy_init();
        if curl != nil {
            mut header_chunk: MemoryStruct;
            header_chunk.memory = cast[ref char](C.malloc(1));
            header_chunk.size = 0;

            C.curl_easy_setopt(curl, CURLOPT_URL, url.data);
            C.curl_easy_setopt(curl, CURLOPT_NOBODY, 1);
            C.curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, std__net__write_callback);
            C.curl_easy_setopt(curl, CURLOPT_HEADERDATA, cast[ref void](addr(header_chunk)));
            C.curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
            C.curl_easy_setopt(curl, CURLOPT_USERAGENT, "axe-std.1.0");

            val res: CURLcode = C.curl_easy_perform(curl);
            if res == CURLE_OK {
                mut response_code: i64 = 0;
                C.curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, addr(response_code));
                response.status_code = cast[i32](response_code);
                response.success = true;
                response.headers.data = header_chunk.memory;
                response.headers.len = header_chunk.size;
                response.headers.cap = header_chunk.size + 1;
                response.body.data = cast[ref char](C.malloc(1));
                response.body.data[0] = '\0';
                response.body.len = 0;
                response.body.cap = 1;
            } else {
                C.free(cast[ref void](header_chunk.memory));
            }
            C.curl_easy_cleanup(curl);
        }
    }
    return response;
}

/// Download a file from a URL and save it to disk
def download_file(url: string, output_path: string): bool {
    mut success: bool = false;
    
    unsafe {
        mut curl: ref CURL = C.curl_easy_init();
        if curl != nil {
            mut fp: ref FILE = C.fopen(output_path.data, "wb");
            if fp != nil {
                C.curl_easy_setopt(curl, CURLOPT_URL, url.data);
                C.curl_easy_setopt(curl, CURLOPT_WRITEDATA, cast[ref void](fp));
                C.curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
                C.curl_easy_setopt(curl, CURLOPT_USERAGENT, "axe-std.1.0");
                
                val res: CURLcode = C.curl_easy_perform(curl);
                
                if res == CURLE_OK {
                    success = true;
                }
                
                C.fclose(fp);
            }
            C.curl_easy_cleanup(curl);
        }
    }
    
    return success;
}

/// URL encode a string (percent encoding for URLs)
def url_encode(input: string): string {
    mut result: string;
    
    result.data = nil;
    result.len = 0;
    result.cap = 0;

    unsafe {
        mut curl: ref CURL = C.curl_easy_init();
        if curl != nil {
            mut encoded: ref char = C.curl_easy_escape(curl, input.data, input.len);
            if encoded != nil {
                val len: usize = C.strlen(encoded);
                result.data = cast[ref char](C.malloc(len + 1));
                if result.data != nil {
                    C.memcpy(result.data, encoded, len + 1);
                    result.len = len;
                    result.cap = len + 1;
                }
                C.curl_free(encoded);
            }
            C.curl_easy_cleanup(curl);
        }
    }

    return result;
}

/// URL decode a string (decode percent-encoded URLs)
def url_decode(input: string): string {
    mut result: string;
    
    unsafe {
        result.data = nil;
        result.len = 0;
        result.cap = 0;

        mut curl: ref CURL = C.curl_easy_init();
        if curl != nil {
            mut outlength: i32 = 0;
            mut decoded: ref char = C.curl_easy_unescape(curl, input.data, input.len, addr(outlength));
            if decoded != nil {
                result.data = cast[ref char](C.malloc(outlength + 1));
                if result.data != nil {
                    C.memcpy(result.data, decoded, outlength);
                    result.data[outlength] = '\0';
                    result.len = outlength;
                    result.cap = outlength + 1;
                }
                C.curl_free(decoded);
            }
            C.curl_easy_cleanup(curl);
        }
    }
    
    return result;
}

/// Check if a response status code indicates success (2xx)
def is_success_status(status_code: i32): bool {
    return status_code >= 200 && status_code < 300;
}

/// Check if a response status code indicates a redirect (3xx)
def is_redirect_status(status_code: i32): bool {
    return status_code >= 300 && status_code < 400;
}

/// Check if a response status code indicates a client error (4xx)
def is_client_error_status(status_code: i32): bool {
    return status_code >= 400 && status_code < 500;
}

/// Check if a response status code indicates a server error (5xx)
def is_server_error_status(status_code: i32): bool {
    return status_code >= 500 && status_code < 600;
}

/// Free the memory allocated for an HttpResponse
def free_response(response: HttpResponse) {
    unsafe {
        if response.body.data != nil {
            C.free(response.body.data);
        }
        if response.headers.data != nil {
            C.free(response.headers.data);
        }
    }
}

// ============================================================================
// Web Server Support - Cross-platform (Windows & POSIX)
// ============================================================================

/// HTTP request model containing method, path, headers, and body
model HttpRequest {
    method: string;
    path: string;
    headers: string;
    body: string;
    version: string;
}

/// HTTP server configuration
model ServerConfig {
    port: i32;
    max_connections: i32;
    timeout_seconds: i32;
}

/// Socket handle type (cross-platform)
model Socket {
    fd: i32;
    is_valid: bool;
}

/// Server instance
model WebServer {
    socket: Socket;
    config: ServerConfig;
    is_running: bool;
}

/// Initialize networking subsystem (cross-platform)
def net_init(): bool {
    mut success: bool = true;
    platform windows {
        foreign { WSADATA };

        mut wsaData: WSADATA;
        mut result: i32 = C.WSAStartup(C.MAKEWORD(2, 2), &wsaData);

        success = (result == 0);
    }
    return success;
}

/// Cleanup networking subsystem (cross-platform)
///
/// This is a NOOP on POSIX systems.
def net_cleanup() {
    platform windows {
        unsafe {
            C.WSACleanup();
        }
    }
}

foreign {
    SOCKET,
    INVALID_SOCKET,
    SOCKET_ERROR,
    AF_INET,
    SOCK_STREAM,
    IPPROTO_TCP,
    INADDR_ANY,
    SOL_SOCKET,
    SO_REUSEADDR
}

/// Create a server socket and bind to port
def server_create(port: i32): WebServer {
    mut server: WebServer;
    
    unsafe {
        server.config.port = port;
        server.config.max_connections = 100;
        server.config.timeout_seconds = 30;
        server.is_running = false;
        server.socket.is_valid = false;
        server.socket.fd = -1;

        platform windows {
            mut sock: SOCKET = C.socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (sock == INVALID_SOCKET) {
                return server;
            }
            
            mut opt: i32 = 1;
            
            C.setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, cast[val ref char](addr(opt)), C.sizeof(i32));
            
            mut address: $(sockaddr_in);
            address.sin_family = AF_INET;
            address.sin_addr.s_addr = INADDR_ANY;
            address.sin_port = C.htons(cast[u_short](port));
            if (C.bind(sock, cast[ref $(sockaddr)](addr(address)), C.sizeof(sockaddr_in)) == SOCKET_ERROR) {
                C.closesocket(sock);
                return server;
            }
            if (C.listen(sock, server.config.max_connections) == SOCKET_ERROR) {
                C.closesocket(sock);
                return server;
            }
            server.socket.fd = cast[i32](sock);
            server.socket.is_valid = true;
        }

        platform posix {
            mut sock: i32 = C.socket(AF_INET, SOCK_STREAM, 0);
            if (sock < 0) {
                return server;
            }
            
            mut opt: i32 = 1;
            C.setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, addr(opt), C.sizeof(i32));
            
            mut address: $(sockaddr_in);
            address.sin_family = AF_INET;
            address.sin_addr.s_addr = INADDR_ANY;
            address.sin_port = C.htons(cast[uint16_t](port));
            if (C.bind(sock, cast[ref $(sockaddr)](addr(address)), C.sizeof($(sockaddr_in))) < 0) {
                C.close(sock);
                return server;
            }
            if (C.listen(sock, server.config.max_connections) < 0) {
                C.close(sock);
                return server;
            }
            server.socket.fd = sock;
            server.socket.is_valid = true;
        }

        server.is_running = true;
    }
    return server;
}

foreign {
    SO_RCVTIMEO,
    SO_SNDTIMEO
}

/// Accept a client connection
def server_accept(server: WebServer): Socket {
    mut client: Socket;
    
    unsafe {
        client.is_valid = false;
        client.fd = -1;

        if !server.socket.is_valid {
            return client;
        }

        platform windows {
            mut client_addr: $(sockaddr_in);
            mut addr_len: i32 = C.sizeof($(sockaddr_in));
            mut client_sock: SOCKET = C.accept(cast[SOCKET](server.socket.fd), cast[ref $(sockaddr)](addr(client_addr)), addr(addr_len));
            if client_sock != INVALID_SOCKET {
                client.fd = cast[i32](client_sock);
                client.is_valid = true;
                mut timeout: u_long = cast[u_long](server.config.timeout_seconds * 1000);
                C.setsockopt(client_sock, SOL_SOCKET, SO_RCVTIMEO, cast[val ref char](addr(timeout)), C.sizeof(u_long));
                C.setsockopt(client_sock, SOL_SOCKET, SO_SNDTIMEO, cast[val ref char](addr(timeout)), C.sizeof(u_long));
            }
        }
        platform posix {
            mut client_addr: $(sockaddr_in);
            mut addr_len: socklen_t = C.sizeof($(sockaddr_in));
            mut client_sock: i32 = C.accept(server.socket.fd, cast[ref $(sockaddr)](addr(client_addr)), addr(addr_len));
            if client_sock >= 0 {
                client.fd = client_sock;
                client.is_valid = true;
                mut timeout: $(timeval);
                timeout.tv_sec = server.config.timeout_seconds;
                timeout.tv_usec = 0;
                C.setsockopt(client_sock, SOL_SOCKET, SO_RCVTIMEO, addr(timeout), C.sizeof($(timeval)));
                C.setsockopt(client_sock, SOL_SOCKET, SO_SNDTIMEO, addr(timeout), C.sizeof($(timeval)));
            }
        }
    }
    
    return client;
}

/// Receive data from a socket
def socket_recv(socket: Socket, buffer_size: i32): string {
    mut result: string;
    
    result.data = nil;
    result.len = 0;
    result.cap = 0;

    if !socket.is_valid {
        return result;
    }

    mut buffer: ref char = cast[ref char](C.malloc(buffer_size));
    if !buffer {
        return result;
    }

    mut bytes_received: usize = 0;
    platform windows {
        bytes_received = C.recv(cast[SOCKET](socket.fd), buffer, buffer_size - 1, 0);
    }
    platform posix {
        bytes_received = C.recv(socket.fd, buffer, buffer_size - 1, 0);
    }

    if bytes_received > 0 {
        buffer[bytes_received] = '\0';
        result.data = buffer;
        result.len = bytes_received;
        result.cap = buffer_size;
    } else {
        C.free(cast[ref void](buffer));
    }
    
    return result;
}

/// Send data to a socket
def socket_send(socket: Socket, data: string): bool {
    mut success: bool = false;
    
    if !socket.is_valid {
        return success;
    }

    unsafe {
        platform windows {
            mut bytes_sent: i32 = C.send(cast[SOCKET](socket.fd), data.data, cast[i32](data.len), 0);
            success = (bytes_sent == cast[i32](data.len));
        }
        platform posix {
            mut bytes_sent: isize = C.send(socket.fd, data.data, cast[usize](data.len), 0);
            success = (bytes_sent == cast[isize](data.len));
        }
    }

    return success;
}

/// Close a socket
def socket_close(socket: Socket) {
    if socket.is_valid {
        platform windows {
            C.closesocket(cast[SOCKET](socket.fd));
        }
        platform posix {
            C.close(socket.fd);
        }
    }
}

/// Close the server socket
def server_close(server: WebServer) {
    if server.socket.is_valid {
        platform windows {
            C.closesocket(cast[SOCKET](server.socket.fd));
        }
        platform posix {
            C.close(server.socket.fd);
        }
    }
}

/// Parse HTTP request from raw data
def parse_http_request(rdata: string): HttpRequest {
    mut request: HttpRequest;
    request.method.data = nil;
    request.method.len = 0;
    request.method.cap = 0;
    request.path.data = nil;
    request.path.len = 0;
    request.path.cap = 0;
    request.headers.data = nil;
    request.headers.len = 0;
    request.headers.cap = 0;
    request.body.data = nil;
    request.body.len = 0;
    request.body.cap = 0;
    request.version.data = nil;
    request.version.len = 0;
    request.version.cap = 0;
    
    if rdata.len == 0 {
        return request;
    }
    
    unsafe {
        mut line_end: ref char = C.strstr(rdata.data, "\r\n");
        if line_end == nil {
            return request;
        }
        
        mut method_end: ref char = C.strchr(rdata.data, ' ');
        if method_end and method_end < line_end {
            val method_len: usize = method_end - rdata.data;
            request.method.data = cast[ref char](C.malloc(method_len + 1));
            if request.method.data != nil {
                C.memcpy(request.method.data, rdata.data, method_len);
                request.method.data[method_len] = '\0';
                request.method.len = method_len;
                request.method.cap = method_len + 1;
            }
            
            mut path_start: ref char = method_end + 1;
            mut path_end: ref char = C.strchr(path_start, ' ');
            if path_end and path_end < line_end {
                val path_len: usize = path_end - path_start;
                request.path.data = cast[ref char](C.malloc(path_len + 1));
                if request.path.data != nil {
                    C.memcpy(request.path.data, path_start, path_len);
                    request.path.data[path_len] = '\0';
                    request.path.len = path_len;
                    request.path.cap = path_len + 1;
                }
                
                mut version_start: ref char = path_end + 1;
                val version_len: usize = line_end - version_start;
                request.version.data = cast[ref char](C.malloc(version_len + 1));
                if request.version.data != nil {
                    C.memcpy(request.version.data, version_start, version_len);
                    request.version.data[version_len] = '\0';
                    request.version.len = version_len;
                    request.version.cap = version_len + 1;
                }
            }
        }
        
        mut headers_end: ref char = C.strstr(rdata.data, "\r\n\r\n");
        if headers_end != nil {
            mut headers_start: ref char = line_end + 2;
            val headers_len: usize = headers_end - headers_start;
            if headers_len > 0 {
                request.headers.data = cast[ref char](C.malloc(headers_len + 1));
                if request.headers.data != nil {
                    C.memcpy(request.headers.data, headers_start, headers_len);
                    request.headers.data[headers_len] = '\0';
                    request.headers.len = headers_len;
                    request.headers.cap = headers_len + 1;
                }
            }
            
            mut body_start: ref char = headers_end + 4;
            val body_len: usize = rdata.len - (body_start - rdata.data);
            if body_len > 0 {
                request.body.data = cast[ref char](C.malloc(body_len + 1));
                if request.body.data != nil {
                    C.memcpy(request.body.data, body_start, body_len);
                    request.body.data[body_len] = '\0';
                    request.body.len = body_len;
                    request.body.cap = body_len + 1;
                }
            }
        }
    }   
    return request;
}

/// Create an HTTP response string
def create_http_response(status_code: i32, content_type: string, body: string): string {
    mut response: string;
    
    raw {
        response.data = NULL;
        response.len = 0;
        response.cap = 0;
        
        const char* status_msg = "Unknown";
        switch (status_code) {
            case 200: status_msg = "OK"; break;
            case 201: status_msg = "Created"; break;
            case 204: status_msg = "No Content"; break;
            case 301: status_msg = "Moved Permanently"; break;
            case 302: status_msg = "Found"; break;
            case 400: status_msg = "Bad Request"; break;
            case 401: status_msg = "Unauthorized"; break;
            case 403: status_msg = "Forbidden"; break;
            case 404: status_msg = "Not Found"; break;
            case 500: status_msg = "Internal Server Error"; break;
            case 501: status_msg = "Not Implemented"; break;
            case 503: status_msg = "Service Unavailable"; break;
        }
        
        char content_len_str[32];
        snprintf(content_len_str, sizeof(content_len_str), "%zu", (size_t)body.len);
        
        size_t response_size = 
            strlen("HTTP/1.1 ") + 3 + strlen(" ") + strlen(status_msg) + strlen("\r\n") +
            strlen("Content-Type: ") + content_type.len + strlen("\r\n") +
            strlen("Content-Length: ") + strlen(content_len_str) + strlen("\r\n") +
            strlen("Server: axe-std.1.0\r\n") +
            strlen("Connection: close\r\n") +
            strlen("\r\n") +
            body.len;
        
        response.data = (char*)malloc(response_size + 1);
        if (response.data) {
            char* ptr = response.data;
            
            ptr += sprintf(ptr, "HTTP/1.1 %d %s\r\n", status_code, status_msg);
            ptr += sprintf(ptr, "Content-Type: %.*s\r\n", (int)content_type.len, content_type.data);
            ptr += sprintf(ptr, "Content-Length: %s\r\n", content_len_str);
            ptr += sprintf(ptr, "Server: axe-std.1.0\r\n");
            ptr += sprintf(ptr, "Connection: close\r\n");
            ptr += sprintf(ptr, "\r\n");
            
            if (body.len > 0) {
                memcpy(ptr, body.data, body.len);
                ptr += body.len;
            }
            
            response.len = ptr - response.data;
            response.cap = response_size + 1;
            response.data[response.len] = '\0';
        }
    }
    
    return response;
}

/// Send an HTTP response to a client
def send_http_response(client: Socket, status_code: i32, content_type: string, body: string): bool {
    mut response_str: string = create_http_response(status_code, content_type, body);
    mut success: bool = socket_send(client, response_str);
    
    raw {
        if (response_str.data != NULL) {
            free(response_str.data);
        }
    }
    
    return success;
}

/// Free HTTP request memory
def free_request(request: HttpRequest) {
    unsafe {
        if request.method.data != nil {
            C.free(request.method.data);
        }
        if request.path.data != nil {
            C.free(request.path.data);
        }
        if request.headers.data != nil {
            C.free(request.headers.data);
        }
        if request.body.data != nil {
            C.free(request.body.data);
        }
        if request.version.data != nil {
            C.free(request.version.data);
        }
    }
}

test {
    curl_init();
    
    assert is_success_status(200), "200 should be success status";
    assert is_success_status(204), "204 should be success status";
    assert !is_success_status(404), "404 should not be success status";
    
    assert is_redirect_status(301), "301 should be redirect status";
    assert is_redirect_status(302), "302 should be redirect status";
    assert !is_redirect_status(200), "200 should not be redirect status";
    
    assert is_client_error_status(404), "404 should be client error status";
    assert is_client_error_status(403), "403 should be client error status";
    assert !is_client_error_status(500), "500 should not be client error status";
    
    assert is_server_error_status(500), "500 should be server error status";
    assert is_server_error_status(503), "503 should be server error status";
    assert !is_server_error_status(404), "404 should not be server error status";
    
    mut test_string: string = string.create("hello world");
    mut encoded: string = url_encode(test_string);
    assert encoded.len > 0, "URL encoding should produce output";
    
    mut decoded: string = url_decode(encoded);
    assert decoded.len > 0, "URL decoding should produce output";
    
    mut special: string = string.create("test@example.com");
    mut encoded_special: string = url_encode(special);
    assert encoded_special.len >= special.len, "Encoded special chars should be at least as long";
    
    mut response: HttpResponse = http_get(string.create("http://example.com"));
    
    if response.success {
        assert response.status_code > 0, "Response should have status code";
        assert response.body.len > 0, "Response body should have content";
        println_str(string.create("HTTP GET test passed"));
    }
    
    free_response(response);    
    curl_cleanup();
}
