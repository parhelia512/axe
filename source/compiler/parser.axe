/// Author: Navid Momtahen (C) 2025
/// License: GPL-3.0
/// 
/// Handles the parsing process - converts tokens into an AST

use lexer (
    Token, 
    TokenType, lex
);

use structs (
    ASTNode,
    ParserContext,
    Scope
);

use imports (is_symbol_imported);
use gstate;
use std.string;
use std.io;
use std.maps;
use std.arena;
use std.errors;
use std.os;

mut g_type_aliases: StringStringMap;
mut g_imported_modules: StringBoolMap;
mut g_list_of_types: StringStringMap;
mut g_var_mutability: StringBoolMap;
mut g_var_actually_mutated: StringBoolMap;
mut g_mutable_vars_in_scope: list(string);
mut g_all_vars_in_scope: list(string);
mut g_var_actually_used: StringBoolMap;
mut g_var_declaration_lines: StringIntMap;
mut g_var_declaration_files: StringStringMap;
mut g_var_scope_depth: StringIntMap;
mut g_current_scope_depth: i32;
mut g_function_has_raw_block: bool;
mut g_check_shadowing: bool;
mut g_macro_names: list(string);
mut g_macro_defs: list(MacroDef);

/// Initialize the state-related globals
pub def initialize_all() {
    mut arena: Arena = Arena.create(1024 * 1024);
    g_type_aliases = deref(StringStringMap.create(addr(arena), 128));
    g_imported_modules = deref(StringBoolMap.create(addr(arena), 128));
    g_list_of_types = deref(StringStringMap.create(addr(arena), 128));
    g_var_mutability = deref(StringBoolMap.create(addr(arena), 128));
    g_var_actually_mutated = deref(StringBoolMap.create(addr(arena), 128));
    g_mutable_vars_in_scope.len = 0;
    g_all_vars_in_scope.len = 0;
    g_var_actually_used = deref(StringBoolMap.create(addr(arena), 128));
    g_var_declaration_lines = deref(StringIntMap.create(addr(arena), 128));
    g_var_declaration_files = deref(StringStringMap.create(addr(arena), 128));
    g_var_scope_depth = deref(StringIntMap.create(addr(arena), 128));
    g_current_scope_depth = 0;
    g_check_shadowing = false;
    g_macro_names.len = 0;
    g_macro_defs.len = 0;
}

/// Register a macro definition
def macros_add(name: string, defn: MacroDef) {
    mut i: i32 = 0;
    loop {
        if i >= len(g_macro_names) {
            break;
        }
        if compare(g_macro_names.data[i], name) == 0 {
            g_macro_defs.data[i] = defn;
            return;
        }
        i++;
    }

    append(g_macro_names, name);
    append(g_macro_defs, defn);
}

/// Check if a macro with the given name exists
def macros_contains(name: string): bool {
    mut i: i32 = 0;
    loop {
        if i >= len(g_macro_names) {
            break;
        }
        if compare(g_macro_names.data[i], name) == 0 {
            return true;
        }
        i++;
    }
    return false;
}

/// Get a macro definition by name
def macros_get(name: string): MacroDef {
    mut i: i32 = 0;
    loop {
        if i >= len(g_macro_names) {
            break;
        }
        if compare(g_macro_names.data[i], name) == 0 {
            return g_macro_defs.data[i];
        }
        i++;
    }

    mut empty: MacroDef;
    return empty;
}

/// Check if a string consists only of decimal digits (for macro arg classification)
def is_all_digits(s: string): bool {
    if str_len(s) == 0 {
        return false;
    }
    mut i: i32 = 0;
    loop {
        if i >= str_len(s) {
            break;
        }
        val ch: char = get_char(s, i);
        if ch < '0' or ch > '9' {
            return false;
        }
        i++;
    }
    return true;
}

/// Expand macro calls inline within an expression string
///
/// This handles macros that appear within expressions (e.g., assert, return, assignments)
def expand_macros_in_expression(expr: string): string {
    mut result: StringBuilder = StringBuilder.init(512);
    mut i: i32 = 0;
    val expr_len: i32 = str_len(expr);
    
    loop {
        if i >= expr_len {
            break;
        }
        
        loop {
            if i >= expr_len {
                break;
            }
            val ch: char = get_char(expr, i);
            if ch != ' ' and ch != '\t' {
                break;
            }
            StringBuilder.append_char(addr(result), ch);
            i++;
        }
        
        if i >= expr_len {
            break;
        }
        
        val ch: char = get_char(expr, i);
        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' {
            val ident_start: i32 = i;
            loop {
                if i >= expr_len {
                    break;
                }
                val c: char = get_char(expr, i);
                if !((c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or (c >= '0' and c <= '9') or c == '_') {
                    break;
                }
                i++;
            }
            val ident: string = substring_se(expr, ident_start, i);
            
            val ws_start: i32 = i;
            loop {
                if i >= expr_len {
                    break;
                }
                val ws: char = get_char(expr, i);
                if ws != ' ' and ws != '\t' {
                    break;
                }
                i++;
            }
            val ws_after: string = substring_se(expr, ws_start, i);
            
            if i < expr_len and get_char(expr, i) == '(' and macros_contains(ident) {
                i++;  // skip '('
                
                mut args: list(string);
                mut current_arg: StringBuilder = StringBuilder.init(128);
                mut paren_depth: i32 = 0;
                
                loop {
                    if i >= expr_len {
                        break;
                    }
                    
                    val c: char = get_char(expr, i);
                    
                    if c == '(' {
                        paren_depth++;
                        StringBuilder.append_char(addr(current_arg), c);
                    } elif c == ')' {
                        if paren_depth == 0 {
                            val arg_str: string = strip(StringBuilder.to_string(addr(current_arg)));
                            if str_len(arg_str) > 0 {
                                append(args, arg_str);
                            }
                            StringBuilder.destroy(addr(current_arg));
                            i++;  // skip ')'
                            break;
                        } else {
                            paren_depth--;
                            StringBuilder.append_char(addr(current_arg), c);
                        }
                    } elif c == ',' and paren_depth == 0 {
                        val arg_str: string = strip(StringBuilder.to_string(addr(current_arg)));
                        if str_len(arg_str) > 0 {
                            append(args, arg_str);
                        }
                        StringBuilder.destroy(addr(current_arg));
                        current_arg = StringBuilder.init(128);
                    } else {
                        StringBuilder.append_char(addr(current_arg), c);
                    }
                    
                    i++;
                }
                
                val defn: MacroDef = macros_get(ident);
                mut expanded: StringBuilder = StringBuilder.init(256);
                mut tok_idx: i32 = 0;
                
                loop {
                    if tok_idx >= len(defn.body) {
                        break;
                    }
                    
                    val tok: Token = defn.body.data[tok_idx];
                    
                    if tok.token_type == TokenType.IDENTIFIER {
                        mut found_param: bool = false;
                        mut param_idx: i32 = 0;
                        loop {
                            if param_idx >= len(defn.params) or param_idx >= len(args) {
                                break;
                            }
                            if compare(tok.value, defn.params.data[param_idx]) == 0 {
                                val arg_expanded: string = expand_macros_in_expression(args.data[param_idx]);
                                StringBuilder.append(addr(expanded), arg_expanded);
                                found_param = true;
                                break;
                            }
                            param_idx++;
                        }
                        
                        if !found_param {
                            StringBuilder.append(addr(expanded), tok.value);
                        }
                    } elif tok.token_type == TokenType.STR {
                        StringBuilder.append_char(addr(expanded), '"');
                        StringBuilder.append(addr(expanded), tok.value);
                        StringBuilder.append_char(addr(expanded), '"');
                    } elif tok.token_type == TokenType.CHAR {
                        StringBuilder.append_char(addr(expanded), '\'');
                        StringBuilder.append(addr(expanded), tok.value);
                        StringBuilder.append_char(addr(expanded), '\'');
                    } elif tok.token_type != TokenType.WHITESPACE and tok.token_type != TokenType.NEWLINE {
                        StringBuilder.append(addr(expanded), tok.value);
                    } else {
                        StringBuilder.append_char(addr(expanded), ' ');
                    }
                    
                    tok_idx++;
                }
                
                val expanded_text: string = StringBuilder.to_string(addr(expanded));
                StringBuilder.destroy(addr(expanded));
                
                val fully_expanded: string = expand_macros_in_expression(expanded_text);
                StringBuilder.append(addr(result), fully_expanded);
            } else {
                StringBuilder.append(addr(result), ident);
                StringBuilder.append(addr(result), ws_after);
            }
        } else {
            StringBuilder.append_char(addr(result), ch);
            i++;
        }
    }
    
    val final_result: string = StringBuilder.to_string(addr(result));
    StringBuilder.destroy(addr(result));
    return final_result;
}

/// Register a variable's mutability (true for mut, false for val)
def register_variable(var_name: string, is_mutable: bool, line_num: i32, source_file: string) {
    mut arena: Arena = Arena.create(1024);
    debug_print_raw "\n[DEBUG] register_variable:";
    debug_print_raw "\n[DEBUG]   name:";
    debug_print_str var_name;
    debug_print_raw "\n[DEBUG]   is_mutable:";
    if is_mutable {
        debug_print_raw "true";
    } else {
        debug_print_raw "false";
    }
    
    if StringBoolMap.contains(addr(g_var_mutability), var_name) {
        if StringIntMap.contains(addr(g_var_scope_depth), var_name) {
            val prev_depth: i32 = StringIntMap.get(addr(g_var_scope_depth), var_name);
            
            if prev_depth < g_current_scope_depth {
                val prev_line: i32 = StringIntMap.get(addr(g_var_declaration_lines), var_name);
                val prev_file: string = StringStringMap.get(addr(g_var_declaration_files), var_name);
                
                print source_file;
                print ":";
                print(i32_to_string(line_num));
                print ": error: variable '";
                print var_name;
                print "' shadows previously declared variable at ";
                print prev_file;
                print ":";
                print(i32_to_string(prev_line));
                println "";
                quit(1);
            }
        }
    }
    
    if g_check_shadowing and is_symbol_imported(var_name) {
        print source_file;
        print ":";
        print(i32_to_string(line_num));
        print ": error: variable '";
        print var_name;
        print "' shadows imported symbol '";
        print var_name;
        println "'";
        quit(1);
    }
    
    StringBoolMap.set(addr(g_var_mutability), addr(arena), var_name, is_mutable);
    StringIntMap.set(addr(g_var_declaration_lines), addr(arena), var_name, line_num);
    StringStringMap.set(addr(g_var_declaration_files), addr(arena), var_name, source_file);
    StringIntMap.set(addr(g_var_scope_depth), addr(arena), var_name, g_current_scope_depth);
    register_for_usage_tracking(var_name);
}

/// Register a mutable variable for mutation tracking (only for vars with initializers)
def register_for_mutation_tracking(var_name: string) {
    append(g_mutable_vars_in_scope, var_name);
}

/// Register a variable for usage tracking
def register_for_usage_tracking(var_name: string) {
    append(g_all_vars_in_scope, var_name);
}

/// Push a new scope level (when entering blocks like loops, if-statements, etc.)
def push_scope() {
    g_current_scope_depth = g_current_scope_depth + 1;
}

/// Pop a scope level and clear variables declared at that depth
def pop_scope() {
    if g_current_scope_depth <= 0 {
        return;
    }
    
    mut i: i32 = 0;
    loop {
        if i >= len(g_all_vars_in_scope) {
            break;
        }
        val var_name: string = g_all_vars_in_scope.data[i];
        if StringIntMap.contains(addr(g_var_scope_depth), var_name) {
            val var_depth: i32 = StringIntMap.get(addr(g_var_scope_depth), var_name);
            if var_depth == g_current_scope_depth {
                StringBoolMap.pop(addr(g_var_mutability), var_name);
                StringIntMap.pop(addr(g_var_declaration_lines), var_name);
                StringStringMap.pop(addr(g_var_declaration_files), var_name);
                StringIntMap.pop(addr(g_var_scope_depth), var_name);
            }
        }
        i++;
    }
    
    g_current_scope_depth = g_current_scope_depth - 1;
}

/// Clear only local variables (scope depth > 0), preserving globals
def clear_local_variables() {
    mut new_all_vars: list(string);
    mut new_mut_vars: list(string);
    mut i: i32 = 0;

    loop {
        if i >= len(g_all_vars_in_scope) {
            break;
        }
        val var_name: string = g_all_vars_in_scope.data[i];
        if StringIntMap.contains(addr(g_var_scope_depth), var_name) {
            val var_depth: i32 = StringIntMap.get(addr(g_var_scope_depth), var_name);
            if var_depth == 0 {
                append(new_all_vars, var_name);
            } else {
                StringBoolMap.pop(addr(g_var_mutability), var_name);
                StringBoolMap.pop(addr(g_var_actually_mutated), var_name);
                StringBoolMap.pop(addr(g_var_actually_used), var_name);
                StringIntMap.pop(addr(g_var_declaration_lines), var_name);
                StringStringMap.pop(addr(g_var_declaration_files), var_name);
                StringIntMap.pop(addr(g_var_scope_depth), var_name);
            }
        }
        i++;
    }
    
    mut j: i32 = 0;
    loop {
        if j >= len(new_all_vars) {
            break;
        }
        val var_name: string = new_all_vars.data[j];
        if StringBoolMap.contains(addr(g_var_mutability), var_name) {
            if StringBoolMap.get(addr(g_var_mutability), var_name) {
                append(new_mut_vars, var_name);
            }
        }
        j++;
    }
    
    g_all_vars_in_scope = new_all_vars;
    g_mutable_vars_in_scope = new_mut_vars;
}

/// Check if a variable has been declared (tracked in mutability map)
def is_variable_declared(var_name: string): bool {
    val declared: bool = StringBoolMap.contains(addr(g_var_mutability), var_name);
    debug_print_raw "\n[DEBUG] is_variable_declared:";
    debug_print_str var_name;
    if declared {
        debug_print_raw "\n[DEBUG]   declared: true";
    } else {
        debug_print_raw "\n[DEBUG]   declared: false";
    }
    return declared;
}

/// Check if a variable is mutable; undeclared variables are treated as mutable here
def is_variable_mutable(var_name: string): bool {
    if !is_variable_declared(var_name) {
        debug_print_raw "\n[DEBUG] is_variable_mutable: not declared, treating as mutable:";
        debug_print_str var_name;
        return true;
    }
    val mut_val: bool = StringBoolMap.get(addr(g_var_mutability), var_name);
    debug_print_raw "\n[DEBUG] is_variable_mutable:";
    debug_print_str var_name;
    if mut_val {
        debug_print_raw "\n[DEBUG]   mutable: true";
    } else {
        debug_print_raw "\n[DEBUG]   mutable: false";
    }
    return mut_val;
}

/// Mark a variable as actually mutated
def mark_variable_mutated(var_name: string) {
    mut arena: Arena = Arena.create(512);
    StringBoolMap.set(addr(g_var_actually_mutated), addr(arena), var_name, true);
}

/// Mark a variable as used (referenced)
def mark_variable_used(var_name: string) {
    mut arena: Arena = Arena.create(512);
    StringBoolMap.set(addr(g_var_actually_used), addr(arena), var_name, true);
}

/// Scan an expression for variable references and mark them as used
def scan_expression_for_usage(expr: string) {
    mut pos: i32 = 0;
    loop {
        if pos >= str_len(expr) {
            break;
        }
        
        val ch: char = get_char(expr, pos);
        
        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' {
            val id_start: i32 = pos;
            mut id_end: i32 = pos;
            loop {
                if id_end >= str_len(expr) {
                    break;
                }
                val ich: char = get_char(expr, id_end);
                if (ich >= 'a' and ich <= 'z') or (ich >= 'A' and ich <= 'Z') or (ich >= '0' and ich <= '9') or ich == '_' {
                    id_end = id_end + 1;
                } else {
                    break;
                }
            }
            
            val var_name: string = substring_se(expr, id_start, id_end);
            
            if str_len(var_name) > 0 and is_variable_declared(var_name) {
                mark_variable_used(var_name);
            }
            
            pos = id_end;
        } else {
            pos++;
        }
    }
}

/// Check if string contains "C." (for detecting C function calls)
/// Handles whitespace between C and .
def contains_c_call(s: string): bool {
    if s.len < 2 {
        return false;
    }
    mut i: usize = 0;
    loop {
        if i >= s.len {
            break;
        }
        if s.data[i] == 'C' {
            // Found 'C', now skip whitespace and look for '.'
            mut j: usize = i + 1;
            loop {
                if j >= s.len {
                    break;
                }
                val ch: char = s.data[j];
                if ch == ' ' or ch == '\t' {
                    j++;
                    continue;
                }
                if ch == '.' {
                    return true;
                }
                break;
            }
        }
        i++;
    }
    return false;
}

/// Scan an expression string for addr() calls and mark those variables as mutated
def scan_expression_for_addr(expr: string) {
    mut pos: i32 = 0;
    loop {
        if pos >= str_len(expr) {
            break;
        }
        
        // Look for "addr"
        if pos + 4 <= str_len(expr) {
            val substr: string = substring_se(expr, pos, pos + 4);
            if equals_c(substr, "addr") {
                // Skip whitespace after "addr"
                mut scan_pos: i32 = pos + 4;
                loop {
                    if scan_pos >= str_len(expr) {
                        break;
                    }
                    val ch: char = get_char(expr, scan_pos);
                    if ch != ' ' and ch != '\t' {
                        break;
                    }
                    scan_pos++;
                }
                
                if scan_pos < str_len(expr) and get_char(expr, scan_pos) == '(' {
                    scan_pos++;
                    
                    val arg_start: i32 = scan_pos;
                    mut arg_end: i32 = scan_pos;
                    mut paren_depth: i32 = 1;
                    
                    loop {
                        if arg_end >= str_len(expr) {
                            break;
                        }
                        val ach: char = get_char(expr, arg_end);
                        if ach == '(' {
                            paren_depth = paren_depth + 1;
                        } elif ach == ')' {
                            paren_depth = paren_depth - 1;
                            if paren_depth == 0 {
                                break;
                            }
                        }
                        arg_end++;
                    }
                    
                    if arg_end > arg_start {
                        val arg: string = strip(substring_se(expr, arg_start, arg_end));
                        
                        // Extract just the variable name (before any . or *)
                        mut var_name: string = arg;
                        val dot_pos: i32 = find_char_from(var_name, '.', 0);
                        val star_pos: i32 = find_char_from(var_name, '*', 0);
                        if dot_pos > 0 {
                            var_name = strip(substring_se(var_name, 0, dot_pos));
                        } elif star_pos > 0 {
                            var_name = strip(substring_se(var_name, 0, star_pos));
                        }
                        
                        // Mark variable as mutated (will only affect tracked variables)
                        if str_len(var_name) > 0 {
                            mark_variable_mutated(var_name);
                        }
                    }
                }
            }
        }
        
        pos++;
    }
}

/// Scan expression for variables used in C function calls
/// If an expression contains "C." it means we're calling C code,
/// and any mutable variables in that expression should be marked as mutated
def scan_expression_for_c_calls(expr: string) {
    // Check if expression contains "C."
    if !contains_c_call(expr) {
        return;
    }
    
    // Expression contains C function calls - mark all mutable variables as mutated
    mut pos: i32 = 0;
    loop {
        if pos >= str_len(expr) {
            break;
        }
        
        val ch: char = get_char(expr, pos);
        
        // Look for identifiers (variable names)
        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' {
            val id_start: i32 = pos;
            mut id_end: i32 = pos;
            loop {
                if id_end >= str_len(expr) {
                    break;
                }
                val ich: char = get_char(expr, id_end);
                if (ich >= 'a' and ich <= 'z') or (ich >= 'A' and ich <= 'Z') or (ich >= '0' and ich <= '9') or ich == '_' {
                    id_end = id_end + 1;
                } else {
                    break;
                }
            }
            
            val var_name: string = substring_se(expr, id_start, id_end);
            
            // If this is a declared variable, mark it as used
            if str_len(var_name) > 0 and is_variable_declared(var_name) {
                mark_variable_used(var_name);
                // If mutable, also mark as mutated since C calls might modify it
                if is_variable_mutable(var_name) {
                    mark_variable_mutated(var_name);
                }
            }
            
            pos = id_end;
        } else {
            pos = pos + 1;
        }
    }
}

/// Scan function arguments for variables that might be passed by reference
/// This marks variables as mutated if they're passed as arguments (potential ref params)
def scan_function_args_for_ref_params(args_str: string) {
    // Split arguments by comma (handling nested parens/brackets)
    mut args: list(string);
    mut current_arg: StringBuilder = StringBuilder.init(128);
    mut depth: i32 = 0;
    mut i: i32 = 0;
    
    loop {
        if i >= str_len(args_str) {
            break;
        }
        
        val ch: char = get_char(args_str, i);
        
        if ch == '(' or ch == '[' {
            depth = depth + 1;
            StringBuilder.append_char(addr(current_arg), ch);
        } elif ch == ')' or ch == ']' {
            depth = depth - 1;
            StringBuilder.append_char(addr(current_arg), ch);
        } elif ch == ',' and depth == 0 {
            val arg: string = strip(StringBuilder.to_string(addr(current_arg)));
            if str_len(arg) > 0 {
                append(args, arg);
            }
            StringBuilder.destroy(addr(current_arg));
            current_arg = StringBuilder.init(128);
        } else {
            StringBuilder.append_char(addr(current_arg), ch);
        }
        
        i = i + 1;
    }
    
    // Don't forget the last argument
    val last_arg: string = strip(StringBuilder.to_string(addr(current_arg)));
    if str_len(last_arg) > 0 {
        append(args, last_arg);
    }
    StringBuilder.destroy(addr(current_arg));
    
    // Check each argument - if it's a simple identifier, mark it as potentially mutated
    mut arg_idx: i32 = 0;
    loop {
        if arg_idx >= len(args) {
            break;
        }
        
        val arg: string = args.data[arg_idx];
        
        // Skip if argument contains operators, function calls, or member access
        // (these indicate it's not a simple variable reference)
        mut is_simple_var: bool = true;
        mut j: i32 = 0;
        loop {
            if j >= str_len(arg) {
                break;
            }
            val c: char = get_char(arg, j);
            if c == '(' or c == ')' or c == '.' or c == '+' or c == '-' or c == '*' or c == '/' or c == '[' or c == ']' {
                is_simple_var = false;
                break;
            }
            j = j + 1;
        }
        
        // If it's a simple identifier, mark it as used and mutated (might be passed by ref)
        if is_simple_var and str_len(arg) > 0 {
            val first_ch: char = get_char(arg, 0);
            if (first_ch >= 'a' and first_ch <= 'z') or (first_ch >= 'A' and first_ch <= 'Z') or first_ch == '_' {
                mark_variable_used(arg);
                mark_variable_mutated(arg);
            }
        }
        
        arg_idx = arg_idx + 1;
    }
}

/// Check if an identifier is NULL and report an error.
def check_null_usage(ctx: ref ParserContext, ident: string) {
    if equals_c(ident, "NULL") {
        print ctx.filename;
        print ":";
        print(i32_to_string(current_line(ctx)));
        println ": error: usage of raw NULL is prohibited, use 'nil' instead.";
        unsafe {
            C.exit(1);
        }
    }
}

/// Check if an expression contains a function call (identifier followed by '(')
def has_function_call_in_expression(expr: string): bool {
    mut i: i32 = 0;
    val expr_len: i32 = str_len(expr);
    
    loop {
        if i >= expr_len {
            break;
        }
        
        val ch: char = get_char(expr, i);
        
        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' {
            val id_start: i32 = i;
            mut id_end: i32 = i;
            loop {
                if id_end >= expr_len {
                    break;
                }
                val ich: char = get_char(expr, id_end);
                if (ich >= 'a' and ich <= 'z') or (ich >= 'A' and ich <= 'Z') or (ich >= '0' and ich <= '9') or ich == '_' {
                    id_end++;
                } else {
                    break;
                }
            }
            
            val ident: string = substring_se(expr, id_start, id_end);
            
            mut j: i32 = id_end;
            loop {
                if j >= expr_len {
                    break;
                }
                val wch: char = get_char(expr, j);
                if wch == ' ' or wch == '\t' or wch == '\n' {
                    j++;
                } else {
                    break;
                }
            }
            
            if j < expr_len and get_char(expr, j) == '(' {
                if !equals_c(ident, "new") and !equals_c(ident, "cast") {
                    return true;
                }
            }
            
            i = id_end;
        } else {
            i++;
        }
    }
    
    return false;
}

/// Extract the function name from an expression that contains a function call
def extract_function_name(expr: string): string {
    mut i: i32 = 0;
    val expr_len: i32 = str_len(expr);
    
    loop {
        if i >= expr_len {
            break;
        }
        
        val ch: char = get_char(expr, i);

        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' {
            val id_start: i32 = i;
            mut id_end: i32 = i;
            loop {
                if id_end >= expr_len {
                    break;
                }
                val ich: char = get_char(expr, id_end);
                if (ich >= 'a' and ich <= 'z') or (ich >= 'A' and ich <= 'Z') or (ich >= '0' and ich <= '9') or ich == '_' {
                    id_end = id_end + 1;
                } else {
                    break;
                }
            }
            
            val ident: string = substring_se(expr, id_start, id_end);
            
            mut j: i32 = id_end;
            loop {
                if j >= expr_len {
                    break;
                }
                val wch: char = get_char(expr, j);
                if wch == ' ' or wch == '\t' or wch == '\n' {
                    j = j + 1;
                } else {
                    break;
                }
            }
            
            if j < expr_len and get_char(expr, j) == '(' {
                if !equals_c(ident, "new") and !equals_c(ident, "cast") {
                    return concat(ident, str("()"));
                }
            }
            
            i = id_end;
        } else {
            i++;
        }
    }
    
    return str("<unknown function>");
}

/// Check if a type string contains raw pointer syntax (e.g., "char*", "int*")
def has_pointer_syntax(type_str: string): bool {
    val len: i32 = str_len(type_str);
    if len == 0 {
        return false;
    }
    
    mut i: i32 = 0;
    loop {
        if i >= len {
            break;
        }
        val ch: char = get_char(type_str, i);
        if ch == '*' {
            if i > 0 {
                val prev_ch: char = get_char(type_str, i - 1);
                if (prev_ch >= 'a' and prev_ch <= 'z') or (prev_ch >= 'A' and prev_ch <= 'Z') or 
                   (prev_ch >= '0' and prev_ch <= '9') or prev_ch == '_' {
                    return true;
                }
            }
        }
        i++;
    }
    return false;
}

/// Add a child AST node to a parent AST node
pub def add_child_to_ast(ast: ref ASTNode, child: ASTNode) {
    if ast.children == nil {
        unsafe {
            mut new_list: list(ASTNode);
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(new_list), list_size);
                ast.children = heap_list;
            }
        }
    }
    
    if ast.children != nil {
        unsafe {
            mut temp_list: list(ASTNode);
            val list_size: usize = C.sizeof(list(ASTNode));
            C.memcpy(addr(temp_list), ast.children, list_size);
            append(temp_list, child);          
            C.memcpy(ast.children, addr(temp_list), list_size);
        }
    }
}

/// Parse the tokens into an AST
pub def parse(tokens: ref list(Token), is_axec: bool, check_entry_point: bool, current_module: string, filename: string): ASTNode {
    mut ctx: ParserContext;
    ctx.tokens = tokens;
    ctx.pos = 0;
    ctx.is_axec = is_axec;
    ctx.check_entry_point = check_entry_point;
    ctx.current_module = current_module;
    ctx.filename = filename;
    
    g_check_shadowing = check_entry_point;
    
    debug_print_raw "=== DEBUG TOKENS ===";
    mut i: i32 = 0;
    loop {
        if i >= len(ctx.tokens) {
            break;
        }
        val t: Token = ctx.tokens.data[i];
        debug_print_i32 i;
        debug_print_i32 t.token_type;
        debug_print_str t.value;
        i = i + 1;
    }
    debug_print_raw "=== END TOKENS ===";

    mut ast: ASTNode;
    ast.node_type = str("Program");
    ast.line = 1;
    
    StringStringMap.clear(addr(g_type_aliases));
    StringBoolMap.clear(addr(g_imported_modules));
    StringStringMap.clear(addr(g_list_of_types));
    StringBoolMap.clear(addr(g_var_mutability));
    
    if str_len(current_module) > 0 {
        // g_imported_modules[current_module] = true
        debug_print_raw "Auto-imported current module: ";
        debug_print_str current_module;
    }
    
    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        skip_whitespace(addr(ctx));        
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        parse_top_level(addr(ctx), addr(ast));
    }
    
    return ast;
}

/// Parse a top-level construct (use, def, model, enum, val, mut val, etc.)
def parse_top_level(ctx: ref ParserContext, ast: ref ASTNode) {
    if ctx.pos >= len(ctx.tokens) {
        return;
    }
    
    val token_type = ctx.tokens.data[ctx.pos].token_type;
    
    if token_type == TokenType.COMMENT {
        ctx.pos++;
        return;
    }
    
    if token_type == TokenType.USE {
        mut node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(node.node_type) > 0 {
            add_child_to_ast(ast, node);
        }
        return;
    }

    if token_type == TokenType.IDENTIFIER {
        val ident_tok: Token = ctx.tokens.data[ctx.pos];
        val ident_name: string = ident_tok.value;
        check_null_usage(ctx, ident_name);

        if macros_contains(ident_name) {
            ctx.pos = ctx.pos + 1; // skip macro name
            skip_whitespace(ctx);

            if !expect(ctx, TokenType.LPAREN) {
                mut err: string = str("Expected '(' after macro name");
                err = concat(err, str(" instead got "));
                err = concat(err, ctx.tokens.data[ctx.pos].value);
                enforce(false, error.create(err.data));
                return;
            }
            consume(ctx); // '('

            mut args: list(string);
            mut current_arg: string = str("");
            mut paren_depth: i32 = 0;

            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                val t: Token = peek(ctx);

                if t.token_type == TokenType.RPAREN and paren_depth == 0 {
                    val trimmed: string = strip(current_arg);
                    if str_len(trimmed) > 0 {
                        append(args, trimmed);
                    }
                    consume(ctx);
                    break;
                }

                if t.token_type == TokenType.LPAREN {
                    paren_depth = paren_depth + 1;
                    current_arg = concat(current_arg, t.value);
                    consume(ctx);
                    continue;
                }

                if t.token_type == TokenType.RPAREN {
                    paren_depth = paren_depth - 1;
                    current_arg = concat(current_arg, t.value);
                    consume(ctx);
                    continue;
                }

                if t.token_type == TokenType.COMMA and paren_depth == 0 {
                    val trimmed_arg: string = strip(current_arg);
                    if str_len(trimmed_arg) > 0 {
                        append(args, trimmed_arg);
                    }
                    current_arg = str("");
                    consume(ctx);
                    continue;
                }

                if t.token_type == TokenType.STR {
                    current_arg = concat(current_arg, str("\""));
                    current_arg = concat(current_arg, t.value);
                    current_arg = concat(current_arg, str("\""));
                } elif t.token_type == TokenType.CHAR {
                    current_arg = concat(current_arg, str("'"));
                    current_arg = concat(current_arg, t.value);
                    current_arg = concat(current_arg, str("'"));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    current_arg = concat(current_arg, str(" "));
                } else {
                    current_arg = concat(current_arg, t.value);
                }
                consume(ctx);
            }

            skip_whitespace(ctx);

            if !expect(ctx, TokenType.SEMICOLON) {
                mut err: string = format_error(ctx, str("Expected ';' after macro invocation"));
                enforce_raw(false, err.data);
                return;
            }
            consume(ctx);

            val defn: MacroDef = macros_get(ident_name);
            mut expanded_tokens: list(Token);
            mut i_tok: i32 = 0;

            loop {
                if i_tok >= len(defn.body) {
                    break;
                }
                append(expanded_tokens, defn.body.data[i_tok]);
                i_tok = i_tok + 1;
            }

            mut i_param: i32 = 0;
            loop {
                if i_param >= len(defn.params) or i_param >= len(args) {
                    break;
                }

                val param_name: string = defn.params.data[i_param];
                val arg_expr: string = args.data[i_param];

                mut j_tok: i32 = 0;
                loop {
                    if j_tok >= len(expanded_tokens) {
                        break;
                    }

                    if expanded_tokens.data[j_tok].token_type == TokenType.IDENTIFIER {
                        mut exp_token: ref Token = addr(expanded_tokens.data[j_tok]);
                        if compare(exp_token.value, param_name) == 0 {
                            exp_token.value = arg_expr;

                            if is_all_digits(arg_expr) {
                                exp_token.token_type = TokenType.NUMBER;
                            }
                        }
                    }
                    j_tok = j_tok + 1;
                }

                i_param = i_param + 1;
            }

            val expanded_ref: ref list(Token) = addr(expanded_tokens);
            val expanded_ast: ASTNode = parse(expanded_ref, ctx.is_axec, false, ctx.current_module, ctx.filename);

            if expanded_ast.children != nil {
                mut k: i32 = 0;
                loop {
                    if k >= deref(expanded_ast.children).len {
                        break;
                    }
                    add_child_to_ast(ast, expanded_ast.children.data[k]);
                    k = k + 1;
                }
            }

            return;
        }
    }
    
    if token_type == TokenType.MAIN {
        ctx.pos++;
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            mut err: string = format_error(ctx, str("Expected '{' after 'def main()'"));
            enforce_raw(false, err.data);
            return;
        }
        ctx.pos++; // Skip '{'
        
        clear_local_variables();
        g_function_has_raw_block = false;
        g_current_scope_depth = 1;
        
        mut main_node: ASTNode;
        main_node.node_type = str("Function");
        main_node.data.function.name = str("main");
        main_node.data.function.return_type = str("");
        main_node.data.function.is_public = false;
        
        unsafe {
            mut empty_params: list(string);
            val params_size: usize = C.sizeof(list(string));
            val heap_params: ref list(string) = cast[ref list(string)](C.malloc(params_size));
            if heap_params != nil {
                C.memcpy(heap_params, addr(empty_params), params_size);
                main_node.data.function.params = heap_params;
            }
        }
        
        mut children: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            skip_whitespace(ctx);
            
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                ctx.pos++; // Skip '}'
                break;
            }
            
            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(children, stmt);
            }
        }
        
        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(children), list_size);
                main_node.children = heap_list;
            }
        }
        
        if !g_function_has_raw_block {
            mut i_mut: i32 = 0;
            loop {
                if i_mut >= len(g_mutable_vars_in_scope) {
                    break;
                }
                val var_name: string = g_mutable_vars_in_scope.data[i_mut];
                
                if StringIntMap.contains(addr(g_var_scope_depth), var_name) {
                    val var_depth: i32 = StringIntMap.get(addr(g_var_scope_depth), var_name);
                    if var_depth == 0 {
                        i_mut++;
                        continue;
                    }
                }
                
                if !StringBoolMap.contains(addr(g_var_actually_mutated), var_name) {
                    print ctx.filename;
                    print ":";
                    print(i32_to_string(1));
                    print ": error: variable '";
                    print var_name;
                    println "' is declared 'mut' but is never mutated. Use 'val' instead.";
                    quit(1);
                }
                i_mut++;
            }
        }
        
        if !g_function_has_raw_block {
            mut i_unused: i32 = 0;
            loop {
                if i_unused >= len(g_all_vars_in_scope) {
                    break;
                }
                val var_name: string = g_all_vars_in_scope.data[i_unused];
                
                if StringIntMap.contains(addr(g_var_scope_depth), var_name) {
                    val var_depth: i32 = StringIntMap.get(addr(g_var_scope_depth), var_name);
                    if var_depth == 0 {
                        i_unused++;
                        continue;
                    }
                }
                
                if !StringBoolMap.contains(addr(g_var_actually_used), var_name) {
                    mut decl_line: i32 = 1;
                    mut decl_file: string = ctx.filename;
                    if StringIntMap.contains(addr(g_var_declaration_lines), var_name) {
                        decl_line = StringIntMap.get(addr(g_var_declaration_lines), var_name);
                    }
                    if StringStringMap.contains(addr(g_var_declaration_files), var_name) {
                        decl_file = StringStringMap.get(addr(g_var_declaration_files), var_name);
                    }
                    print decl_file;
                    print ":";
                    print(i32_to_string(decl_line));
                    print ": error: variable '";
                    print var_name;
                    println "' is declared but never used.";
                    quit(1);
                }
                i_unused++;
            }
        }
        
        clear_local_variables();
        g_current_scope_depth = 0;
        
        add_child_to_ast(ast, main_node);
        return;
    }
    
    // Handle function tags like [inline]
    if token_type == TokenType.LBRACKET {
        mut tags: list(string);
        ctx.pos++;
        skip_whitespace(ctx);
        
        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER {
            val tag_name: string = ctx.tokens.data[ctx.pos].value;
            
            if !equals_c(tag_name, "inline") and !equals_c(tag_name, "noinline") and !equals_c(tag_name, "cold") and !equals_c(tag_name, "hot") {
                print ctx.filename;
                print ":";
                print(i32_to_string(current_line(ctx)));
                print ": error: unrecognized function tag '";
                print tag_name;
                println "'. Supported tags: [inline], [noinline], [cold], [hot].";
                quit(1);
            }
            
            append(tags, tag_name);
            ctx.pos++;
            skip_whitespace(ctx);
        }
        
        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACKET {
            ctx.pos++;
            skip_whitespace(ctx);
        }
        
        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.DEF {
            ctx.pos++;
            mut func_node: ASTNode = parse_function(ctx);
            if str_len(func_node.node_type) > 0 {
                unsafe {
                    val tags_size: usize = C.sizeof(list(string));
                    val heap_tags: ref list(string) = cast[ref list(string)](C.malloc(tags_size));
                    if heap_tags != nil {
                        C.memcpy(heap_tags, addr(tags), tags_size);
                        func_node.data.function.tags = heap_tags;
                    }
                }
                add_child_to_ast(ast, func_node);
            }
        }
        return;
    }
    
    if token_type == TokenType.DEF {
        ctx.pos++; // Skip 'def'
        mut func_node: ASTNode = parse_function(ctx);
        if str_len(func_node.node_type) > 0 {
            add_child_to_ast(ast, func_node);
        }
        return;
    }
    
    if token_type == TokenType.EXTERN {
        val extern_node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(extern_node.node_type) > 0 {
            add_child_to_ast(ast, extern_node);
        }
        return;
    }
    
    if token_type == TokenType.MODEL {
        ctx.pos++;
        skip_whitespace(ctx);

        if ctx.pos >= len(ctx.tokens) {
            mut err: string = str("Expected model name after 'model'");
            enforce(false, error.create(err.data));
            return;
        }

        // If we see `model {` with no name at top level, treat it as an
        // anonymous model block and skip its body instead of just erroring.
        if ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
            ctx.pos++; // Skip '{'
            mut depth_model: i32 = 1;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t_br: Token = ctx.tokens.data[ctx.pos];
                if t_br.token_type == TokenType.LBRACE {
                    depth_model = depth_model + 1;
                } elif t_br.token_type == TokenType.RBRACE {
                    depth_model = depth_model - 1;
                    if depth_model == 0 {
                        ctx.pos++; // consume final '}'
                        break;
                    }
                }
                ctx.pos++;
            }
            return;
        }

        if ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
            mut err: string = str("Expected model name after 'model', instead got: ");
            err = concat(err, ctx.tokens.data[ctx.pos].value);
            enforce(false, error.create(err.data));
            return;
        }

        mut model_node: ASTNode;
        model_node.node_type = str("Model");
        val model_name: string = ctx.tokens.data[ctx.pos].value;
        model_node.data.model_node.name = model_name;
        model_node.data.model_node.is_public = false;
        ctx.pos++;

        skip_whitespace(ctx);
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            mut err: string = format_error(ctx, str("Expected '{' after model name"));
            enforce_raw(false, err.data);
            return;
        }
        ctx.pos++; // Skip '{'

        mut field_names: list(string);
        mut field_types: list(string);

        mut union_member_parents: list(string);
        mut union_member_names: list(string);
        mut union_member_types: list(string);

        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                ctx.pos++; // Skip '}'
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.PUB {
                ctx.pos++;
                skip_whitespace(ctx);

                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.DEF {
                    ctx.pos++; // skip 'def'
                    mut method_node: ASTNode = parse_function(ctx);
                    if str_len(method_node.node_type) > 0 {
                        method_node.data.function.is_public = true;

                        val orig_name: string = method_node.data.function.name;
                        mut full_name: string = model_name;
                        full_name = concat(full_name, str("__"));
                        full_name = concat(full_name, orig_name);
                        method_node.data.function.name = full_name;

                        add_child_to_ast(ast, method_node);
                    }
                    continue;
                }
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.DEF {
                // Non-pub static method inside model
                ctx.pos++; // skip 'def'
                mut method_node2: ASTNode = parse_function(ctx);
                if str_len(method_node2.node_type) > 0 {
                    val orig_name2: string = method_node2.data.function.name;
                    mut full_name2: string = model_name;
                    full_name2 = concat(full_name2, str("__"));
                    full_name2 = concat(full_name2, orig_name2);
                    method_node2.data.function.name = full_name2;
                    add_child_to_ast(ast, method_node2);
                }
                continue;
            }

            if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER {
                val field_name: string = ctx.tokens.data[ctx.pos].value;
                ctx.pos++;

                skip_whitespace(ctx);

                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.COLON {
                    ctx.pos++;
                    skip_whitespace(ctx);

                    // Parse base type
                    mut field_type: string = parse_type(ctx);

                    // Special handling for `field_name: union { ... }` including anonymous models
                    if str_len(field_type) == 5 and compare(field_type, str("union")) == 0 and ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
                        // Record this as a union field
                        append(field_names, field_name);
                        append(field_types, field_type);

                        ctx.pos++; // Skip '{'

                        loop {
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }

                            skip_whitespace(ctx);
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }

                            val t_inner: Token = ctx.tokens.data[ctx.pos];
                            if t_inner.token_type == TokenType.RBRACE {
                                ctx.pos++; // Skip '}'
                                break;
                            }

                            if t_inner.token_type == TokenType.SEMICOLON or t_inner.token_type == TokenType.NEWLINE {
                                ctx.pos++;
                                continue;
                            }

                            if t_inner.token_type != TokenType.IDENTIFIER {
                                ctx.pos++;
                                continue;
                            }

                            // union member name
                            val member_name: string = t_inner.value;
                            ctx.pos++;

                            skip_whitespace(ctx);
                            if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.COLON {
                                // Malformed, bail out of this member
                                continue;
                            }
                            ctx.pos++; // Skip ':'

                            skip_whitespace(ctx);
                            val member_base_type: string = parse_type(ctx);
                            skip_whitespace(ctx);

                            // Anonymous model inside union: `member_name: model { ... }`
                            if str_len(member_base_type) == 5 and compare(member_base_type, str("model")) == 0 and ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.LBRACE {
                                // Record the anonymous model as a union member of type "model"
                                append(union_member_parents, field_name);
                                append(union_member_names, member_name);
                                append(union_member_types, member_base_type);

                                ctx.pos++; // Skip '{' of anonymous model

                                mut brace_depth: i32 = 0;
                                loop {
                                    if ctx.pos >= len(ctx.tokens) {
                                        break;
                                    }

                                    val t_nested: Token = ctx.tokens.data[ctx.pos];

                                    if t_nested.token_type == TokenType.WHITESPACE or t_nested.token_type == TokenType.NEWLINE or t_nested.token_type == TokenType.SEMICOLON or t_nested.token_type == TokenType.COMMENT {
                                        ctx.pos++;
                                        continue;
                                    }

                                    if t_nested.token_type == TokenType.RBRACE {
                                        if brace_depth == 0 {
                                            ctx.pos++; // consume closing '}' of anonymous model
                                            break;
                                        }
                                        brace_depth = brace_depth - 1;
                                        ctx.pos++;
                                        continue;
                                    }

                                    if t_nested.token_type == TokenType.LBRACE {
                                        brace_depth = brace_depth + 1;
                                        ctx.pos++;
                                        continue;
                                    }

                                    if t_nested.token_type != TokenType.IDENTIFIER {
                                        ctx.pos++;
                                        continue;
                                    }

                                    // Nested field inside anonymous model
                                    val nested_name: string = t_nested.value;
                                    ctx.pos++;

                                    skip_whitespace(ctx);
                                    if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.COLON {
                                        continue;
                                    }
                                    ctx.pos++; // Skip ':'

                                    skip_whitespace(ctx);
                                    val nested_type: string = parse_type(ctx);

                                    // Optional semicolon
                                    skip_whitespace(ctx);
                                    if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                                        ctx.pos++;
                                    }

                                    // Parent of nested fields is the anonymous model member name
                                    append(union_member_parents, member_name);
                                    append(union_member_names, nested_name);
                                    append(union_member_types, nested_type);
                                }

                                // Optional semicolon after anonymous model member
                                skip_whitespace(ctx);
                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                                    ctx.pos++;
                                }
                            } else {
                                // Normal union member (non-anonymous-model)
                                val member_type: string = member_base_type;

                                // Consume optional semicolon after union member
                                skip_whitespace(ctx);
                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                                    ctx.pos++;
                                }

                                append(union_member_parents, field_name);
                                append(union_member_names, member_name);
                                append(union_member_types, member_type);
                            }
                        }

                        // After union block, optional semicolon at model level
                        skip_whitespace(ctx);
                        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                            ctx.pos++;
                        }
                    } else {
                        // Normal (non-union) field type, preserve existing suffix handling
                        loop {
                            skip_whitespace(ctx);
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }

                            if ctx.tokens.data[ctx.pos].token_type == TokenType.DOT {
                                field_type = concat(field_type, str("."));
                                ctx.pos++;

                                skip_whitespace(ctx);

                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER {
                                    field_type = concat(field_type, ctx.tokens.data[ctx.pos].value);
                                    ctx.pos++;
                                } else {
                                    break;
                                }
                            } elif ctx.tokens.data[ctx.pos].token_type == TokenType.SLASH {
                                field_type = concat(field_type, str("/"));
                                ctx.pos++;

                                skip_whitespace(ctx);

                                if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER {
                                    field_type = concat(field_type, ctx.tokens.data[ctx.pos].value);
                                    ctx.pos++;
                                } else {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }

                        skip_whitespace(ctx);
                        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                            ctx.pos++;
                        }

                        append(field_names, field_name);
                        append(field_types, field_type);
                    }
                } else {
                    // No type annotation, skip to semicolon
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = ctx.tokens.data[ctx.pos];
                        if t.token_type == TokenType.SEMICOLON {
                            ctx.pos++;
                            break;
                        }
                        ctx.pos++;
                    }
                }
            } else {
                ctx.pos++;
            }
        }

        unsafe {
            val list_size: usize = C.sizeof(list(string));
            val heap_names: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_names != nil {
                C.memcpy(heap_names, addr(field_names), list_size);
                model_node.data.model_node.field_names = heap_names;
            }

            val heap_types: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_types != nil {
                C.memcpy(heap_types, addr(field_types), list_size);
                model_node.data.model_node.field_types = heap_types;
            }

            val union_list_size: usize = C.sizeof(list(string));
            if len(union_member_parents) > 0 {
                val heap_union_parents: ref list(string) = cast[ref list(string)](C.malloc(union_list_size));
                if heap_union_parents != nil {
                    C.memcpy(heap_union_parents, addr(union_member_parents), union_list_size);
                    model_node.data.model_node.union_member_parents = heap_union_parents;
                }

                val heap_union_names: ref list(string) = cast[ref list(string)](C.malloc(union_list_size));
                if heap_union_names != nil {
                    C.memcpy(heap_union_names, addr(union_member_names), union_list_size);
                    model_node.data.model_node.union_member_names = heap_union_names;
                }

                val heap_union_types: ref list(string) = cast[ref list(string)](C.malloc(union_list_size));
                if heap_union_types != nil {
                    C.memcpy(heap_union_types, addr(union_member_types), union_list_size);
                    model_node.data.model_node.union_member_types = heap_union_types;
                }
            }
        }

        add_child_to_ast(ast, model_node);
        return;
    }
    
    if token_type == TokenType.ENUM {
        ctx.pos++;
        skip_whitespace(ctx);

        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
            mut err: string = format_error(ctx, str("Expected enum name after 'enum'"));
            enforce_raw(false, err.data);
            return;
        }

        val name_tok: Token = ctx.tokens.data[ctx.pos];
        ctx.pos++;
        val enum_name: string = name_tok.value;

        skip_whitespace(ctx);
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            mut err: string = format_error(ctx, str("Expected '{' after enum name"));
            enforce_raw(false, err.data);
            return;
        }

        ctx.pos++;

        mut values: list(string);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            val t: Token = ctx.tokens.data[ctx.pos];

            if t.token_type == TokenType.RBRACE {
                ctx.pos++;
                break;
            }

            if t.token_type == TokenType.IDENTIFIER {
                append(values, t.value);
                ctx.pos++;
                continue;
            }

            if t.token_type == TokenType.COMMA or
               t.token_type == TokenType.SEMICOLON or
               t.token_type == TokenType.WHITESPACE or
               t.token_type == TokenType.NEWLINE {
                ctx.pos++;
                continue;
            }

            ctx.pos++;
        }

        mut enum_node: ASTNode;
        enum_node.node_type = str("Enum");
        enum_node.data.enum_node.name = enum_name;

        unsafe {
            val list_size: usize = C.sizeof(list(string));
            mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(values), list_size);
                enum_node.data.enum_node.values = heap_list;
            }
        }

        add_child_to_ast(ast, enum_node);
        return;
    }
    
    if token_type == TokenType.MUT or token_type == TokenType.VAL {
        val decl_node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(decl_node.node_type) > 0 {
            if equals_c(decl_node.node_type, "Declaration") {
                val init_expr: string = decl_node.data.declaration.initializer;
                if has_function_call_in_expression(init_expr) {
                    val func_name: string = extract_function_name(init_expr);
                    print ctx.filename;
                    print ":";
                    print(i32_to_string(current_line(ctx)));
                    print ": error: The result of ";
                    print func_name;
                    println " cannot be resolved at compile time.";
                    quit(1);
                }
            }
            add_child_to_ast(ast, decl_node);
        }
        return;
    }

    if token_type == TokenType.TEST {
        ctx.pos++;  // Skip 'test'
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.LBRACE {
            mut err: string = format_error(ctx, str("Expected '{' after 'test'"));
            enforce_raw(false, err.data);
            return;
        }
        ctx.pos++; // Skip '{'
        
        clear_local_variables();
        g_current_scope_depth = 1;
        
        mut test_node: ASTNode;
        test_node.node_type = str("Test");
        
        mut children: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                ctx.pos++; // Skip '}'
                break;
            }
            
            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(children, stmt);
            }
        }
        
        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(children), list_size);
                test_node.children = heap_list;
            }
        }
        
        clear_local_variables();
        g_current_scope_depth = 0;
        
        add_child_to_ast(ast, test_node);
        return;
    }
    
    if token_type == TokenType.OVERLOAD {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            mut err: string = format_error(ctx, str("Expected overload name after 'overload'"));
            enforce_raw(false, err.data);
            return;
        }
        val overload_name: Token = consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LPAREN) {
            mut err: string = format_error(ctx, str("Expected '(' after overload name"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            mut err: string = format_error(ctx, str("Expected parameter name in overload"));
            enforce_raw(false, err.data);
            return;
        }
        val param_name_token: Token = consume(ctx);
        val param_name: string = param_name_token.value;
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.COLON) {
            consume(ctx);
            skip_whitespace(ctx);
            if expect(ctx, TokenType.IDENTIFIER) {
                consume(ctx); // Skip type annotation (e.g., 'generic')
                skip_whitespace(ctx);
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            mut err: string = format_error(ctx, str("Expected ')' after overload parameter"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after overload header"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx);
        
        // Parse type mappings: type => function;
        mut type_names: list(string);
        mut target_funcs: list(string);
        
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if expect(ctx, TokenType.RBRACE) {
                break;
            }
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                mut err: string = format_error(ctx, str("Expected type name in overload mapping"));
                enforce_raw(false, err.data);
                return;
            }
            val type_token: Token = consume(ctx);
            append(type_names, type_token.value);
            // Support pointer types like "char*" by optionally consuming a STAR
            skip_whitespace(ctx);
            if expect(ctx, TokenType.STAR) {
                consume(ctx);
                // Append '*' to the last stored type name
                val last_idx: i32 = len(type_names) - 1;
                type_names.data[last_idx] = concat(type_names.data[last_idx], str("*"));
                skip_whitespace(ctx);
            }
            
            // Expect '=>'
            if !expect(ctx, TokenType.OPERATOR) {
                mut err: string = format_error(ctx, str("Expected '=>' in overload mapping"));
                enforce_raw(false, err.data);
                return;
            }
            val op_token: Token = consume(ctx);
            if !equals_c(op_token.value, "=>") {
                mut err: string = format_error(ctx, str("Expected '=>' in overload mapping"));
                enforce_raw(false, err.data);
                return;
            }
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                mut err: string = format_error(ctx, str("Expected target function name in overload mapping"));
                enforce_raw(false, err.data);
                return;
            }
            val first_target_token: Token = consume(ctx);
            mut target_name: string = first_target_token.value;
            skip_whitespace(ctx);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
                    break;
                }
                val extra_tok: Token = consume(ctx);

                target_name = concat(target_name, str("_"));
                target_name = concat(target_name, extra_tok.value);

                skip_whitespace(ctx);
            }
            append(target_funcs, target_name);
            
            if !expect(ctx, TokenType.SEMICOLON) {
                mut err: string = str("Expected ';' after overload mapping, instead got ");
                if ctx.pos < len(ctx.tokens) {
                    err = concat(err, ctx.tokens.data[ctx.pos].value);
                } else {
                    err = concat(err, str("<eof>"));
                }
                enforce_raw(false, err.data);
                return;
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.RBRACE) {
            mut err: string = format_error(ctx, str("Expected '}' after overload mappings"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        // Parse call expression: (expr)
        if !expect(ctx, TokenType.LPAREN) {
            mut err: string = format_error(ctx, str("Expected '(' with call expression after overload block"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx);
        
        mut call_expr: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if expect(ctx, TokenType.RPAREN) {
                break;
            }
            
            val t: Token = consume(ctx);
            if t.token_type == TokenType.STR {
                call_expr = concat(call_expr, str("\""));
                call_expr = concat(call_expr, t.value);
                call_expr = concat(call_expr, str("\""));
            } elif t.token_type == TokenType.CHAR {
                call_expr = concat(call_expr, str("'"));
                call_expr = concat(call_expr, t.value);
                call_expr = concat(call_expr, str("'"));
            } else {
                call_expr = concat(call_expr, t.value);
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            mut err: string = format_error(ctx, str("Expected ')' after overload call expression"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            mut err: string = format_error(ctx, str("Expected ';' after overload definition"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx);
        
        mut overload_node: ASTNode;
        overload_node.node_type = str("Overload");
        overload_node.data.overload_node.name = overload_name.value;
        overload_node.data.overload_node.param_name = param_name;
        overload_node.data.overload_node.call_expr = call_expr;
        
        unsafe {
            val type_list_size: usize = C.sizeof(list(string));
            val heap_type_list: ref list(string) = cast[ref list(string)](C.malloc(type_list_size));
            if heap_type_list != nil {
                C.memcpy(heap_type_list, addr(type_names), type_list_size);
                overload_node.data.overload_node.type_names = heap_type_list;
            }
            
            val func_list_size: usize = C.sizeof(list(string));
            val heap_func_list: ref list(string) = cast[ref list(string)](C.malloc(func_list_size));
            if heap_func_list != nil {
                C.memcpy(heap_func_list, addr(target_funcs), func_list_size);
                overload_node.data.overload_node.target_functions = heap_func_list;
            }
        }
        
        add_child_to_ast(ast, overload_node);
        return;
    }
    
    if token_type == TokenType.PUB {
        ctx.pos++;  // Skip 'pub'
        skip_whitespace(ctx);
        parse_top_level(ctx, ast);
        return;
    }
    
    if token_type == TokenType.MACRO {
        ctx.pos++;  // Skip 'macro'
        skip_whitespace(ctx);

        if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
            mut err: string = format_error(ctx, str("Expected macro name after 'macro'"));
            enforce_raw(false, err.data);
            return;
        }

        val name_tok: Token = ctx.tokens.data[ctx.pos];
        val macro_name: string = name_tok.value;
        ctx.pos++;

        skip_whitespace(ctx);

        mut params: list(string);
        mut param_types: list(string);

        if !expect(ctx, TokenType.LPAREN) {
            mut err: string = str("Expected '(' after macro name");
            err = concat(err, str(" instead got "));
            err = concat(err, ctx.tokens.data[ctx.pos].value);
            enforce(false, error.create(err.data));
            return;
        }
        consume(ctx); // '('

        loop {
            skip_whitespace(ctx);
            if expect(ctx, TokenType.RPAREN) {
                consume(ctx);
                break;
            }

            if !expect(ctx, TokenType.IDENTIFIER) {
                mut err: string = format_error(ctx, str("Expected parameter name in macro definition"));
                enforce_raw(false, err.data);
                return;
            }

            val param_tok: Token = consume(ctx);
            val param_name: string = param_tok.value;

            skip_whitespace(ctx);

            if !expect(ctx, TokenType.COLON) {
                mut err: string = format_error(ctx, str("Expected ':' after macro parameter name"));
                enforce_raw(false, err.data);
                return;
            }
            consume(ctx);

            skip_whitespace(ctx);

            if !expect(ctx, TokenType.IDENTIFIER) {
                mut err: string = format_error(ctx, str("Expected type after ':' in macro parameter"));
                enforce_raw(false, err.data);
                return;
            }

            val type_tok: Token = consume(ctx);
            val param_type: string = type_tok.value;

            append(params, param_name);
            append(param_types, param_type);

            skip_whitespace(ctx);

            if expect(ctx, TokenType.COMMA) {
                consume(ctx);
                continue;
            }
        }

        skip_whitespace(ctx);

        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after macro header"));
            enforce_raw(false, err.data);
            return;
        }
        consume(ctx); // '{'

        mut body_tokens: list(Token);
        mut brace_depth: i32 = 1;

        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            val t: Token = ctx.tokens.data[ctx.pos];

            if t.token_type == TokenType.LBRACE {
                brace_depth = brace_depth + 1;
                append(body_tokens, t);
                ctx.pos++;
                continue;
            }

            if t.token_type == TokenType.RBRACE {
                brace_depth = brace_depth - 1;
                if brace_depth == 0 {
                    ctx.pos++;
                    break;
                }
                append(body_tokens, t);
                ctx.pos++;
                continue;
            }

            append(body_tokens, t);
            ctx.pos++;
        }

        if brace_depth != 0 {
            mut err: string = format_error(ctx, str("Expected '}' after macro body"));
            enforce_raw(false, err.data);
            return;
        }

        mut heap_params: ref list(string) = nil;
        mut heap_body: ref list(Token) = nil;
        
        unsafe {
            val params_size: usize = C.sizeof(list(string));
            heap_params = cast[ref list(string)](C.malloc(params_size));
            if heap_params != nil {
                C.memcpy(heap_params, addr(params), params_size);
            }

            val body_size: usize = C.sizeof(list(Token));
            heap_body = cast[ref list(Token)](C.malloc(body_size));
            if heap_body != nil {
                C.memcpy(heap_body, addr(body_tokens), body_size);
            }
        }

        mut macro_node: ASTNode;
        macro_node.node_type = str("Macro");
        macro_node.data.macro_node.name = macro_name;
        macro_node.data.macro_node.params = heap_params;
        macro_node.data.macro_node.param_types = addr(param_types);
        macro_node.data.macro_node.body_tokens = heap_body;

        add_child_to_ast(ast, macro_node);

        mut defn: MacroDef;
        defn.params = heap_params;
        defn.body = heap_body;
        macros_add(macro_name, defn);

        return;
    }
    
    if token_type == TokenType.OPAQUE {
        ctx.pos++;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[ctx.pos].token_type == TokenType.SEMICOLON {
                ctx.pos++;
                break;
            }
            ctx.pos++;
        }
        return;
    }
    
    if token_type == TokenType.FOREIGN {
        mut node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(node.node_type) > 0 {
            add_child_to_ast(ast, node);
        }
        return;
    }
    
    if token_type == TokenType.PLATFORM {
        mut node: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(node.node_type) > 0 {
            add_child_to_ast(ast, node);
        }
        return;
    }
    
    mut err: string = format_error(
        ctx,
        str("Unexpected token at top level. Expected def, model, enum, val, mut, use, platform, macro, opaque, foreign, extern, or pub.")
    );
    println err;
    quit(1);
}

/// Skip the whitespace and newline tokens
def skip_whitespace(ctx: ref ParserContext) {
    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        val token_type = ctx.tokens.data[ctx.pos].token_type;
        
        if token_type == TokenType.WHITESPACE or token_type == TokenType.NEWLINE {
            ctx.pos++;
        } else {
            break;
        }
    }
}

/// Peek at current token without advancing
def peek(ctx: ref ParserContext): Token {
    if ctx.pos < len(ctx.tokens) {
        return ctx.tokens.data[ctx.pos];
    }
    
    mut empty: Token;
    empty.token_type = TokenType.IDENTIFIER;
    empty.value = str("");
    empty.line = 0;
    empty.column = 0;
    return empty;
}

/// Get the current line number from the parser context
def current_line(ctx: ref ParserContext): i32 {
    val token: Token = peek(ctx);
    return token.line;
}

/// Format error message with file, line, and column information
def format_error(ctx: ref ParserContext, message: string): string {
    mut result: string = str("");
    if str_len(ctx.filename) > 0 {
        result = concat(result, ctx.filename);
        result = concat(result, str(":"));
    }
    
    mut line_num: i32 = 1;
    mut col_num: i32 = 1;
    
    if ctx.pos < len(ctx.tokens) {
        val token: Token = ctx.tokens.data[ctx.pos];
        line_num = token.line;
        col_num = token.column;
    } elif ctx.pos > 0 and len(ctx.tokens) > 0 {
        val last_token: Token = ctx.tokens.data[len(ctx.tokens) - 1];
        line_num = last_token.line;
        col_num = last_token.column;
    }
    
    if line_num <= 0 {
        line_num = 1;
    }
    if col_num <= 0 {
        col_num = 1;
    }
    
    result = concat(result, i32_to_string(line_num));
    result = concat(result, str(":"));
    result = concat(result, i32_to_string(col_num));
    result = concat(result, str(": "));
    result = concat(result, message);
    return result;
}

/// Consume current token and advance
def consume(ctx: ref ParserContext): Token {
    val token: Token = peek(ctx);
    ctx.pos = ctx.pos + 1;
    return token;
}

/// Check if current token matches expected type
def expect(ctx: ref ParserContext, expected_type: i32): bool {
    skip_whitespace(ctx);
    val token: Token = peek(ctx);
    return token.token_type == expected_type;
}

/// Parse a type specification (e.g., "i32", "ref string", "list(Token)")
def parse_type(ctx: ref ParserContext): string {
    skip_whitespace(ctx);
    
    if ctx.pos >= len(ctx.tokens) {
        val err: string = format_error(ctx, str("Expected type but reached end of tokens"));
        enforce_raw(false, err.data);
        return str("");
    }
    
    mut ref_prefix: string = str("");
    
    loop {
        val token: Token = peek(ctx);
        if token.token_type == TokenType.REF {
            ref_prefix = concat_c(ref_prefix, "ref ");
            consume(ctx);
            skip_whitespace(ctx);
        } else {
            break;
        }
    }
    
    skip_whitespace(ctx);
    mut type_name: string = str("");
    val current_token: Token = peek(ctx);
    
    if current_token.token_type == TokenType.MODEL {
        consume(ctx);
        return concat_c(ref_prefix, "model");
    }
    
    if current_token.token_type == TokenType.IDENTIFIER {
        type_name = current_token.value;
        check_null_usage(ctx, type_name);
        consume(ctx);
        
        // Handle list(ElementType) syntax
        if equals_c(type_name, "list") {
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.LPAREN) {
                val err: string = format_error(ctx, str("Expected '(' after 'list'"));
                enforce_raw(false, err.data);
                return str("");
            }
            consume(ctx);
            
            skip_whitespace(ctx);
            val elem_token: Token = consume(ctx);
            val element_type: string = elem_token.value;
            
            skip_whitespace(ctx);
            if !expect(ctx, TokenType.RPAREN) {
                val err: string = format_error(ctx, str("Expected ')' after list element type"));
                enforce_raw(false, err.data);
                return str("");
            }
            consume(ctx);
            type_name = concat(element_type, str("[999]"));
        }

        loop {
            if expect(ctx, TokenType.LBRACKET) {
                consume(ctx);
                type_name = concat(type_name, str("["));
                
                loop {
                    val tok: Token = peek(ctx);
                    if tok.token_type == TokenType.RBRACKET {
                        break;
                    }
                    type_name = concat(type_name, tok.value);
                    consume(ctx);
                }
                
                if expect(ctx, TokenType.RBRACKET) {
                    consume(ctx);
                    type_name = concat(type_name, str("]"));
                }
            } else {
                break;
            }
        }
        
        loop {
            val tok: Token = peek(ctx);
            if (tok.token_type == TokenType.OPERATOR and equals_c(tok.value, "*")) or
               (tok.token_type == TokenType.STAR) {
                consume(ctx);
                type_name = concat(type_name, str("*"));
            } else {
                break;
            }
        }
    } else {
        val err: string = format_error(ctx, str("Invalid type specification"));
        enforce_raw(false, err.data);
        return str("");
    }
    
    if StringStringMap.contains(addr(g_type_aliases), type_name) {
        type_name = StringStringMap.get(addr(g_type_aliases), type_name);
    }
    
    return concat(ref_prefix, type_name);
}

/// Parse ref depth (e.g., "ref ref int" returns 2)
def parse_ref_depth(ctx: ref ParserContext): i32 {
    mut depth: i32 = 0;
    
    loop {
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        val token: Token = peek(ctx);
        if token.token_type == TokenType.REF {
            depth = depth + 1;
            consume(ctx);
        } else {
            break;
        }
    }
    
    return depth;
}

/// Parse function definition
def parse_function(ctx: ref ParserContext): ASTNode {
    mut func: ASTNode;
    func.node_type = str("Function");
    func.line = current_line(ctx);
    
    clear_local_variables();
    g_current_scope_depth = 1;
    g_function_has_raw_block = false;
    
    skip_whitespace(ctx);
    if ctx.pos >= len(ctx.tokens) or ctx.tokens.data[ctx.pos].token_type != TokenType.IDENTIFIER {
        mut err: string = format_error(ctx, str("Expected function name after 'def'"));
        enforce_raw(false, err.data);
        return func;
    }
    
    mut func_name: string = ctx.tokens.data[ctx.pos].value;
    
    if ctx.check_entry_point and is_symbol_imported(func_name) {
        print ctx.filename;
        print ":";
        print(i32_to_string(current_line(ctx)));
        print ": error: function '";
        print func_name;
        print "' shadows imported symbol '";
        print func_name;
        println "'";
        quit(1);
    }
    
    func.data.function.name = func_name;
    func.data.function.return_type = str("");
    func.data.function.is_public = false;
    ctx.pos++;
    
    skip_whitespace(ctx);

    if ctx.pos + 1 < len(ctx.tokens) {
        if ctx.tokens.data[ctx.pos].token_type == TokenType.IDENTIFIER and
           equals_c(ctx.tokens.data[ctx.pos + 1].value, "(") {
            mut merged: string = func_name;
            val next_ident: string = ctx.tokens.data[ctx.pos].value;

            if str_len(next_ident) > 0 and get_char(next_ident, 0) != '_' {
                merged = concat(merged, str("_"));
            }

            merged = concat(merged, next_ident);
            func_name = merged;
            func.data.function.name = merged;
            ctx.pos++;
            skip_whitespace(ctx);
        }
    }

    if !expect(ctx, TokenType.LPAREN) {
        println "DEBUG parse_function: missing '(' after function name";

        mut dbg: string = str("  func_name = ");
        dbg = concat(dbg, func_name);
        debug_print_str dbg;
        
        val buffer: char[64] = {};
        dbg = str("  ctx.pos = ");
        dbg = concat_c(dbg, int_to_str(ctx.pos, buffer));
        dbg = concat(dbg, str(" / "));
        dbg = concat_c(dbg, int_to_str(len(ctx.tokens), buffer));
        debug_print_str dbg;

        if ctx.pos < len(ctx.tokens) {
            dbg = str("  current token type = ");
            dbg = concat_c(dbg, int_to_str(ctx.tokens.data[ctx.pos].token_type, buffer));
            dbg = concat(dbg, str(", value = '"));
            dbg = concat(dbg, ctx.tokens.data[ctx.pos].value);
            dbg = concat(dbg, str("'"));
            debug_print_str dbg;
        } else {
            debug_print_raw "  current token = <eof>";
        }

        mut start_dbg: i32 = ctx.pos - 5;
        if start_dbg < 0 {
            start_dbg = 0;
        }
        mut end_dbg: i32 = ctx.pos + 5;
        val total_tokens: i32 = len(ctx.tokens);
        if end_dbg > total_tokens {
            end_dbg = total_tokens;
        }
        println "  Surrounding tokens:";
        mut i_dbg: i32 = start_dbg;
        loop {
            if i_dbg >= end_dbg {
                break;
            }
            val tok_dbg: Token = ctx.tokens.data[i_dbg];
            val buffer2: char[64] = {};

            dbg = str("    [");
            dbg = concat_c(dbg, int_to_str(i_dbg, buffer2));

            dbg = concat(dbg, str("] type="));
            dbg = concat_c(dbg, int_to_str(tok_dbg.token_type, buffer2));
            dbg = concat(dbg, str(", value='"));
            dbg = concat(dbg, tok_dbg.value);
            dbg = concat(dbg, str("'"));
            debug_print_str dbg;
            i_dbg = i_dbg + 1;
        }

        mut err: string = str("Expected '(' after function name");
        if ctx.pos < len(ctx.tokens) {
            err = concat(err, str(" instead got "));
            err = concat(err, ctx.tokens.data[ctx.pos].value);
        } else {
            err = concat(err, str(" instead got <eof>"));
        }
        err = concat(err, str(" in function "));
        err = concat(err, func_name);
        enforce_raw(false, err.data);
        return func;
    }
    consume(ctx);

    mut params: list(string);
    mut current_param: string = str("");
    mut paren_depth_params: i32 = 0;

    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }

        val t: Token = ctx.tokens.data[ctx.pos];

        if t.token_type == TokenType.RPAREN and paren_depth_params == 0 {
            val trimmed: string = strip(current_param);
            if str_len(trimmed) > 0 {
                append(params, trimmed);
            }
            ctx.pos++;
            break;
        }

        if t.token_type == TokenType.LPAREN {
            paren_depth_params = paren_depth_params + 1;
            current_param = concat(current_param, t.value);
            consume(ctx);
            continue;
        }

        if t.token_type == TokenType.RPAREN {
            paren_depth_params = paren_depth_params - 1;
            current_param = concat(current_param, t.value);
            consume(ctx);
            continue;
        }

        if t.token_type == TokenType.COMMA and paren_depth_params == 0 {
            val trimmed_param: string = strip(current_param);
            if str_len(trimmed_param) > 0 {
                append(params, trimmed_param);
            }
            current_param = str("");
            consume(ctx);
            continue;
        }

        if t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
            consume(ctx);
            continue;
        }

        // Preserve spacing for ref/mut prefixes so types like 'ref char'
        // and 'ref ref char' are not squashed into 'refchar'. The renderer
        // relies on a 'ref ' prefix (with space) to map these to pointers.
        
        if t.token_type == TokenType.REF {
            current_param = concat(current_param, str("ref "));
        } elif t.token_type == TokenType.MUT {
            current_param = concat(current_param, str("mut "));
        } else {
            current_param = concat(current_param, t.value);
        }
        consume(ctx);
    }

    if !ctx.is_axec and len(params) > 0 {
        mut param_idx: i32 = 0;
        loop {
            if param_idx >= len(params) {
                break;
            }
            val param: string = params.data[param_idx];
            if has_pointer_syntax(param) {
                print ctx.filename;
                print ":";
                print(i32_to_string(current_line(ctx)));
                print ": error: raw pointer syntax (e.g., 'char*') is not allowed.";
                println " Use 'ref' instead (e.g., 'ref char').";
                print "(in parameter: ";
                print param;
                println ")";
                quit(1);
            }
            param_idx++;
        }
    }
    
    // Store parameters on function node (if any)
    if len(params) > 0 {
        unsafe {
            val params_size: usize = C.sizeof(list(string));
            val heap_params: ref list(string) = cast[ref list(string)](C.malloc(params_size));
            if heap_params != nil {
                C.memcpy(heap_params, addr(params), params_size);
                func.data.function.params = heap_params;
            }
        }
    }

    skip_whitespace(ctx);
    if expect(ctx, TokenType.COLON) {
        consume(ctx);
        val return_type: string = parse_type(ctx);
        func.data.function.return_type = return_type;
        
        if !ctx.is_axec and has_pointer_syntax(return_type) {
            print ctx.filename;
            print ":";
            print(i32_to_string(current_line(ctx)));
            print ": error: raw pointer syntax (e.g., 'char*') is not allowed. ";
            println "Use 'ref' instead (e.g., 'ref char').";
            print "(in return type: ";
            print return_type;
            println ")";
            quit(1);
        }
    }
    
    skip_whitespace(ctx);
    if !expect(ctx, TokenType.LBRACE) {
        mut msg: string = str("Expected '{' after function declaration, instead got: ");
        msg = concat(msg, ctx.tokens.data[ctx.pos].value);
        msg = concat(msg, str(" in function "));
        msg = concat(msg, func_name);
        enforce_raw(false, msg.data);
        return func;
    }
    consume(ctx);
    
    mut children: list(ASTNode);
    loop {
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        skip_whitespace(ctx);
        
        if ctx.pos >= len(ctx.tokens) {
            break;
        }
        
        if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
            ctx.pos++;
            break;
        }
        
        val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
        if str_len(stmt.node_type) > 0 {
            append(children, stmt);
        }
    }
    
    unsafe {
        val list_size: usize = C.sizeof(list(ASTNode));
        val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
        if heap_list != nil {
            C.memcpy(heap_list, addr(children), list_size);
            func.children = heap_list;
        }
    }
    
    // Skip mutation checking if function contains raw block
    if !g_function_has_raw_block {
        mut i_mut: i32 = 0;
        loop {
            if i_mut >= len(g_mutable_vars_in_scope) {
                break;
            }
            val var_name: string = g_mutable_vars_in_scope.data[i_mut];
            
            if StringIntMap.contains(addr(g_var_scope_depth), var_name) {
                val var_depth: i32 = StringIntMap.get(addr(g_var_scope_depth), var_name);
                if var_depth == 0 {
                    i_mut++;
                    continue;
                }
            }
            
            if !StringBoolMap.contains(addr(g_var_actually_mutated), var_name) {
                print ctx.filename;
                print ":";
                print(i32_to_string(func.line));
                print ": error: variable '";
                print var_name;
                println "' is declared 'mut' but is never mutated. Use 'val' instead.";
                quit(1);
            }
            i_mut++;
        }
    }
    
    if !g_function_has_raw_block {
        mut i_unused: i32 = 0;
        loop {
            if i_unused >= len(g_all_vars_in_scope) {
                break;
            }
            val var_name: string = g_all_vars_in_scope.data[i_unused];
            
            if StringIntMap.contains(addr(g_var_scope_depth), var_name) {
                val var_depth: i32 = StringIntMap.get(addr(g_var_scope_depth), var_name);
                if var_depth == 0 {
                    i_unused++;
                    continue;
                }
            }
            
            if !StringBoolMap.contains(addr(g_var_actually_used), var_name) {
                mut decl_line: i32 = func.line;
                mut decl_file: string = ctx.filename;
                if StringIntMap.contains(addr(g_var_declaration_lines), var_name) {
                    decl_line = StringIntMap.get(addr(g_var_declaration_lines), var_name);
                }
                if StringStringMap.contains(addr(g_var_declaration_files), var_name) {
                    decl_file = StringStringMap.get(addr(g_var_declaration_files), var_name);
                }
                print decl_file;
                print ":";
                print(i32_to_string(decl_line));
                print ": error: variable '";
                print var_name;
                println "' is declared but never used.";
                quit(1);
            }
            i_unused++;
        }
    }
    
    // Clear only the function-local variables from the maps (keep globals)
    clear_local_variables();
    g_current_scope_depth = 0;
    
    return func;
}

/// Parse a single statement (helper for parsing function bodies, loops, etc.)
///
/// Returns an ASTNode for the statement, or nil node for whitespace/newlines
def parse_statement_helper(ctx: ref ParserContext, scope: ref Scope): ASTNode {
    mut node: ASTNode;
    node.node_type = str("Empty");
    node.line = current_line(ctx);
    node.source_file = ctx.filename;
    
    if ctx.pos >= len(ctx.tokens) {
        return node;
    }
    
    val token: Token = peek(ctx);
    val token_type: i32 = token.token_type;
    
    if token_type == TokenType.WHITESPACE or token_type == TokenType.NEWLINE {
        consume(ctx);
        return node;
    }
    
    // Handle BREAK
    if token_type == TokenType.BREAK {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            mut err: string = format_error(ctx, str("Expected ';' after break"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Break");
        node.line = token.line;
        node.source_file = ctx.filename;
        return node;
    }
    
    // Handle CONTINUE
    if token_type == TokenType.CONTINUE {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            mut err: string = format_error(ctx, str("Expected ';' after continue"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Continue");
        node.line = token.line;
        node.source_file = ctx.filename;
        return node;
    }
    
    // Handle ASSERT
    if token_type == TokenType.ASSERT {
        val assert_line: i32 = token.line;
        consume(ctx);
        skip_whitespace(ctx);
        
        mut has_parens: bool = false;
        if expect(ctx, TokenType.LPAREN) {
            has_parens = true;
            consume(ctx);
        }
        
        mut condition: string = str("");
        mut paren_depth: i32 = 0;
        
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            
            if t.token_type == TokenType.LPAREN {
                paren_depth = paren_depth + 1;
                condition = concat(condition, t.value);
                condition = concat(condition, str(" "));
            } elif t.token_type == TokenType.RPAREN {
                if paren_depth == 0 and has_parens {
                    break;
                }
                paren_depth = paren_depth - 1;
                condition = concat(condition, t.value);
                condition = concat(condition, str(" "));
            } elif t.token_type == TokenType.COMMA and paren_depth == 0 {
                break;
            } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                if t.token_type == TokenType.STR {
                    condition = concat(condition, str("\""));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("\" "));
                } elif t.token_type == TokenType.CHAR {
                    condition = concat(condition, str("'"));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("' "));
                } else {
                    condition = concat(condition, t.value);
                    condition = concat(condition, str(" "));
                }
            }
            consume(ctx);
        }
        
        condition = expand_macros_in_expression(condition);
        
        if !expect(ctx, TokenType.COMMA) {
            mut err: string = format_error(ctx, str("Expected ',' after assert condition"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.STR) {
            mut err: string = format_error(ctx, str("Expected string message after comma in assert"));
            enforce_raw(false, err.data);
            return node;
        }
        val message_token: Token = consume(ctx);
        val message: string = message_token.value;
        skip_whitespace(ctx);
        
        if has_parens {
            if !expect(ctx, TokenType.RPAREN) {
                mut err: string = format_error(ctx, str("Expected ')' after assert message"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            skip_whitespace(ctx);
        }
        
        if !expect(ctx, TokenType.SEMICOLON) {
            mut err: string = format_error(ctx, str("Expected ';' after assert statement"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Assert");
        node.line = assert_line;
        node.source_file = ctx.filename;
        node.data.assert_node.condition = condition;
        node.data.assert_node.message = message;
        debug_print_raw "\n[DEBUG] ASSERT condition:";
        debug_print_str condition;
        debug_print_raw "\n[DEBUG] ASSERT message:";
        debug_print_str message;
        return node;
    }
    
    // Handle RETURN
    if token_type == TokenType.RETURN {
        val return_line: i32 = token.line;
        consume(ctx);
        skip_whitespace(ctx);
        
        mut expr: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.SEMICOLON {
                break;
            }
            if t.token_type == TokenType.STR {
                expr = concat(expr, str("\""));
                expr = concat(expr, t.value);
                expr = concat(expr, str("\" "));
            } elif t.token_type == TokenType.CHAR {
                expr = concat(expr, str("'"));
                expr = concat(expr, t.value);
                expr = concat(expr, str("' "));
            } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
            } else {
                if (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("and")) == 0)
                   or t.token_type == TokenType.AND {
                    expr = concat(expr, str("&&"));
                    expr = concat(expr, str(" "));
                } elif (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("or")) == 0)
                       or t.token_type == TokenType.OR {
                    expr = concat(expr, str("||"));
                    expr = concat(expr, str(" "));
                } else {
                    expr = concat(expr, t.value);
                    expr = concat(expr, str(" "));
                }
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.SEMICOLON) {
            mut err: string = format_error(ctx, str("Expected ';' after return"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        expr = expand_macros_in_expression(expr);
        
        node.node_type = str("Return");
        node.line = return_line;
        node.source_file = ctx.filename;
        debug_print_raw "\n[DEBUG] RETURN expr:";
        debug_print_str expr;
        node.data.return_node.expression = expr;
        scan_expression_for_usage(expr);
        return node;
    }
    
    // Handle LOOP
    if token_type == TokenType.LOOP {
        val loop_line: i32 = token.line;
        consume(ctx);
        skip_whitespace(ctx);

        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after loop"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // skip '{'
        
        push_scope();

        mut lnode: ASTNode;
        lnode.node_type = str("Loop");
        lnode.line = loop_line;
        lnode.source_file = ctx.filename;

        mut body: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx); // skip '}'
                break;
            }

            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }
        
        pop_scope();

        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(body), list_size);
                lnode.children = heap_list;
            }
        }

        return lnode;
    }
    
    // Handle SWITCH
    if token_type == TokenType.SWITCH {
        consume(ctx);
        skip_whitespace(ctx);
        
        mut switch_expr: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                switch_expr = concat(switch_expr, t.value);
                switch_expr = concat(switch_expr, str(" "));
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after switch expression"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Switch");
        return node;
    }
    
    // Handle IF
    if token_type == TokenType.IF {
        val if_line: i32 = token.line;
        consume(ctx);
        skip_whitespace(ctx);

        // Parse condition expression up to '{'
        mut condition: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {

                // If we see a VAL token immediately followed by an IDENTIFIER token, it
                // may be an identifier like 'value' that was split into 'val' + 'ue'.
                //
                // In that case, concatenate the two pieces without an extra space so
                // the condition string becomes "value" instead of "val ue".

                if t.token_type == TokenType.VAL and ctx.pos + 1 < len(ctx.tokens) {
                    val next_tok: Token = ctx.tokens.data[ctx.pos + 1];
                    if next_tok.token_type == TokenType.IDENTIFIER {
                        mut merged: string = t.value;
                        merged = concat(merged, next_tok.value);
                        condition = concat(condition, merged);
                        condition = concat(condition, str(" "));
                        consume(ctx);
                        consume(ctx);
                        continue;
                    }
                }

                if (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("and")) == 0)
                   or t.token_type == TokenType.AND {
                    condition = concat(condition, str("&&"));
                    condition = concat(condition, str(" "));
                } elif (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("or")) == 0)
                       or t.token_type == TokenType.OR {
                    condition = concat(condition, str("||"));
                    condition = concat(condition, str(" "));
                } elif t.token_type == TokenType.STR {
                    condition = concat(condition, str("\""));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("\" "));
                } elif t.token_type == TokenType.CHAR {
                    condition = concat(condition, str("'"));
                    condition = concat(condition, t.value);
                    condition = concat(condition, str("' "));
                } else {
                    condition = concat(condition, t.value);
                    condition = concat(condition, str(" "));
                }
            }
            consume(ctx);
        }

        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after if condition"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // skip '{'

        push_scope();

        // Parse if-body statements into a list of children
        mut if_children: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            val t_body: Token = peek(ctx);
            if t_body.token_type == TokenType.RBRACE {
                consume(ctx); // end of if-body
                break;
            }

            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(if_children, stmt);
            }
        }

        pop_scope();

        // Support elif/else chains by lowering
        //   if cond1 { ... }
        //   elif cond2 { ... }
        //   else { ... }
        // into a chain of If nodes where each elif becomes the else-branch of the previous.
        //
        // NOTE: We use a list to collect elif nodes and then chain them linearly at the end.

        mut elif_nodes: list(ASTNode);
        mut final_else_children: list(ASTNode);

        skip_whitespace(ctx);

        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type != TokenType.ELIF {
                break;
            }

            ctx.pos = ctx.pos + 1;
            skip_whitespace(ctx);

            mut elif_condition: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t_el: Token = peek(ctx);
                if t_el.token_type == TokenType.LBRACE {
                    break;
                }
                if t_el.token_type != TokenType.WHITESPACE and t_el.token_type != TokenType.NEWLINE {
                    if t_el.token_type == TokenType.VAL and ctx.pos + 1 < len(ctx.tokens) {
                        val next_tok_el: Token = ctx.tokens.data[ctx.pos + 1];
                        if next_tok_el.token_type == TokenType.IDENTIFIER {
                            mut merged_el: string = t_el.value;
                            merged_el = concat(merged_el, next_tok_el.value);
                            elif_condition = concat(elif_condition, merged_el);
                            elif_condition = concat(elif_condition, str(" "));
                            consume(ctx);
                            consume(ctx);
                            continue;
                        }
                    }

                    if (t_el.token_type == TokenType.IDENTIFIER and compare(t_el.value, str("and")) == 0)
                       or t_el.token_type == TokenType.AND {
                        elif_condition = concat(elif_condition, str("&&"));
                        elif_condition = concat(elif_condition, str(" "));
                    } elif (t_el.token_type == TokenType.IDENTIFIER and compare(t_el.value, str("or")) == 0)
                           or t_el.token_type == TokenType.OR {
                        elif_condition = concat(elif_condition, str("||"));
                        elif_condition = concat(elif_condition, str(" "));
                    } elif t_el.token_type == TokenType.STR {
                        elif_condition = concat(elif_condition, str("\""));
                        elif_condition = concat(elif_condition, t_el.value);
                        elif_condition = concat(elif_condition, str("\" "));
                    } elif t_el.token_type == TokenType.CHAR {
                        elif_condition = concat(elif_condition, str("'"));
                        elif_condition = concat(elif_condition, t_el.value);
                        elif_condition = concat(elif_condition, str("' "));
                    } else {
                        elif_condition = concat(elif_condition, t_el.value);
                        elif_condition = concat(elif_condition, str(" "));
                    }
                }
                consume(ctx);
            }

            if !expect(ctx, TokenType.LBRACE) {
                enforce_raw(false, "Expected '{' after elif condition");
                return node;
            }
            consume(ctx); // skip '{'

            push_scope();

            mut elif_children: list(ASTNode);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                val t_eb: Token = peek(ctx);
                if t_eb.token_type == TokenType.RBRACE {
                    consume(ctx);
                    break;
                }

                val stmt_eb: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt_eb.node_type) > 0 {
                    append(elif_children, stmt_eb);
                }
            }

            pop_scope();

            mut elif_node: ASTNode;
            elif_node.node_type = str("If");
            elif_node.data.if_node.condition = elif_condition;
            scan_expression_for_usage(elif_condition);

            unsafe {
                mut body_list_el: list(ASTNode);
                mut i_el: i32 = 0;
                loop {
                    if i_el >= len(elif_children) {
                        break;
                    }
                    append(body_list_el, elif_children.data[i_el]);
                    i_el = i_el + 1;
                }

                val sz_el: usize = C.sizeof(list(ASTNode));
                val heap_el: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz_el));
                if heap_el != nil {
                    C.memcpy(heap_el, addr(body_list_el), sz_el);
                    elif_node.children = heap_el;
                }
            }

            append(elif_nodes, elif_node);
            skip_whitespace(ctx);
        }

        skip_whitespace(ctx);
        if ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.ELSE {
            ctx.pos = ctx.pos + 1; // consume 'else'
            skip_whitespace(ctx);

            if !expect(ctx, TokenType.LBRACE) {
                mut err: string = format_error(ctx, str("Expected '{' after else"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx); // skip '{'

            push_scope();

            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }

                val t_else2: Token = peek(ctx);
                if t_else2.token_type == TokenType.RBRACE {
                    consume(ctx); // end of else-body
                    break;
                }

                val stmt2: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt2.node_type) > 0 {
                    append(final_else_children, stmt2);
                }
            }

            pop_scope();
        }

        mut i_chain: i32 = len(elif_nodes) - 1;
        loop {
            if i_chain < 0 {
                break;
            }
            
            mut else_body_for_this: list(ASTNode);
            
            if i_chain == len(elif_nodes) - 1 {
                if len(final_else_children) > 0 {
                    mut k_final: i32 = 0;
                    loop {
                        if k_final >= len(final_else_children) {
                            break;
                        }
                        append(else_body_for_this, final_else_children.data[k_final]);
                        k_final = k_final + 1;
                    }
                }
            } else {
                append(else_body_for_this, elif_nodes.data[i_chain + 1]);
            }
            
            if len(else_body_for_this) > 0 {
                unsafe {
                    mut new_children: list(ASTNode);
                    mut curr_elif_ptr: ref ASTNode = addr(elif_nodes.data[i_chain]);
                    
                    if curr_elif_ptr.children != nil {
                        mut j_copy: i32 = 0;
                        val curr_children: ref list(ASTNode) = curr_elif_ptr.children;
                        loop {
                            if j_copy >= len(deref(curr_children)) {
                                break;
                            }
                            append(new_children, curr_children.data[j_copy]);
                            j_copy = j_copy + 1;
                        }
                    }
                    
                    mut marker: ASTNode;
                    marker.node_type = str("ElseMarker");
                    append(new_children, marker);
                    
                    mut k_else: i32 = 0;
                    loop {
                        if k_else >= len(else_body_for_this) {
                            break;
                        }
                        append(new_children, else_body_for_this.data[k_else]);
                        k_else = k_else + 1;
                    }
                    
                    val sz_new: usize = C.sizeof(list(ASTNode));
                    val heap_new: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz_new));
                    if heap_new != nil {
                        C.memcpy(heap_new, addr(new_children), sz_new);
                        curr_elif_ptr.children = heap_new;
                    }
                }
            }
            
            i_chain = i_chain - 1;
        }

        mut else_children: list(ASTNode);
        if len(elif_nodes) > 0 {
            append(else_children, elif_nodes.data[0]);
        } else {
            mut k_else_final: i32 = 0;
            loop {
                if k_else_final >= len(final_else_children) {
                    break;
                }
                append(else_children, final_else_children.data[k_else_final]);
                k_else_final = k_else_final + 1;
            }
        }

        // Build If AST node with children list containing then-body and
        // (optionally) else-body nodes in order.
        node.node_type = str("If");
        node.line = if_line;
        node.source_file = ctx.filename;
        node.data.if_node.condition = condition;
        scan_expression_for_usage(condition);

        unsafe {
            mut body_list: list(ASTNode);

            // First, if-body statements
            mut i_body: i32 = 0;
            loop {
                if i_body >= len(if_children) {
                    break;
                }
                append(body_list, if_children.data[i_body]);
                i_body = i_body + 1;
            }

            // Sentinel: an empty node marking boundary between if and else
            if len(else_children) > 0 {
                mut marker: ASTNode;
                marker.node_type = str("ElseMarker");
                append(body_list, marker);

                mut i_else: i32 = 0;
                loop {
                    if i_else >= len(else_children) {
                        break;
                    }
                    append(body_list, else_children.data[i_else]);
                    i_else = i_else + 1;
                }
            }

            val list_size_if: usize = C.sizeof(list(ASTNode));
            val heap_list_if: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size_if));
            if heap_list_if != nil {
                C.memcpy(heap_list_if, addr(body_list), list_size_if);
                node.children = heap_list_if;
            }
        }

        return node;
    }
    
    if token_type == TokenType.FOR {
        consume(ctx);
        skip_whitespace(ctx);

        mut is_for_in: bool = false;
        mut temp_pos: i32 = ctx.pos;
        
        loop {
            if temp_pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[temp_pos].token_type != TokenType.WHITESPACE and ctx.tokens.data[temp_pos].token_type != TokenType.NEWLINE {
                break;
            }
            temp_pos = temp_pos + 1;
        }
        
        if temp_pos < len(ctx.tokens) and ctx.tokens.data[temp_pos].token_type == TokenType.IDENTIFIER {
            temp_pos = temp_pos + 1;
            loop {
                if temp_pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[temp_pos].token_type != TokenType.WHITESPACE and ctx.tokens.data[temp_pos].token_type != TokenType.NEWLINE {
                    break;
                }
                temp_pos = temp_pos + 1;
            }
            if temp_pos < len(ctx.tokens) and ctx.tokens.data[temp_pos].token_type == TokenType.IN {
                is_for_in = true;
            }
        }
        
        if is_for_in {
            if !expect(ctx, TokenType.IDENTIFIER) {
                mut err: string = format_error(ctx, str("Expected variable name in for-in loop"));
                enforce_raw(false, err.data);
                return node;
            }
            val item_var_token: Token = consume(ctx);
            val item_var: string = item_var_token.value;
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IN) {
                mut err: string = format_error(ctx, str("Expected 'in' in for-in loop"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx); // skip 'in'
            skip_whitespace(ctx);
            
            mut collection: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val ct: Token = peek(ctx);
                if ct.token_type == TokenType.LBRACE {
                    break;
                }
                if ct.token_type == TokenType.WHITESPACE or ct.token_type == TokenType.NEWLINE {
                    consume(ctx);
                    continue;
                }
                collection = concat(collection, ct.value);
                consume(ctx);
            }
            collection = strip(collection);
            
            if !expect(ctx, TokenType.LBRACE) {
                mut err: string = format_error(ctx, str("Expected '{' after for-in header"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx); // skip '{'
            
            push_scope();
            
            mut for_in_node: ASTNode;
            for_in_node.node_type = str("ForIn");
            for_in_node.data.for_in.var_name = item_var;
            for_in_node.data.for_in.array_name = collection;
            
            mut body: list(ASTNode);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                    consume(ctx); // skip '}'
                    break;
                }
                val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt.node_type) > 0 {
                    append(body, stmt);
                }
            }
            
            pop_scope();
            
            unsafe {
                val list_size: usize = C.sizeof(list(ASTNode));
                val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
                if heap_list != nil {
                    C.memcpy(heap_list, addr(body), list_size);
                    for_in_node.children = heap_list;
                }
            }
            
            return for_in_node;
        }
        
        mut header: string = str("");
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                header = concat(header, t.value);
                header = concat(header, str(" "));
            }
            consume(ctx);
        }

        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after for header"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // skip '{'

        mut init: string = str("");
        mut cond: string = str("");
        mut incr: string = str("");
        mut part_idx: i32 = 0;
        mut current: string = str("");
        mut i_hdr: i32 = 0;

        loop {
            if i_hdr >= str_len(header) {
                break;
            }
            val ch_hdr: char = get_char(header, i_hdr);
            if ch_hdr == ';' {
                val trimmed: string = strip(current);
                if str_len(trimmed) > 0 {
                    if part_idx == 0 {
                        init = trimmed;
                    } elif part_idx == 1 {
                        cond = trimmed;
                    } else {
                        incr = trimmed;
                    }
                }
                part_idx = part_idx + 1;
                current = str("");
            } else {
                current = concat_chr(current, ch_hdr);
            }
            i_hdr = i_hdr + 1;
        }

        val last_trimmed: string = strip(current);
        if str_len(last_trimmed) > 0 {
            if part_idx == 0 {
                init = last_trimmed;
            } elif part_idx == 1 {
                cond = last_trimmed;
            } else {
                incr = last_trimmed;
            }
        }

        // Handle "for mut i = 0 to n" syntax
        if part_idx == 0 and str_len(init) > 0 and str_len(cond) == 0 {
            val to_pos: i32 = find_substr(init, str(" to "));
            if to_pos >= 0 {
                val var_part: string = strip(substring_se(init, 0, to_pos));
                val end_part: string = strip(substring_se(init, to_pos + 4, str_len(init)));
                mut var_name: string = str("i");
                val eq_pos: i32 = find_char_from(var_part, '=', 0);
                if eq_pos > 0 {
                    val before_eq: string = strip(substring_se(var_part, 0, eq_pos));
                    mut name_part: string = before_eq;
                    if has_prefix(name_part, str("mut ")) {
                        name_part = strip(substring_se(name_part, 4, str_len(name_part)));
                    }
                    if str_len(name_part) > 0 {
                        var_name = name_part;
                    }
                }
                init = var_part;
                cond = concat(concat(var_name, str(" < ")), end_part);
                incr = concat(var_name, str("++"));
            }
        }

        mut fnode: ASTNode;
        fnode.node_type = str("For");
        fnode.data.for_loop.initialization = init;
        fnode.data.for_loop.condition = cond;
        fnode.data.for_loop.increment = incr;
        scan_expression_for_usage(init);
        scan_expression_for_usage(cond);
        scan_expression_for_usage(incr);

        push_scope();

        mut body: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }

            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx); // skip '}'
                break;
            }

            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }

        pop_scope();

        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(body), list_size);
                fnode.children = heap_list;
            }
        }

        return fnode;
    }
    
    // Handle PUT.
    if token_type == TokenType.PRINT {
        consume(ctx);
        skip_whitespace(ctx);

        if !expect(ctx, TokenType.STR) {
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t_skip: Token = peek(ctx);
                if t_skip.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            return node;
        }

        val str_token: Token = consume(ctx);
        skip_whitespace(ctx);

        if expect(ctx, TokenType.SEMICOLON) {
            consume(ctx);
        }

        mut messages: list(string);
        mut flags: list(bool);
        append(messages, str_token.value);
        append(flags, false);

        node.node_type = str("Print");

        unsafe {
            val list_size_str: usize = C.sizeof(list(string));
            mut heap_messages: ref list(string) = cast[ref list(string)](C.malloc(list_size_str));
            if heap_messages != nil {
                C.memcpy(heap_messages, addr(messages), list_size_str);
                node.data.print.messages = heap_messages;
            }

            val list_size_bool: usize = C.sizeof(list(bool));
            mut heap_flags: ref list(bool) = cast[ref list(bool)](C.malloc(list_size_bool));
            if heap_flags != nil {
                C.memcpy(heap_flags, addr(flags), list_size_bool);
                node.data.print.is_expressions = heap_flags;
            }
        }

        return node;
    }

    // Handle VAL and MUT VAL (variable declarations)
    if token_type == TokenType.VAL {
        val decl_line: i32 = token.line;
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            mut err: string = format_error(ctx, str("Expected identifier after 'val'"));
            enforce_raw(false, err.data);
            return node;
        }

        val var_name: Token = consume(ctx);
        skip_whitespace(ctx);

        mut type_name: string = str("");
        mut initializer: string = str("");
        mut has_explicit_type: bool = false;

        if expect(ctx, TokenType.COLON) {
            consume(ctx);
            type_name = parse_type(ctx);
            has_explicit_type = true;
            skip_whitespace(ctx);
        }

        if expect(ctx, TokenType.OPERATOR) {
            val op_token: Token = peek(ctx);
            if equals_c(op_token.value, "=") {
                consume(ctx);
                skip_whitespace(ctx);

                // mut rhs_has_function_call: bool = false;
                // mut last_non_ws_token_type: i32 = -1;
                mut first_non_ws_token: Token;
                mut non_ws_count: i32 = 0;

                mut found_semicolon: bool = false;
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        found_semicolon = true;
                        break;
                    }
                    
                    if t.token_type == TokenType.VAL or t.token_type == TokenType.MUT {
                        break;
                    }

                    if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        if non_ws_count == 0 {
                            first_non_ws_token = t;
                        }
                        non_ws_count = non_ws_count + 1;

                        // if t.token_type == TokenType.IDENTIFIER {
                        //     if ctx.pos + 1 < len(ctx.tokens) {
                        //         val next_t: Token = ctx.tokens.data[ctx.pos + 1];
                        //         if next_t.token_type == TokenType.LPAREN and last_non_ws_token_type != TokenType.NEW {
                        //             rhs_has_function_call = true;
                        //         }
                        //     }
                        // }
                        // last_non_ws_token_type = t.token_type;
                    }

                    if t.token_type == TokenType.STR {
                        initializer = concat(initializer, str("\""));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("\" "));
                    } elif t.token_type == TokenType.CHAR {
                        initializer = concat(initializer, str("'"));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("' "));
                    } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        // skip it
                    } else {
                        if t.token_type == TokenType.IDENTIFIER {
                            check_null_usage(ctx, t.value);
                        }
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str(" "));
                    }
                    consume(ctx);
                }
                
                if !found_semicolon {
                    mut err: string = format_error(ctx, str("Expected ';' after val declaration"));
                    enforce_raw(false, err.data);
                    return node;
                }

                initializer = expand_macros_in_expression(initializer);

                if !has_explicit_type {
                    if non_ws_count == 1 {
                        if first_non_ws_token.token_type == TokenType.NUMBER or (first_non_ws_token.token_type == TokenType.IDENTIFIER and is_all_digits(first_non_ws_token.value)) {
                            type_name = str("int32_t");
                        } elif first_non_ws_token.token_type == TokenType.CHAR {
                            type_name = str("char");
                        } elif first_non_ws_token.token_type == TokenType.STR {
                            type_name = str("char*");
                        }
                    }

                    val trimmed_init_val: string = strip(initializer);

                    if str_len(type_name) == 0 {
                        val brace_pos_val: i32 = find_char_from(trimmed_init_val, '{', 0);
                        if brace_pos_val > 0 {
                            val inferred_name_brace: string = strip(substring_se(trimmed_init_val, 0, brace_pos_val));
                            if str_len(inferred_name_brace) > 0 {
                                type_name = inferred_name_brace;
                            }
                        }
                    }
                }
            } else {
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }
                    consume(ctx);
                }
            }
        } else {
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
        }

        node.node_type = str("Declaration");
        node.line = decl_line;
        node.source_file = ctx.filename;
        node.data.declaration.name = var_name.value;
        node.data.declaration.is_mutable = false;
        node.data.declaration.initializer = initializer;
        node.data.declaration.type_name = type_name;
        node.data.declaration.ref_depth = 0;
        register_variable(var_name.value, false, decl_line, ctx.filename);
        scan_expression_for_addr(initializer);
        scan_expression_for_c_calls(initializer);
        scan_expression_for_usage(initializer);
        debug_print_raw "\n[DEBUG] VAL declaration details:";
        debug_print_raw "\n[DEBUG]   name:";
        debug_print_str var_name.value;
        debug_print_raw "\n[DEBUG]   type_name:";
        debug_print_str type_name;
        debug_print_raw "\n[DEBUG]   initializer:";
        debug_print_str initializer;
        debug_print_raw "\n[DEBUG] VAL declaration finished for:";
        debug_print_str var_name.value;
        return node;
    }
    
    if token_type == TokenType.MUT {
        val mut_line: i32 = token.line;
        consume(ctx); // Skip 'mut'
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.VAL) {
            consume(ctx);
            skip_whitespace(ctx);
        }
        
        if !expect(ctx, TokenType.IDENTIFIER) {
            mut err: string = format_error(ctx, str("Expected identifier after 'mut'"));
            enforce_raw(false, err.data);
            return node;
        }
        val var_name: Token = consume(ctx);
        skip_whitespace(ctx);

        mut type_name: string = str("");
        mut initializer: string = str("");
        mut has_explicit_type_mut: bool = false;

        if expect(ctx, TokenType.COLON) {
            consume(ctx);
            type_name = parse_type(ctx);
            has_explicit_type_mut = true;
            skip_whitespace(ctx);
        }

        if expect(ctx, TokenType.OPERATOR) {
            val op_token: Token = peek(ctx);
            if equals_c(op_token.value, "=") {
                consume(ctx);
                skip_whitespace(ctx);

                // mut rhs_has_function_call_mut: bool = false;
                // mut last_non_ws_token_type_mut: i32 = -1;
                mut first_non_ws_token_mut: Token;
                mut non_ws_count_mut: i32 = 0;
                mut found_semicolon_mut: bool = false;

                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        found_semicolon_mut = true;
                        break;
                    }
                    
                    if t.token_type == TokenType.VAL or t.token_type == TokenType.MUT {
                        break;
                    }

                    if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        if non_ws_count_mut == 0 {
                            first_non_ws_token_mut = t;
                        }
                        non_ws_count_mut = non_ws_count_mut + 1;

                        // if t.token_type == TokenType.IDENTIFIER {
                        //     if ctx.pos + 1 < len(ctx.tokens) {
                        //         val next_t: Token = ctx.tokens.data[ctx.pos + 1];
                        //         if next_t.token_type == TokenType.LPAREN and last_non_ws_token_type_mut != TokenType.NEW {
                        //             rhs_has_function_call_mut = true;
                        //         }
                        //     }
                        // }
                        // last_non_ws_token_type_mut = t.token_type;
                    }

                    if t.token_type == TokenType.STR {
                        initializer = concat(initializer, str("\""));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("\" "));
                    } elif t.token_type == TokenType.CHAR {
                        initializer = concat(initializer, str("'"));
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str("' "));
                    } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        // skip adding explicit whitespace
                    } else {
                        if t.token_type == TokenType.IDENTIFIER {
                            check_null_usage(ctx, t.value);
                        }
                        initializer = concat(initializer, t.value);
                        initializer = concat(initializer, str(" "));
                    }
                    consume(ctx);
                }
                
                if !found_semicolon_mut {
                    mut err: string = format_error(ctx, str("Expected ';' after mut declaration"));
                    enforce_raw(false, err.data);
                    return node;
                }

                initializer = expand_macros_in_expression(initializer);

                if !has_explicit_type_mut {
                    if non_ws_count_mut == 1 {
                        if first_non_ws_token_mut.token_type == TokenType.NUMBER or (first_non_ws_token_mut.token_type == TokenType.IDENTIFIER and is_all_digits(first_non_ws_token_mut.value)) {
                            type_name = str("int32_t");
                        } elif first_non_ws_token_mut.token_type == TokenType.CHAR {
                            type_name = str("char");
                        } elif first_non_ws_token_mut.token_type == TokenType.STR {
                            type_name = str("char*");
                        }
                    }

                    mut trimmed_init_mut: string = strip(initializer);
                    if str_len(type_name) == 0 and has_prefix(trimmed_init_mut, str("new ")) {
                        trimmed_init_mut = substring_se(trimmed_init_mut, 4, str_len(trimmed_init_mut));
                        trimmed_init_mut = strip(trimmed_init_mut);

                        mut end_pos_mut: i32 = -1;
                        mut i_mut: i32 = 0;
                        loop {
                            if i_mut >= str_len(trimmed_init_mut) {
                                break;
                            }
                            val ch_mut: char = get_char(trimmed_init_mut, i_mut);
                            if ch_mut == '(' or ch_mut == ' ' or ch_mut == '\t' {
                                end_pos_mut = i_mut;
                                break;
                            }
                            i_mut = i_mut + 1;
                        }
                        if end_pos_mut < 0 {
                            end_pos_mut = str_len(trimmed_init_mut);
                        }
                        val inferred_name_mut: string = strip(substring_se(trimmed_init_mut, 0, end_pos_mut));
                        if str_len(inferred_name_mut) > 0 {
                            type_name = inferred_name_mut;
                        }
                    }
                }
            } else {
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }
                    consume(ctx);
                }
            }
        } else {
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
        }

        node.node_type = str("Declaration");
        node.line = mut_line;
        node.source_file = ctx.filename;
        node.data.declaration.name = var_name.value;
        node.data.declaration.is_mutable = true;
        node.data.declaration.initializer = initializer;
        node.data.declaration.type_name = type_name;
        node.data.declaration.ref_depth = 0;

        register_variable(var_name.value, true, mut_line, ctx.filename);


        if str_len(initializer) > 0 {
            val has_dot: bool = find_char_from(initializer, '.', 0) >= 0;
            val has_paren: bool = find_char_from(initializer, '(', 0) >= 0;
            val is_constructor: bool = has_dot and has_paren;
            
            if !is_constructor {
                register_for_mutation_tracking(var_name.value);
            }
            
            scan_expression_for_addr(initializer);
            scan_expression_for_c_calls(initializer);
            scan_expression_for_usage(initializer);

            if contains_c_call(initializer) {
                mark_variable_mutated(var_name.value);
            }
        }
        debug_print_raw "\n[DEBUG] MUT declaration finished for:";
        debug_print_str var_name.value;
        return node;
    }
    
    // Handle IDENTIFIER (function calls, assignments, etc.)
    if token_type == TokenType.IDENTIFIER {
        val ident_token: Token = consume(ctx);
        mut ident_name: string = ident_token.value;
        skip_whitespace(ctx);
        
        if macros_contains(ident_name) and ctx.pos < len(ctx.tokens) and ctx.tokens.data[ctx.pos].token_type == TokenType.LPAREN {
            consume(ctx);
            
            mut args: list(string);
            mut current_arg: string = str("");
            mut paren_depth: i32 = 0;
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                
                val t: Token = peek(ctx);
                
                if t.token_type == TokenType.RPAREN and paren_depth == 0 {
                    val trimmed: string = strip(current_arg);
                    if str_len(trimmed) > 0 {
                        append(args, trimmed);
                    }
                    consume(ctx);
                    break;
                }
                
                if t.token_type == TokenType.LPAREN {
                    paren_depth = paren_depth + 1;
                    current_arg = concat(current_arg, t.value);
                    consume(ctx);
                    continue;
                }
                
                if t.token_type == TokenType.RPAREN {
                    paren_depth = paren_depth - 1;
                    current_arg = concat(current_arg, t.value);
                    consume(ctx);
                    continue;
                }
                
                if t.token_type == TokenType.COMMA and paren_depth == 0 {
                    val trimmed_arg: string = strip(current_arg);
                    if str_len(trimmed_arg) > 0 {
                        append(args, trimmed_arg);
                    }
                    current_arg = str("");
                    consume(ctx);
                    continue;
                }
                
                if t.token_type == TokenType.STR {
                    current_arg = concat(current_arg, str("\""));
                    current_arg = concat(current_arg, t.value);
                    current_arg = concat(current_arg, str("\""));
                } elif t.token_type == TokenType.CHAR {
                    current_arg = concat(current_arg, str("'"));
                    current_arg = concat(current_arg, t.value);
                    current_arg = concat(current_arg, str("'"));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    current_arg = concat(current_arg, str(" "));
                } else {
                    current_arg = concat(current_arg, t.value);
                }
                consume(ctx);
            }
            
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.SEMICOLON) {
                mut err: string = format_error(ctx, str("Expected ';' after macro invocation"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            val defn: MacroDef = macros_get(ident_name);
            
            mut expanded_tokens: list(Token);
            mut i_tok: i32 = 0;
            loop {
                if i_tok >= len(defn.body) {
                    break;
                }
                append(expanded_tokens, defn.body.data[i_tok]);
                i_tok = i_tok + 1;
            }
            
            mut i_param: i32 = 0;
            loop {
                if i_param >= len(defn.params) or i_param >= len(args) {
                    break;
                }
                
                val param_name: string = defn.params.data[i_param];
                val arg_expr: string = args.data[i_param];
                mut j_tok: i32 = 0;

                loop {
                    if j_tok >= len(expanded_tokens) {
                        break;
                    }
                    
                    if expanded_tokens.data[j_tok].token_type == TokenType.IDENTIFIER {
                        mut exp_token: ref Token = addr(expanded_tokens.data[j_tok]);
                        if compare(exp_token.value, param_name) == 0 {
                            exp_token.value = arg_expr;
                            
                            if is_all_digits(arg_expr) {
                                exp_token.token_type = TokenType.NUMBER;
                            }
                        }
                    }
                    j_tok++;
                }
                
                i_param++;
            }
            
            mut temp_ctx: ParserContext;
            temp_ctx.tokens = addr(expanded_tokens);
            temp_ctx.pos = 0;
            temp_ctx.is_axec = ctx.is_axec;
            temp_ctx.check_entry_point = false;
            temp_ctx.current_module = ctx.current_module;
            temp_ctx.filename = ctx.filename;
            temp_ctx.current_scope = ctx.current_scope;
            
            mut expanded_nodes: list(ASTNode);
            
            loop {
                if temp_ctx.pos >= len(deref(temp_ctx.tokens)) {
                    break;
                }
                
                loop {
                    if temp_ctx.pos >= len(deref(temp_ctx.tokens)) {
                        break;
                    }
                    val t: Token = temp_ctx.tokens.data[temp_ctx.pos];
                    if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        break;
                    }
                    temp_ctx.pos++;
                }
                
                if temp_ctx.pos >= len(deref(temp_ctx.tokens)) {
                    break;
                }
                
                val stmt: ASTNode = parse_statement_helper(addr(temp_ctx), addr(temp_ctx.current_scope));
                if str_len(stmt.node_type) > 0 {
                    append(expanded_nodes, stmt);
                }
            }
            
            if len(expanded_nodes) == 0 {
                return node;
            } elif len(expanded_nodes) == 1 {
                return expanded_nodes.data[0];
            } else {
                mut compound: ASTNode;
                compound.node_type = str("MacroExpansion");
                compound.line = node.line;
                compound.source_file = ctx.filename;
                
                unsafe {
                    val list_size: usize = C.sizeof(list(ASTNode));
                    val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
                    if heap_list != nil {
                        C.memcpy(heap_list, addr(expanded_nodes), list_size);
                        compound.children = heap_list;
                    }
                }
                
                return compound;
            }
        }

        if ctx.pos + 1 < len(ctx.tokens) {
            val look1: Token = ctx.tokens.data[ctx.pos];
            val look2: Token = ctx.tokens.data[ctx.pos + 1];

            if look1.token_type == TokenType.IDENTIFIER and equals_c(look2.value, "(") {
                mut merged_call: string = ident_name;
                val next_ident_call: string = look1.value;

                if str_len(next_ident_call) > 0 and get_char(next_ident_call, 0) != '_' {
                    merged_call = concat(merged_call, str("_"));
                }

                merged_call = concat(merged_call, next_ident_call);
                ident_name = merged_call;
                ctx.pos = ctx.pos + 1;
                skip_whitespace(ctx);
            }
        }

        if ctx.pos >= len(ctx.tokens) {
            return node;
        }
        
        val next_token: Token = peek(ctx);
        
        if next_token.token_type == TokenType.LPAREN {
            consume(ctx);            
            mut paren_depth: i32 = 1;
            mut args_str: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.LPAREN {
                    paren_depth = paren_depth + 1;
                    args_str = concat(args_str, str("("));
                } elif t.token_type == TokenType.RPAREN {
                    paren_depth = paren_depth - 1;
                    if paren_depth == 0 {
                        consume(ctx);
                        break;
                    }
                    args_str = concat(args_str, str(")"));
                } elif t.token_type == TokenType.STR {
                    args_str = concat(args_str, str("\""));
                    args_str = concat(args_str, t.value);
                    args_str = concat(args_str, str("\""));
                } elif t.token_type == TokenType.CHAR {
                    args_str = concat(args_str, str("'"));
                    args_str = concat(args_str, t.value);
                    args_str = concat(args_str, str("'"));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    // normalize to single space
                    args_str = concat(args_str, str(" "));
                } else {
                    if t.token_type == TokenType.IDENTIFIER {
                        check_null_usage(ctx, t.value);
                    }
                    args_str = concat(args_str, t.value);
                }
                consume(ctx);
            }
            
            skip_whitespace(ctx);
            
            // Scan function arguments for addr() calls
            scan_expression_for_addr(args_str);
            scan_expression_for_c_calls(args_str);
            scan_expression_for_usage(args_str);
            // Scan for variables passed as arguments (potential ref params)
            scan_function_args_for_ref_params(args_str);
            
            mut is_assignment: bool = false;
            if ctx.pos < len(ctx.tokens) {
                val look_tok: Token = peek(ctx);
                if look_tok.token_type == TokenType.OPERATOR and equals_c(look_tok.value, "=") {
                    is_assignment = true;
                }
            }
            
            if is_assignment {
                consume(ctx); // Skip '='
                skip_whitespace(ctx);
                
                mut value_str: string = str("");
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val vt: Token = peek(ctx);
                    if vt.token_type == TokenType.SEMICOLON {
                        break;
                    }
                    if vt.token_type == TokenType.STR {
                        value_str = concat(value_str, str("\""));
                        value_str = concat(value_str, vt.value);
                        value_str = concat(value_str, str("\""));
                    } elif vt.token_type == TokenType.CHAR {
                        value_str = concat(value_str, str("'"));
                        value_str = concat(value_str, vt.value);
                        value_str = concat(value_str, str("'"));
                    } elif vt.token_type == TokenType.WHITESPACE or vt.token_type == TokenType.NEWLINE {
                        value_str = concat(value_str, str(" "));
                    } else {
                        if vt.token_type == TokenType.IDENTIFIER {
                            check_null_usage(ctx, vt.value);
                        }
                        value_str = concat(value_str, vt.value);
                    }
                    consume(ctx);
                }
                
                if !expect(ctx, TokenType.SEMICOLON) {
                    mut err: string = format_error(ctx, str("Expected ';' after function call assignment"));
                    enforce_raw(false, err.data);
                    return node;
                }
                consume(ctx);
                
                value_str = expand_macros_in_expression(value_str);
                
                mut left_side: string = concat(ident_name, str("("));
                left_side = concat(left_side, strip(args_str));
                left_side = concat(left_side, str(")"));
                
                node.node_type = str("Assignment");
                node.data.assignment.variable = left_side;
                node.data.assignment.expression = strip(value_str);
                node.data.assignment.operator = str("=");
                return node;
            }
            
            if !expect(ctx, TokenType.SEMICOLON) {
                mut err: string = format_error(ctx, str("Expected ';' after function call"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            node.node_type = str("FunctionCall");
            node.data.func_call.function_name = ident_name;

            mut args_list: list(string);
            val trimmed_args: string = strip(args_str);
            if str_len(trimmed_args) > 0 {
                append(args_list, trimmed_args);
            }

            unsafe {
                val list_size: usize = C.sizeof(list(string));
                mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
                if heap_list != nil {
                    C.memcpy(heap_list, addr(args_list), list_size);
                    node.data.func_call.args = heap_list;
                }
            }
            return node;
        }
        
        if next_token.token_type == TokenType.LBRACKET {
            consume(ctx); // Skip '['
            skip_whitespace(ctx);
            
            mut index_expr: string = str("");
            mut bracket_depth: i32 = 0;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.LBRACKET {
                    bracket_depth = bracket_depth + 1;
                    index_expr = concat(index_expr, t.value);
                    index_expr = concat(index_expr, str(" "));
                } elif t.token_type == TokenType.RBRACKET {
                    if bracket_depth == 0 {
                        break;
                    }
                    bracket_depth = bracket_depth - 1;
                    index_expr = concat(index_expr, t.value);
                    index_expr = concat(index_expr, str(" "));
                } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                    index_expr = concat(index_expr, t.value);
                    index_expr = concat(index_expr, str(" "));
                }
                consume(ctx);
            }
            
            if !expect(ctx, TokenType.RBRACKET) {
                mut err: string = format_error(ctx, str("Expected ']' after array index"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            skip_whitespace(ctx);
            
            mut index2_expr: string = str("");
            if expect(ctx, TokenType.LBRACKET) {
                consume(ctx); // Skip '['
                skip_whitespace(ctx);
                
                bracket_depth = 0;
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.LBRACKET {
                        bracket_depth = bracket_depth + 1;
                        index2_expr = concat(index2_expr, t.value);
                        index2_expr = concat(index2_expr, str(" "));
                    } elif t.token_type == TokenType.RBRACKET {
                        if bracket_depth == 0 {
                            break;
                        }
                        bracket_depth = bracket_depth - 1;
                        index2_expr = concat(index2_expr, t.value);
                        index2_expr = concat(index2_expr, str(" "));
                    } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        index2_expr = concat(index2_expr, t.value);
                        index2_expr = concat(index2_expr, str(" "));
                    }
                    consume(ctx);
                }
                
                if !expect(ctx, TokenType.RBRACKET) {
                    mut err: string = format_error(ctx, str("Expected ']' after second array index"));
                    enforce_raw(false, err.data);
                    return node;
                }
                consume(ctx);
                skip_whitespace(ctx);
            }
            
            // Check if this is array assignment: array[index] = value
            if expect(ctx, TokenType.OPERATOR) {
                val op_token: Token = peek(ctx);
                if equals_c(op_token.value, "=") {
                    consume(ctx); // Skip '='
                    skip_whitespace(ctx);
                    
                    mut value_expr: string = str("");
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.SEMICOLON {
                            consume(ctx);
                            break;
                        }
                        if t.token_type == TokenType.STR {
                            value_expr = concat(value_expr, str("\""));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("\" "));
                        } elif t.token_type == TokenType.CHAR {
                            value_expr = concat(value_expr, str("'"));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("' "));
                        } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        } else {
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    node.node_type = str("ArrayAssign");
                    node.data.array_assign.array_name = ident_name;
                    node.data.array_assign.index = index_expr;
                    node.data.array_assign.index2 = index2_expr;
                    node.data.array_assign.value = value_expr;
                    scan_expression_for_usage(index_expr);
                    scan_expression_for_usage(index2_expr);
                    scan_expression_for_usage(value_expr);
                    // Mark the array/pointer variable as mutated
                    mark_variable_mutated(ident_name);
                    return node;
                }
            }
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            
            node.node_type = str("ArrayAccess");
            node.data.array_access.array_name = ident_name;
            node.data.array_access.index = index_expr;
            node.data.array_access.index2 = index2_expr;
            return node;
        }
        
        if next_token.token_type == TokenType.DOT {
            consume(ctx); // Skip '.'
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                mut err: string = format_error(ctx, str("Expected member name after '.'"));
                enforce_raw(false, err.data);
                return node;
            }

            val member_token: Token = consume(ctx);
            mut member_name: string = member_token.value;

            skip_whitespace(ctx);

            loop {
                if !expect(ctx, TokenType.DOT) {
                    break;
                }
                consume(ctx);
                skip_whitespace(ctx);
                
                if !expect(ctx, TokenType.IDENTIFIER) {
                    break;
                }
                
                val next_member_token: Token = consume(ctx);
                member_name = concat(member_name, str("."));
                member_name = concat(member_name, next_member_token.value);
                skip_whitespace(ctx);
            }

            if ctx.pos + 1 < len(ctx.tokens) {
                val look_member: Token = ctx.tokens.data[ctx.pos];
                val look_after: Token = ctx.tokens.data[ctx.pos + 1];
                if look_member.token_type == TokenType.IDENTIFIER and look_after.token_type == TokenType.LPAREN {
                    mut merged_member: string = member_name;
                    val next_ident_member: string = look_member.value;

                    if str_len(next_ident_member) > 0 and get_char(next_ident_member, 0) != '_' {
                        merged_member = concat(merged_member, str("_"));
                    }

                    merged_member = concat(merged_member, next_ident_member);
                    member_name = merged_member;
                    ctx.pos = ctx.pos + 1;
                    skip_whitespace(ctx);
                }
            }

            if expect(ctx, TokenType.LPAREN) {
                consume(ctx); // skip '('
                mut paren_depth2: i32 = 1;
                mut args_str2: string = str("");
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t2: Token = peek(ctx);
                    if t2.token_type == TokenType.LPAREN {
                        paren_depth2 = paren_depth2 + 1;
                        args_str2 = concat(args_str2, str("("));
                    } elif t2.token_type == TokenType.RPAREN {
                        paren_depth2 = paren_depth2 - 1;
                        if paren_depth2 == 0 {
                            consume(ctx);
                            break;
                        }
                        args_str2 = concat(args_str2, str(")"));
                    } elif t2.token_type == TokenType.STR {
                        args_str2 = concat(args_str2, str("\""));
                        args_str2 = concat(args_str2, t2.value);
                        args_str2 = concat(args_str2, str("\""));
                    } elif t2.token_type == TokenType.CHAR {
                        args_str2 = concat(args_str2, str("'"));
                        args_str2 = concat(args_str2, t2.value);
                        args_str2 = concat(args_str2, str("'"));
                    } elif t2.token_type == TokenType.WHITESPACE or t2.token_type == TokenType.NEWLINE {
                        args_str2 = concat(args_str2, str(" "));
                    } else {
                        args_str2 = concat(args_str2, t2.value);
                    }
                    consume(ctx);
                }

                skip_whitespace(ctx);
                if expect(ctx, TokenType.SEMICOLON) {
                    consume(ctx);
                }

                scan_expression_for_addr(args_str2);
                scan_expression_for_c_calls(args_str2);
                scan_expression_for_usage(args_str2);
                scan_function_args_for_ref_params(args_str2);

                node.node_type = str("FunctionCall");
                mut full_name: string = ident_name;

                if equals_c(ident_name, "C") {
                    full_name = concat(str("C."), member_name);
                } else {
                    full_name = concat(full_name, str("__"));
                    full_name = concat(full_name, member_name);
                }

                node.data.func_call.function_name = full_name;

                mut args_list2: list(string);
                val trimmed2: string = strip(args_str2);
                if str_len(trimmed2) > 0 {
                    append(args_list2, trimmed2);
                }

                unsafe {
                    val list_size2: usize = C.sizeof(list(string));
                    mut heap_list2: ref list(string) = cast[ref list(string)](C.malloc(list_size2));
                    if heap_list2 != nil {
                        C.memcpy(heap_list2, addr(args_list2), list_size2);
                        node.data.func_call.args = heap_list2;
                    }
                }
                return node;
            }
            
            if expect(ctx, TokenType.LBRACKET) {
                consume(ctx); // Skip '['
                skip_whitespace(ctx);
                
                mut member_index_expr: string = str("");
                mut member_bracket_depth: i32 = 0;
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.LBRACKET {
                        member_bracket_depth = member_bracket_depth + 1;
                        member_index_expr = concat(member_index_expr, t.value);
                        member_index_expr = concat(member_index_expr, str(" "));
                    } elif t.token_type == TokenType.RBRACKET {
                        if member_bracket_depth == 0 {
                            break;
                        }
                        member_bracket_depth = member_bracket_depth - 1;
                        member_index_expr = concat(member_index_expr, t.value);
                        member_index_expr = concat(member_index_expr, str(" "));
                    } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        member_index_expr = concat(member_index_expr, t.value);
                        member_index_expr = concat(member_index_expr, str(" "));
                    }
                    consume(ctx);
                }
                
                if !expect(ctx, TokenType.RBRACKET) {
                    mut err: string = format_error(ctx, str("Expected ']' after member array index"));
                    enforce_raw(false, err.data);
                    return node;
                }
                consume(ctx);
                skip_whitespace(ctx);
                
                mut member_index2_expr: string = str("");
                if expect(ctx, TokenType.LBRACKET) {
                    consume(ctx); // Skip '['
                    skip_whitespace(ctx);
                    
                    member_bracket_depth = 0;
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.LBRACKET {
                            member_bracket_depth = member_bracket_depth + 1;
                            member_index2_expr = concat(member_index2_expr, t.value);
                            member_index2_expr = concat(member_index2_expr, str(" "));
                        } elif t.token_type == TokenType.RBRACKET {
                            if member_bracket_depth == 0 {
                                break;
                            }
                            member_bracket_depth = member_bracket_depth - 1;
                            member_index2_expr = concat(member_index2_expr, t.value);
                            member_index2_expr = concat(member_index2_expr, str(" "));
                        } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                            member_index2_expr = concat(member_index2_expr, t.value);
                            member_index2_expr = concat(member_index2_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    if !expect(ctx, TokenType.RBRACKET) {
                        mut err: string = format_error(ctx, str("Expected ']' after second member array index"));
                        enforce_raw(false, err.data);
                        return node;
                    }
                    consume(ctx);
                    skip_whitespace(ctx);
                }
                
                if expect(ctx, TokenType.OPERATOR) {
                    val member_op_token: Token = peek(ctx);
                    if equals_c(member_op_token.value, "=") {
                        consume(ctx); // Skip '='
                        skip_whitespace(ctx);
                        
                        mut member_array_value_expr: string = str("");
                        loop {
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }
                            val t: Token = peek(ctx);
                            if t.token_type == TokenType.SEMICOLON {
                                consume(ctx);
                                break;
                            }
                            if t.token_type == TokenType.STR {
                                member_array_value_expr = concat(member_array_value_expr, str("\""));
                                member_array_value_expr = concat(member_array_value_expr, t.value);
                                member_array_value_expr = concat(member_array_value_expr, str("\" "));
                            } elif t.token_type == TokenType.CHAR {
                                member_array_value_expr = concat(member_array_value_expr, str("'"));
                                member_array_value_expr = concat(member_array_value_expr, t.value);
                                member_array_value_expr = concat(member_array_value_expr, str("' "));
                            } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                            } else {
                                member_array_value_expr = concat(member_array_value_expr, t.value);
                                member_array_value_expr = concat(member_array_value_expr, str(" "));
                            }
                            consume(ctx);
                        }
                        
                        mut full_array_name: string = ident_name;
                        full_array_name = concat(full_array_name, str("."));
                        full_array_name = concat(full_array_name, member_name);
                        
                        node.node_type = str("ArrayAssign");
                        node.data.array_assign.array_name = full_array_name;
                        node.data.array_assign.index = member_index_expr;
                        node.data.array_assign.index2 = member_index2_expr;
                        node.data.array_assign.value = member_array_value_expr;
                        scan_expression_for_usage(member_index_expr);
                        scan_expression_for_usage(member_index2_expr);
                        scan_expression_for_usage(member_array_value_expr);
                        // Mark the base variable as mutated
                        mark_variable_mutated(ident_name);
                        return node;
                    }
                }
                
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }
                    consume(ctx);
                }
                
                mut access_array_name: string = ident_name;
                access_array_name = concat(access_array_name, str("."));
                access_array_name = concat(access_array_name, member_name);
                
                node.node_type = str("ArrayAccess");
                node.data.array_access.array_name = access_array_name;
                node.data.array_access.index = member_index_expr;
                node.data.array_access.index2 = member_index2_expr;
                return node;
            }
            
            if expect(ctx, TokenType.OPERATOR) {
                val op_token: Token = peek(ctx);
                if equals_c(op_token.value, "=") {
                    debug_print_raw "\n[DEBUG] MemberAccess assignment check:";
                    debug_print_raw "\n[DEBUG]   object ident_name:";
                    debug_print_str ident_name;
                    debug_print_raw "\n[DEBUG]   member_name:";
                    debug_print_str member_name;

                    if !is_variable_mutable(ident_name) {
                        mut err: string = str("Cannot assign to member '");
                        err = concat(err, member_name);
                        err = concat(err, str("' of immutable variable '"));
                        err = concat(err, ident_name);
                        err = concat(err, str("'"));
                        enforce_raw(false, format_error(ctx, err).data);
                        return node;
                    }

                    consume(ctx);
                    skip_whitespace(ctx);
                    
                    mut value_expr: string = str("");
                    mut found_semicolon_member: bool = false;
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.SEMICOLON {
                            consume(ctx);
                            found_semicolon_member = true;
                            break;
                        }
                        
                        if t.token_type == TokenType.VAL or t.token_type == TokenType.MUT {
                            break;
                        }
                        if t.token_type == TokenType.STR {
                            value_expr = concat(value_expr, str("\""));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("\" "));
                        } elif t.token_type == TokenType.CHAR {
                            value_expr = concat(value_expr, str("'"));
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str("' "));
                        } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        } else {
                            value_expr = concat(value_expr, t.value);
                            value_expr = concat(value_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    if !found_semicolon_member {
                        mut err: string = format_error(ctx, str("Expected ';' after member assignment"));
                        enforce_raw(false, err.data);
                        return node;
                    }
                    
                    node.node_type = str("MemberAccess");
                    node.data.member_access.object_name = ident_name;
                    node.data.member_access.member_name = member_name;
                    node.data.member_access.value = value_expr;
                    scan_expression_for_usage(value_expr);
                    mark_variable_mutated(ident_name);
                    return node;
                }
            }
            
            // Check for: member increment/decrement, so obj.field++ or obj.field--
            if expect(ctx, TokenType.INCREMENT) or expect(ctx, TokenType.DECREMENT) {
                val inc_dec_token: Token = peek(ctx);
                val is_inc: bool = inc_dec_token.token_type == TokenType.INCREMENT;
                consume(ctx);
                skip_whitespace(ctx);
                
                if !expect(ctx, TokenType.SEMICOLON) {
                    mut err: string = format_error(ctx, str("Expected ';' after member increment/decrement"));
                    enforce_raw(false, err.data);
                    return node;
                }
                consume(ctx);
                
                node.node_type = str("MemberIncDec");
                node.data.member_inc_dec.object_name = ident_name;
                node.data.member_inc_dec.member_name = member_name;
                node.data.member_inc_dec.is_increment = is_inc;
                return node;
            }
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            
            node.node_type = str("MemberAccess");
            node.data.member_access.object_name = ident_name;
            node.data.member_access.member_name = member_name;
            node.data.member_access.value = str("");
            return node;
        }
        
        if next_token.token_type == TokenType.STAR_DOT {
            consume(ctx); // Skip '*.'
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.IDENTIFIER) {
                mut err: string = format_error(ctx, str("Expected member name after '*.' "));
                enforce_raw(false, err.data);
                return node;
            }
            
            val ptr_member_token: Token = consume(ctx);
            val ptr_member_name: string = ptr_member_token.value;
            skip_whitespace(ctx);
            
            // Handle pointer member array access: ptr*.member[index] or ptr*.member[index] = value
            if expect(ctx, TokenType.LBRACKET) {
                consume(ctx); // Skip '['
                skip_whitespace(ctx);
                
                mut ptr_member_index_expr: string = str("");
                mut ptr_member_bracket_depth: i32 = 0;
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.LBRACKET {
                        ptr_member_bracket_depth = ptr_member_bracket_depth + 1;
                        ptr_member_index_expr = concat(ptr_member_index_expr, t.value);
                        ptr_member_index_expr = concat(ptr_member_index_expr, str(" "));
                    } elif t.token_type == TokenType.RBRACKET {
                        if ptr_member_bracket_depth == 0 {
                            break;
                        }
                        ptr_member_bracket_depth = ptr_member_bracket_depth - 1;
                        ptr_member_index_expr = concat(ptr_member_index_expr, t.value);
                        ptr_member_index_expr = concat(ptr_member_index_expr, str(" "));
                    } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        ptr_member_index_expr = concat(ptr_member_index_expr, t.value);
                        ptr_member_index_expr = concat(ptr_member_index_expr, str(" "));
                    }
                    consume(ctx);
                }
                
                if !expect(ctx, TokenType.RBRACKET) {
                    mut err: string = format_error(ctx, str("Expected ']' after pointer member array index"));
                    enforce_raw(false, err.data);
                    return node;
                }
                consume(ctx);
                skip_whitespace(ctx);
                
                mut ptr_member_index2_expr: string = str("");
                if expect(ctx, TokenType.LBRACKET) {
                    consume(ctx); // Skip '['
                    skip_whitespace(ctx);
                    
                    ptr_member_bracket_depth = 0;
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.LBRACKET {
                            ptr_member_bracket_depth = ptr_member_bracket_depth + 1;
                            ptr_member_index2_expr = concat(ptr_member_index2_expr, t.value);
                            ptr_member_index2_expr = concat(ptr_member_index2_expr, str(" "));
                        } elif t.token_type == TokenType.RBRACKET {
                            if ptr_member_bracket_depth == 0 {
                                break;
                            }
                            ptr_member_bracket_depth = ptr_member_bracket_depth - 1;
                            ptr_member_index2_expr = concat(ptr_member_index2_expr, t.value);
                            ptr_member_index2_expr = concat(ptr_member_index2_expr, str(" "));
                        } elif t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                            ptr_member_index2_expr = concat(ptr_member_index2_expr, t.value);
                            ptr_member_index2_expr = concat(ptr_member_index2_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    if !expect(ctx, TokenType.RBRACKET) {
                        mut err: string = format_error(ctx, str("Expected ']' after second pointer member array index"));
                        enforce_raw(false, err.data);
                        return node;
                    }
                    consume(ctx);
                    skip_whitespace(ctx);
                }
                
                if expect(ctx, TokenType.OPERATOR) {
                    val ptr_member_op_token: Token = peek(ctx);
                    if equals_c(ptr_member_op_token.value, "=") {
                        consume(ctx); // Skip '='
                        skip_whitespace(ctx);
                        
                        mut ptr_member_array_value_expr: string = str("");
                        loop {
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }
                            val t: Token = peek(ctx);
                            if t.token_type == TokenType.SEMICOLON {
                                consume(ctx);
                                break;
                            }
                            if t.token_type == TokenType.STR {
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, str("\""));
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, t.value);
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, str("\" "));
                            } elif t.token_type == TokenType.CHAR {
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, str("'"));
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, t.value);
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, str("' "));
                            } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                            } else {
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, t.value);
                                ptr_member_array_value_expr = concat(ptr_member_array_value_expr, str(" "));
                            }
                            consume(ctx);
                        }
                        
                        mut full_ptr_array_name: string = ident_name;
                        full_ptr_array_name = concat(full_ptr_array_name, str("*."));
                        full_ptr_array_name = concat(full_ptr_array_name, ptr_member_name);
                        
                        node.node_type = str("ArrayAssign");
                        node.data.array_assign.array_name = full_ptr_array_name;
                        node.data.array_assign.index = ptr_member_index_expr;
                        node.data.array_assign.index2 = ptr_member_index2_expr;
                        node.data.array_assign.value = ptr_member_array_value_expr;
                        scan_expression_for_usage(ptr_member_index_expr);
                        scan_expression_for_usage(ptr_member_index2_expr);
                        scan_expression_for_usage(ptr_member_array_value_expr);
                        // Mark the base variable as mutated
                        mark_variable_mutated(ident_name);
                        return node;
                    }
                }
                
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.SEMICOLON {
                        consume(ctx);
                        break;
                    }
                    consume(ctx);
                }
                
                mut access_ptr_array_name: string = ident_name;
                access_ptr_array_name = concat(access_ptr_array_name, str("*."));
                access_ptr_array_name = concat(access_ptr_array_name, ptr_member_name);
                
                node.node_type = str("ArrayAccess");
                node.data.array_access.array_name = access_ptr_array_name;
                node.data.array_access.index = ptr_member_index_expr;
                node.data.array_access.index2 = ptr_member_index2_expr;
                return node;
            }
            
            if expect(ctx, TokenType.OPERATOR) {
                val op_token: Token = peek(ctx);
                if equals_c(op_token.value, "=") {
                    consume(ctx); // Skip '='
                    skip_whitespace(ctx);
                    
                    mut ptr_value_expr: string = str("");
                    mut found_semicolon_ptr: bool = false;

                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.SEMICOLON {
                            consume(ctx);
                            found_semicolon_ptr = true;
                            break;
                        }
                        if t.token_type == TokenType.VAL or t.token_type == TokenType.MUT {
                            break;
                        }
                        if t.token_type == TokenType.STR {
                            ptr_value_expr = concat(ptr_value_expr, str("\""));
                            ptr_value_expr = concat(ptr_value_expr, t.value);
                            ptr_value_expr = concat(ptr_value_expr, str("\" "));
                        } elif t.token_type == TokenType.CHAR {
                            ptr_value_expr = concat(ptr_value_expr, str("'"));
                            ptr_value_expr = concat(ptr_value_expr, t.value);
                            ptr_value_expr = concat(ptr_value_expr, str("' "));
                        } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                        } else {
                            ptr_value_expr = concat(ptr_value_expr, t.value);
                            ptr_value_expr = concat(ptr_value_expr, str(" "));
                        }
                        consume(ctx);
                    }
                    
                    if !found_semicolon_ptr {
                        mut err: string = format_error(ctx, str("Expected ';' after pointer member assignment"));
                        enforce_raw(false, err.data);
                        return node;
                    }
                    
                    node.node_type = str("PtrMemberAccess");
                    node.data.member_access.object_name = ident_name;
                    node.data.member_access.member_name = ptr_member_name;
                    node.data.member_access.value = ptr_value_expr;
                    scan_expression_for_usage(ptr_value_expr);
                    mark_variable_mutated(ident_name);
                    return node;
                }
            }
            
            if expect(ctx, TokenType.INCREMENT) or expect(ctx, TokenType.DECREMENT) {
                val ptr_inc_dec_token: Token = peek(ctx);
                val ptr_is_inc: bool = ptr_inc_dec_token.token_type == TokenType.INCREMENT;
                consume(ctx);
                skip_whitespace(ctx);
                
                if !expect(ctx, TokenType.SEMICOLON) {
                    mut err: string = format_error(ctx, str("Expected ';' after pointer member increment/decrement"));
                    enforce_raw(false, err.data);
                    return node;
                }
                consume(ctx);
                
                node.node_type = str("PtrMemberIncDec");
                node.data.member_inc_dec.object_name = ident_name;
                node.data.member_inc_dec.member_name = ptr_member_name;
                node.data.member_inc_dec.is_increment = ptr_is_inc;
                return node;
            }
            
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    break;
                }
                consume(ctx);
            }
            
            node.node_type = str("PtrMemberAccess");
            node.data.member_access.object_name = ident_name;
            node.data.member_access.member_name = ptr_member_name;
            node.data.member_access.value = str("");
            return node;
        }
        
        if next_token.token_type == TokenType.PLUS_ASSIGN or next_token.token_type == TokenType.MINUS_ASSIGN {
            val compound_op: string = next_token.value;
            debug_print_raw "\n[DEBUG] parse_statement_helper: entering compound Assignment branch";
            debug_print_raw "\n[DEBUG]   ident_name:";
            debug_print_str ident_name;
            debug_print_raw "\n[DEBUG]   operator:";
            debug_print_str compound_op;

            if !is_variable_declared(ident_name) {
                if !ctx.is_axec {
                    mut err: string = str("Undeclared variable: ");
                    err = concat(err, ident_name);
                    enforce_raw(false, err.data);
                    return node;
                }
            }
            if !is_variable_mutable(ident_name) {
                mut err: string = str("Cannot assign to immutable variable: ");
                err = concat(err, ident_name);
                enforce_raw(false, format_error(ctx, err).data);
                return node;
            }

            consume(ctx);
            skip_whitespace(ctx);

            mut expr: string = str("");
            mut found_semicolon_compound: bool = false;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    consume(ctx);
                    found_semicolon_compound = true;
                    break;
                }
                
                if t.token_type == TokenType.VAL or t.token_type == TokenType.MUT {
                    break;
                }

                if t.token_type == TokenType.STR {
                    expr = concat(expr, str("\""));
                    expr = concat(expr, t.value);
                    expr = concat(expr, str("\" "));
                } elif t.token_type == TokenType.CHAR {
                    expr = concat(expr, str("'"));
                    expr = concat(expr, t.value);
                    expr = concat(expr, str("' "));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    // skip
                } else {
                    expr = concat(expr, t.value);
                    expr = concat(expr, str(" "));
                }
                consume(ctx);
            }
            
            if !found_semicolon_compound {
                mut err: string = format_error(ctx, str("Expected ';' after compound assignment"));
                enforce_raw(false, err.data);
                return node;
            }

            expr = expand_macros_in_expression(expr);
            scan_expression_for_addr(expr);
            scan_expression_for_c_calls(expr);
            scan_expression_for_usage(expr);
            
            node.node_type = str("Assignment");
            node.data.assignment.variable = ident_name;
            node.data.assignment.expression = strip(expr);
            node.data.assignment.operator = compound_op;
            mark_variable_mutated(ident_name);
            return node;
        }
        
        if next_token.token_type == TokenType.OPERATOR and equals_c(next_token.value, "=") {
            debug_print_raw "\n[DEBUG] parse_statement_helper: entering Assignment branch";
            debug_print_raw "\n[DEBUG]   ident_name:";
            debug_print_str ident_name;

            if !is_variable_declared(ident_name) {
                if !ctx.is_axec {
                    mut err: string = str("Undeclared variable: ");
                    err = concat(err, ident_name);
                    enforce_raw(false, format_error(ctx, err).data);
                    return node;
                }
            }
            if !is_variable_mutable(ident_name) {
                mut err: string = str("Cannot assign to immutable variable: ");
                err = concat(err, ident_name);
                enforce_raw(false, format_error(ctx, err).data);
                return node;
            }

            consume(ctx);
            skip_whitespace(ctx);

            mut expr: string = str("");
            mut found_semicolon_assign: bool = false;
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    debug_print_raw "\n[DEBUG]   reached end of tokens while collecting RHS";
                    break;
                }
                val t: Token = peek(ctx);
                if t.token_type == TokenType.SEMICOLON {
                    debug_print_raw "\n[DEBUG]   encountered ';' terminating RHS";
                    consume(ctx);
                    found_semicolon_assign = true;
                    break;
                }
                
                if t.token_type == TokenType.VAL or t.token_type == TokenType.MUT {
                    debug_print_raw "\n[DEBUG]   encountered new declaration, stopping RHS collection";
                    break;
                }

                // Per-token debug for RHS
                debug_print_raw "\n[DEBUG]   RHS token type:";
                debug_print_i32 t.token_type;
                debug_print_raw "\n[DEBUG]   RHS token value:";
                debug_print_str t.value;

                if t.token_type == TokenType.STR {
                    expr = concat(expr, str("\""));
                    expr = concat(expr, t.value);
                    expr = concat(expr, str("\" "));
                } elif t.token_type == TokenType.CHAR {
                    expr = concat(expr, str("'"));
                    expr = concat(expr, t.value);
                    expr = concat(expr, str("' "));
                } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                    // I dont give a shit
                } else {
                    if (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("and")) == 0)
                       or t.token_type == TokenType.AND {
                        expr = concat(expr, str("&&"));
                        expr = concat(expr, str(" "));
                    } elif (t.token_type == TokenType.IDENTIFIER and compare(t.value, str("or")) == 0)
                           or t.token_type == TokenType.OR {
                        expr = concat(expr, str("||"));
                        expr = concat(expr, str(" "));
                    } else {
                        expr = concat(expr, t.value);
                        expr = concat(expr, str(" "));
                    }
                }
                consume(ctx);
            }
            
            if !found_semicolon_assign {
                mut err: string = format_error(ctx, str("Expected ';' after assignment"));
                enforce_raw(false, err.data);
                return node;
            }

            debug_print_raw "\n[DEBUG]   final RHS expr:";
            debug_print_str expr;

            expr = expand_macros_in_expression(expr);

            mut trimmed_assign: string = strip(expr);
            val prefix_fix: string = str("_state = ");
            if compare(ident_name, str("fixed")) == 0 and has_prefix(trimmed_assign, prefix_fix) {
                ident_name = str("fixed_state");
                trimmed_assign = substring_se(trimmed_assign, str_len(prefix_fix), str_len(trimmed_assign));
                expr = trimmed_assign;
            }

            scan_expression_for_addr(expr);
            scan_expression_for_c_calls(expr);
            scan_expression_for_usage(expr);
            
            node.node_type = str("Assignment");
            node.data.assignment.variable = ident_name;
            node.data.assignment.expression = expr;
            node.data.assignment.operator = str("=");
            mark_variable_mutated(ident_name);
            return node;
        }
        
        // Handle: INCREMENT and DECREMENT: variable++ or variable--
        if next_token.token_type == TokenType.INCREMENT or next_token.token_type == TokenType.DECREMENT {
            mark_variable_mutated(ident_name);
            val is_inc: bool = next_token.token_type == TokenType.INCREMENT;
            consume(ctx);
            skip_whitespace(ctx);

            if !is_variable_declared(ident_name) {
                if !ctx.is_axec {
                    mut err: string = str("Undeclared variable: ");
                    err = concat(err, ident_name);
                    enforce_raw(false, format_error(ctx, err).data);
                    return node;
                }
            }
            if !is_variable_mutable(ident_name) {
                debug_print_raw "\n[DEBUG] Variable is not mutable:";
                debug_print_str ident_name;
                mut err: string = str("Cannot increment/decrement immutable variable: ");
                err = concat(err, ident_name);
                enforce_raw(false, format_error(ctx, err).data);
                return node;
            }
            
            if !expect(ctx, TokenType.SEMICOLON) {
                mut err: string = format_error(ctx, str("Expected ';' after increment/decrement"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            node.node_type = str("IncDec");
            node.data.inc_dec.variable = ident_name;
            node.data.inc_dec.is_increment = is_inc;
            return node;
        }
        
        // Function call without parentheses (Axe syntax sugar): e.g. println "hello"
        mut args_str_sugar: string = str("");
        mut found_semicolon_sugar: bool = false;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.SEMICOLON {
                consume(ctx);
                found_semicolon_sugar = true;
                break;
            }
            
            if t.token_type == TokenType.VAL or t.token_type == TokenType.MUT {
                break;
            }

            if t.token_type == TokenType.STR {
                args_str_sugar = concat(args_str_sugar, str("\""));
                args_str_sugar = concat(args_str_sugar, t.value);
                args_str_sugar = concat(args_str_sugar, str("\""));
            } elif t.token_type == TokenType.CHAR {
                args_str_sugar = concat(args_str_sugar, str("'"));
                args_str_sugar = concat(args_str_sugar, t.value);
                args_str_sugar = concat(args_str_sugar, str("'"));
            } elif t.token_type == TokenType.WHITESPACE or t.token_type == TokenType.NEWLINE {
                args_str_sugar = concat(args_str_sugar, str(" "));
            } else {
                args_str_sugar = concat(args_str_sugar, t.value);
            }
            consume(ctx);
        }
        
        if !found_semicolon_sugar {
            mut err: string = format_error(ctx, str("Expected ';' after function call"));
            enforce_raw(false, err.data);
            return node;
        }

        node.node_type = str("FunctionCall");
        node.data.func_call.function_name = ident_name;

        mut sugar_args_list: list(string);
        val trimmed_sugar: string = strip(args_str_sugar);
        if str_len(trimmed_sugar) > 0 {
            append(sugar_args_list, trimmed_sugar);
        }

        scan_expression_for_usage(trimmed_sugar);

        unsafe {
            val list_size_s: usize = C.sizeof(list(string));
            mut heap_list_s: ref list(string) = cast[ref list(string)](C.malloc(list_size_s));
            if heap_list_s != nil {
                C.memcpy(heap_list_s, addr(sugar_args_list), list_size_s);
                node.data.func_call.args = heap_list_s;
            }
        }

        return node;
    }
    
    // Handle PLATFORM
    if token_type == TokenType.PLATFORM {
        consume(ctx);
        skip_whitespace(ctx);

        if !expect(ctx, TokenType.IDENTIFIER) {
            mut err: string = format_error(ctx, str("Expected platform name after 'platform'"));
            enforce_raw(false, err.data);
            return node;
        }
        val platform_token: Token = consume(ctx);
        val platform_name: string = platform_token.value;
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after platform name"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        push_scope();
        
        node.node_type = str("Platform");
        node.data.platform_node.platform_name = platform_name;
        
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            skip_whitespace(ctx);
            val t: Token = peek(ctx);
            if t.token_type == TokenType.RBRACE {
                consume(ctx);
                break;
            }
            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                add_child_to_ast(addr(node), stmt);
            }
        }
        
        pop_scope();
        
        return node;
    }
    
    // Handle PARALLEL
    if token_type == TokenType.PARALLEL {
        consume(ctx);
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.FOR) {
            consume(ctx);
            skip_whitespace(ctx);
            
            mut var_name: string = str("");
            mut var_type: string = str("int");
            mut is_mutable: bool = false;
            mut init_value: string = str("");
            mut to_value: string = str("");
            mut condition: string = str("");
            mut increment: string = str("");
            mut reduction_clauses: list(string);
            
            if expect(ctx, TokenType.MUT) {
                is_mutable = true;
                consume(ctx);
                skip_whitespace(ctx);
            } elif expect(ctx, TokenType.VAL) {
                consume(ctx);
                skip_whitespace(ctx);
            }
            
            if expect(ctx, TokenType.IDENTIFIER) {
                val var_tok: Token = consume(ctx);
                var_name = var_tok.value;
                skip_whitespace(ctx);
            }
            
            if expect(ctx, TokenType.COLON) {
                consume(ctx);
                skip_whitespace(ctx);
                if expect(ctx, TokenType.IDENTIFIER) {
                    val type_tok: Token = consume(ctx);
                    var_type = type_tok.value;
                    skip_whitespace(ctx);
                }
            }
            
            if expect(ctx, TokenType.OPERATOR) {
                val op_tok: Token = peek(ctx);
                if equals_c(op_tok.value, "=") {
                    consume(ctx);
                    skip_whitespace(ctx);
                    loop {
                        if ctx.pos >= len(ctx.tokens) {
                            break;
                        }
                        val t: Token = peek(ctx);
                        if t.token_type == TokenType.TO or t.token_type == TokenType.LBRACE {
                            break;
                        }
                        if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                            init_value = concat(init_value, t.value);
                        }
                        consume(ctx);
                    }
                }
            }
            
            skip_whitespace(ctx);
            
            if expect(ctx, TokenType.TO) {
                consume(ctx);
                skip_whitespace(ctx);
                
                loop {
                    if ctx.pos >= len(ctx.tokens) {
                        break;
                    }
                    val t: Token = peek(ctx);
                    if t.token_type == TokenType.LBRACE or t.token_type == TokenType.REDUCE {
                        break;
                    }
                    if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                        to_value = concat(to_value, t.value);
                    }
                    consume(ctx);
                }
                
                if expect(ctx, TokenType.REDUCE) {
                    consume(ctx);
                    skip_whitespace(ctx);
                    
                    if expect(ctx, TokenType.LPAREN) {
                        consume(ctx);
                        
                        mut clause: string = str("");
                        loop {
                            if ctx.pos >= len(ctx.tokens) {
                                break;
                            }
                            val t: Token = peek(ctx);
                            if t.token_type == TokenType.RPAREN {
                                if str_len(strip(clause)) > 0 {
                                    append(reduction_clauses, strip(clause));
                                }
                                consume(ctx);
                                break;
                            }
                            if t.token_type == TokenType.COMMA {
                                if str_len(strip(clause)) > 0 {
                                    append(reduction_clauses, strip(clause));
                                }
                                clause = str("");
                                consume(ctx);
                            } else {
                                if t.token_type != TokenType.WHITESPACE {
                                    clause = concat(clause, t.value);
                                }
                                consume(ctx);
                            }
                        }
                    }
                }
                
                skip_whitespace(ctx);
                
                condition = concat(var_name, str("<"));
                condition = concat(condition, to_value);
                increment = concat(var_name, str("++"));
            }
            
            if !expect(ctx, TokenType.LBRACE) {
                mut err: string = format_error(ctx, str("Expected '{' after parallel for header"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            push_scope();
            
            mut init_str: string = str("");
            if str_len(var_name) > 0 {
                if equals_c(var_type, "int") or equals_c(var_type, "i32") {
                    init_str = str("int32_t ");
                } else {
                    init_str = concat(var_type, str(" "));
                }
                init_str = concat(init_str, var_name);
                if str_len(init_value) > 0 {
                    init_str = concat_c(init_str, " = ");
                    init_str = concat(init_str, init_value);
                }
            }
            
            mut body: list(ASTNode);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                    consume(ctx);
                    break;
                }
                val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt.node_type) > 0 {
                    append(body, stmt);
                }
            }
            
            pop_scope();
            
            node.node_type = str("ParallelFor");
            node.data.parallel_for.initialization = init_str;
            node.data.parallel_for.condition = condition;
            node.data.parallel_for.increment = increment;
            
            unsafe {
                val list_size: usize = C.sizeof(list(ASTNode));
                val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
                if heap_list != nil {
                    C.memcpy(heap_list, addr(body), list_size);
                    node.children = heap_list;
                }
                
                val list_size_str: usize = C.sizeof(list(string));
                val heap_clauses: ref list(string) = cast[ref list(string)](C.malloc(list_size_str));
                if heap_clauses != nil {
                    C.memcpy(heap_clauses, addr(reduction_clauses), list_size_str);
                    node.data.parallel_for.reduction_clauses = heap_clauses;
                }
            }
            
            return node;
        }
        
        // Handle parallel local(...)
        if expect(ctx, TokenType.LOCAL) {
            consume(ctx);
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.LPAREN) {
                mut err: string = format_error(ctx, str("Expected '(' after 'parallel local'"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            mut private_vars: list(string);
            mut private_types: list(string);
            mut is_mutable: list(bool);
            
            loop {
                skip_whitespace(ctx);
                
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                
                if expect(ctx, TokenType.RPAREN) {
                    consume(ctx);
                    break;
                }
                
                mut is_mut: bool = false;
                if expect(ctx, TokenType.MUT) {
                    is_mut = true;
                    consume(ctx);
                    skip_whitespace(ctx);
                } elif expect(ctx, TokenType.VAL) {
                    consume(ctx);
                    skip_whitespace(ctx);
                }
                
                if !expect(ctx, TokenType.IDENTIFIER) {
                    mut err: string = format_error(ctx, str("Expected variable name in parallel local"));
                    enforce_raw(false, err.data);
                    return node;
                }

                val var_tok: Token = consume(ctx);
                val var_name: string = var_tok.value;
                skip_whitespace(ctx);
                
                if !expect(ctx, TokenType.COLON) {
                    mut err: string = format_error(ctx, str("Expected ':' after variable name in parallel local"));
                    enforce_raw(false, err.data);
                    return node;
                }

                consume(ctx);
                skip_whitespace(ctx);
                
                mut type_name: string = str("");
                mut ref_depth: i32 = 0;
                
                loop {
                    if !expect(ctx, TokenType.REF) {
                        break;
                    }
                    ref_depth = ref_depth + 1;
                    consume(ctx);
                    skip_whitespace(ctx);
                }
                
                if expect(ctx, TokenType.IDENTIFIER) {
                    val type_tok: Token = consume(ctx);
                    type_name = type_tok.value;
                    skip_whitespace(ctx);
                }
                
                if ref_depth > 0 {
                    type_name = concat(str("ref "), type_name);
                }
                
                append(private_vars, var_name);
                append(private_types, type_name);
                append(is_mutable, is_mut);
                
                register_variable(var_name, is_mut, current_line(ctx), ctx.filename);
                
                skip_whitespace(ctx);
                if expect(ctx, TokenType.COMMA) {
                    consume(ctx);
                }
            }
            
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.LBRACE) {
                mut err: string = format_error(ctx, str("Expected '{' after parallel local declaration"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            mut body: list(ASTNode);
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                skip_whitespace(ctx);
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                    consume(ctx);
                    break;
                }
                val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
                if str_len(stmt.node_type) > 0 {
                    append(body, stmt);
                }
            }
            
            node.node_type = str("ParallelLocal");
            
            unsafe {
                val list_size: usize = C.sizeof(list(ASTNode));
                val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
                if heap_list != nil {
                    C.memcpy(heap_list, addr(body), list_size);
                    node.children = heap_list;
                }
                
                val list_size_str: usize = C.sizeof(list(string));
                val heap_vars: ref list(string) = cast[ref list(string)](C.malloc(list_size_str));
                if heap_vars != nil {
                    C.memcpy(heap_vars, addr(private_vars), list_size_str);
                    node.data.parallel_local.private_vars = heap_vars;
                }
                
                val heap_types: ref list(string) = cast[ref list(string)](C.malloc(list_size_str));
                if heap_types != nil {
                    C.memcpy(heap_types, addr(private_types), list_size_str);
                    node.data.parallel_local.private_types = heap_types;
                }
                
                val list_size_bool: usize = C.sizeof(list(bool));
                val heap_mutable: ref list(bool) = cast[ref list(bool)](C.malloc(list_size_bool));
                if heap_mutable != nil {
                    C.memcpy(heap_mutable, addr(is_mutable), list_size_bool);
                    node.data.parallel_local.is_mutable = heap_mutable;
                }
            }
            
            return node;
        }
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after 'parallel'"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        mut body: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx);
                break;
            }
            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }
        
        node.node_type = str("Parallel");
        
        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(body), list_size);
                node.children = heap_list;
            }
        }
        
        return node;
    }
    
    if token_type == TokenType.SINGLE {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after 'single'"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        mut body: list(ASTNode);
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx);
                break;
            }
            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }
        
        node.node_type = str("Single");
        
        unsafe {
            val list_size: usize = C.sizeof(list(ASTNode));
            val heap_list: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(body), list_size);
                node.children = heap_list;
            }
        }
        
        return node;
    }
    
    if token_type == TokenType.UNSAFE {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after 'unsafe'"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // Skip '{'
        
        mut body: list(ASTNode);
        
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            if ctx.tokens.data[ctx.pos].token_type == TokenType.RBRACE {
                consume(ctx); // Skip '}'
                break;
            }
            
            val stmt: ASTNode = parse_statement_helper(ctx, addr(ctx.current_scope));
            if str_len(stmt.node_type) > 0 {
                append(body, stmt);
            }
        }
        
        node.node_type = str("Unsafe");

        unsafe {
            val list_size_ast: usize = C.sizeof(list(ASTNode));
            mut heap_body: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(list_size_ast));
            if heap_body != nil {
                C.memcpy(heap_body, addr(body), list_size_ast);
                node.data.unsafe_node.body = heap_body;
            }
        }
        return node;
    }
    
    // Handle RAW (only in .axec files)
    if token_type == TokenType.RAW {
        if !ctx.is_axec {
            mut err: string = format_error(ctx, str("Raw C blocks are only allowed in .axec files"));
            enforce_raw(false, err.data);
            return node;
        }

        // Mark that this function contains a raw block
        g_function_has_raw_block = true;

        consume(ctx); // Skip 'raw'
        skip_whitespace(ctx);

        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after 'raw'"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // '{'

        mut raw_code: string = str("");
        mut depth: i32 = 1;

        loop {
            if ctx.pos >= len(ctx.tokens) {
                mut err: string = format_error(ctx, str("Unexpected end of tokens in raw block"));
                enforce_raw(false, err.data);
                return node;
            }

            val t: Token = peek(ctx);

            if t.token_type == TokenType.LBRACE {
                raw_code = concat(raw_code, str("{"));
                depth = depth + 1;
                consume(ctx);
                continue;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    break;
                } else {
                    raw_code = concat(raw_code, str("}"));
                    consume(ctx);
                    continue;
                }
            }

            if t.token_type == TokenType.NEWLINE {
                raw_code = concat(raw_code, str("\n"));
            } elif t.token_type == TokenType.STR {
                raw_code = concat(raw_code, str("\""));
                raw_code = concat(raw_code, t.value);
                raw_code = concat(raw_code, str("\""));
            } elif t.token_type == TokenType.CHAR {
                raw_code = concat(raw_code, str("'"));
                raw_code = concat(raw_code, t.value);
                raw_code = concat(raw_code, str("'"));
            } else {
                raw_code = concat(raw_code, t.value);
            }

            consume(ctx);
        }

        if !expect(ctx, TokenType.RBRACE) {
            mut err: string = format_error(ctx, str("Expected '}' after raw block body"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // '}'

        node.node_type = str("RawC");
        node.data.raw_c.code = raw_code;
        return node;
    }
    
    // Handle OPAQUE (only in .axec files)
    if token_type == TokenType.OPAQUE {
        consume(ctx); // Skip 'opaque'
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after 'opaque'"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        // Collect opaque type names
        mut type_names: list(string);
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.RBRACE {
                consume(ctx);
                break;
            }
            if t.token_type == TokenType.IDENTIFIER {
                append(type_names, t.value);
                consume(ctx);
            } elif t.token_type == TokenType.SEMICOLON or t.token_type == TokenType.COMMA {
                consume(ctx);
            } else {
                consume(ctx);
            }
        }
        
        skip_whitespace(ctx);
        
        node.node_type = str("Opaque");
        
        unsafe {
            val list_size: usize = C.sizeof(list(string));
            mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(type_names), list_size);
                node.data.opaque_node.type_names = heap_list;
            }
        }
        
        return node;
    }
    
    if token_type == TokenType.FOREIGN {
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            mut err: string = format_error(ctx, str("Expected '{' after 'foreign'"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        mut type_names: list(string);
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.RBRACE {
                consume(ctx);
                break;
            }
            if t.token_type == TokenType.IDENTIFIER {
                append(type_names, t.value);
                consume(ctx);
            } elif t.token_type == TokenType.SEMICOLON or t.token_type == TokenType.COMMA {
                consume(ctx);
            } else {
                consume(ctx);
            }
        }
        
        skip_whitespace(ctx);
        
        node.node_type = str("Foreign");
        
        unsafe {
            val list_size: usize = C.sizeof(list(string));
            mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(type_names), list_size);
                node.data.foreign_node.type_names = heap_list;
            }
        }
        
        return node;
    }
    
    // Handle DEF inside platform blocks and globally
    if token_type == TokenType.DEF {
        consume(ctx); // Skip 'def'
        val func_node: ASTNode = parse_function(ctx);
        return func_node;
    }
    
    // Handle EXTERN (only in .axec files)
    if token_type == TokenType.EXTERN {
        consume(ctx); // Skip 'extern'
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.DEF) {
            mut err: string = format_error(ctx, str("Expected 'def' after 'extern'"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        // Get function name
        if !expect(ctx, TokenType.IDENTIFIER) {
            mut err: string = format_error(ctx, str("Expected function name after 'extern def'"));
            enforce_raw(false, err.data);
            return node;
        }
        val func_name_token: Token = consume(ctx);
        val func_name: string = func_name_token.value;
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LPAREN) {
            mut err: string = format_error(ctx, str("Expected '(' after extern function name"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // Skip '('
        
        mut extern_params: list(string);
        loop {
            skip_whitespace(ctx);
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.RPAREN {
                break;
            }
            
            mut param_str: string = str("");
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val pt: Token = peek(ctx);
                if pt.token_type == TokenType.COMMA or pt.token_type == TokenType.RPAREN {
                    break;
                }
                if pt.token_type != TokenType.WHITESPACE and pt.token_type != TokenType.NEWLINE {
                    param_str = concat(param_str, pt.value);
                } else {
                    param_str = concat(param_str, str(" "));
                }
                consume(ctx);
            }
            
            val trimmed_param: string = strip(param_str);
            if str_len(trimmed_param) > 0 {
                append(extern_params, trimmed_param);
            }
            
            if ctx.pos < len(ctx.tokens) and peek(ctx).token_type == TokenType.COMMA {
                consume(ctx); // Skip comma
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            mut err: string = format_error(ctx, str("Expected ')' after extern parameters"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // Skip ')'
        skip_whitespace(ctx);
        
        // Parse return type if present
        mut extern_return_type: string = str("");
        if ctx.pos < len(ctx.tokens) and peek(ctx).token_type == TokenType.COLON {
            consume(ctx); // Skip ':'
            skip_whitespace(ctx);
            
            // Parse return type until semicolon
            loop {
                if ctx.pos >= len(ctx.tokens) {
                    break;
                }
                val rt: Token = peek(ctx);
                if rt.token_type == TokenType.SEMICOLON {
                    break;
                }
                if rt.token_type != TokenType.WHITESPACE and rt.token_type != TokenType.NEWLINE {
                    extern_return_type = concat(extern_return_type, rt.value);
                } elif str_len(extern_return_type) > 0 {
                    extern_return_type = concat(extern_return_type, str(" "));
                }
                consume(ctx);
            }
            extern_return_type = strip(extern_return_type);
        }
        
        skip_whitespace(ctx);
        if !expect(ctx, TokenType.SEMICOLON) {
            mut err: string = format_error(ctx, str("Expected ';' after extern declaration"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx); // Skip ';'
        
        node.node_type = str("Extern");
        node.data.extern_node.function_name = func_name;
        
        if len(extern_params) > 0 {
            unsafe {
                val params_size: usize = C.sizeof(list(string));
                val heap_params: ref list(string) = cast[ref list(string)](C.malloc(params_size));
                if heap_params != nil {
                    C.memcpy(heap_params, addr(extern_params), params_size);
                    node.data.extern_node.params = heap_params;
                }
            }
        }
        
        node.data.extern_node.return_type = extern_return_type;
        return node;
    }
    
    if token_type == TokenType.USE {
        consume(ctx); // Skip 'use'
        skip_whitespace(ctx);
        
        if expect(ctx, TokenType.EXTERNAL) {
            consume(ctx);
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.LPAREN) {
                mut err: string = format_error(ctx, str("Expected '(' after 'use external'"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            if !expect(ctx, TokenType.STR) {
                mut err: string = format_error(ctx, str("Expected string literal for header file"));
                enforce_raw(false, err.data);
                return node;
            }
            val header_token: Token = consume(ctx);
            val header_file: string = header_token.value;
            
            if !expect(ctx, TokenType.RPAREN) {
                mut err: string = format_error(ctx, str("Expected ')' after header file"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            skip_whitespace(ctx);
            
            if !expect(ctx, TokenType.SEMICOLON) {
                mut err: string = format_error(ctx, str("Expected ';' after external import"));
                enforce_raw(false, err.data);
                return node;
            }
            consume(ctx);
            
            node.node_type = str("ExternalImport");
            node.data.external_import.header_file = header_file;
            return node;
        }
        
        mut module_name: string = str("");
        
        loop {
            if expect(ctx, TokenType.DOT) {
                consume(ctx);
                
                if expect(ctx, TokenType.DOT) {
                    consume(ctx);
                    if expect(ctx, TokenType.SLASH) {
                        consume(ctx);
                        module_name = concat(module_name, str("../"));
                        continue;
                    }
                } elif expect(ctx, TokenType.SLASH) {
                    consume(ctx);
                    module_name = concat(module_name, str("./"));
                    continue;
                }
            }
            break;
        }
        
        // Parse module path (e.g., std.io or std/maps)
        if !expect(ctx, TokenType.IDENTIFIER) {
            mut err: string = format_error(ctx, str("Expected module name after 'use'"));
            enforce_raw(false, err.data);
            return node;
        }
        val first_ident: Token = consume(ctx);
        module_name = concat(module_name, first_ident.value);
        
        loop {
            skip_whitespace(ctx);
            if expect(ctx, TokenType.DOT) {
                consume(ctx);
                module_name = concat(module_name, str("."));
                
                if !expect(ctx, TokenType.IDENTIFIER) {
                    mut err: string = format_error(ctx, str("Expected identifier after '.' in module path"));
                    enforce_raw(false, err.data);
                    return node;
                }
                val ident: Token = consume(ctx);
                module_name = concat(module_name, ident.value);
            } elif expect(ctx, TokenType.SLASH) {
                consume(ctx);
                module_name = concat(module_name, str("/"));
                
                if !expect(ctx, TokenType.IDENTIFIER) {
                    mut err: string = format_error(ctx, str("Expected identifier after '/' in module path"));
                    enforce_raw(false, err.data);
                    return node;
                }
                val ident: Token = consume(ctx);
                module_name = concat(module_name, ident.value);
            } elif expect(ctx, TokenType.IDENTIFIER) {
                val ident2: Token = peek(ctx);
                if str_len(ident2.value) > 0 and get_char(ident2.value, 0) == '_' {
                    consume(ctx);
                    module_name = concat(module_name, ident2.value);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        
        skip_whitespace(ctx);
        
        // Check for import all syntax: use module;
        if expect(ctx, TokenType.SEMICOLON) {
            consume(ctx);
            node.node_type = str("Use");
            node.data.use_node.module_name = module_name;
            node.data.use_node.import_all = true;
            return node;
        }
        
        // Parse selective imports: use module (item1, item2);
        if !expect(ctx, TokenType.LPAREN) {
            mut err: string = format_error(ctx, str("Expected '(' or ';' after module name"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        
        mut imports: list(string);
        loop {
            skip_whitespace(ctx);
            if expect(ctx, TokenType.RPAREN) {
                break;
            }
            
            if expect(ctx, TokenType.IDENTIFIER) {
                val import_token: Token = consume(ctx);
                append(imports, import_token.value);
            } elif expect(ctx, TokenType.COMMA) {
                consume(ctx);
            } else {
                mut err: string = format_error(ctx, str("Expected identifier or ',' in use statement"));
                enforce_raw(false, err.data);
                return node;
            }
        }
        
        if !expect(ctx, TokenType.RPAREN) {
            mut err: string = format_error(ctx, str("Expected ')' after imports"));
            enforce_raw(false, err.data);
            return node;
        }
        consume(ctx);
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.SEMICOLON) {
            enforce_raw(false, "Expected ';' after use statement");
            return node;
        }
        consume(ctx);
        
        node.node_type = str("Use");
        node.data.use_node.module_name = module_name;
        
        // Heap-allocate the imports list so it persists after function returns
        // The list struct contains data inline, so we just copy the whole struct
        unsafe {
            val list_size: usize = C.sizeof(list(string));
            mut heap_list: ref list(string) = cast[ref list(string)](C.malloc(list_size));
            if heap_list != nil {
                C.memcpy(heap_list, addr(imports), list_size);
                node.data.use_node.imports = heap_list;
            }
        }
        
        node.data.use_node.import_all = false;
        return node;
    }
    
    // Handle CASE (within switch statements)
    if token_type == TokenType.CASE {
        debug_print_raw "\n[DEBUG] Parsing CASE statement";
        consume(ctx); // Skip 'case'
        debug_print_raw "\n[DEBUG] Consumed 'case' token";
        skip_whitespace(ctx);
        debug_print_raw "\n[DEBUG] Skipped whitespace after 'case'";
        
        // Collect case value until '{'
        mut case_value: string = str("");
        debug_print_raw "\n[DEBUG] Starting to collect case value";
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                break;
            }
            if t.token_type != TokenType.WHITESPACE and t.token_type != TokenType.NEWLINE {
                case_value = concat(case_value, t.value);
                case_value = concat(case_value, str(" "));
            }
            consume(ctx);
        }
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "Expected '{' after case value");
            return node;
        }
        consume(ctx);
        
        // Skip case body
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Case");
        node.data.case_node.value = case_value;
        node.data.case_node.is_default = false;
        return node;
    }
    
    // Handle DEFAULT (within switch statements)
    if token_type == TokenType.DEFAULT {
        consume(ctx); // Skip 'default'
        skip_whitespace(ctx);
        
        if !expect(ctx, TokenType.LBRACE) {
            enforce_raw(false, "Expected '{' after default");
            return node;
        }
        consume(ctx);
        
        // Skip default body
        mut depth: i32 = 1;
        loop {
            if ctx.pos >= len(ctx.tokens) {
                break;
            }
            val t: Token = peek(ctx);
            if t.token_type == TokenType.LBRACE {
                depth = depth + 1;
            } elif t.token_type == TokenType.RBRACE {
                depth = depth - 1;
                if depth == 0 {
                    consume(ctx);
                    break;
                }
            }
            consume(ctx);
        }
        
        node.node_type = str("Case");
        node.data.case_node.value = str("");
        node.data.case_node.is_default = true;
        return node;
    }
    
    // For now, skip unknown tokens
    consume(ctx);
    return node;
}

test {
    initialize_all();
    
    println "\nTest 1: parse_type with simple type";
    mut tokens1: list(Token) = lex(str("i32"));
    mut ctx1: ParserContext;
    ctx1.tokens = addr(tokens1);
    ctx1.pos = 0;
    mut type1: string = parse_type(addr(ctx1));
    assert equals_c(type1, "i32"), "Expected i32.";

    println "\nTest 2: skip_whitespace";
    mut tokens2: list(Token) = lex(str("   \n  \t  i32"));
    mut ctx2: ParserContext;
    ctx2.tokens = addr(tokens2);
    ctx2.pos = 0;
    mut pos_before: i32 = ctx2.pos;
    skip_whitespace(addr(ctx2));
    assert ctx2.pos > pos_before, "Expected position to advance after skipping whitespace";

    println "\nTest 3: peek and consume";
    mut tokens3: list(Token) = lex(str("identifier"));
    mut ctx3: ParserContext;
    ctx3.tokens = addr(tokens3);
    ctx3.pos = 0;
    mut peeked: Token = peek(addr(ctx3));
    mut pos_after_peek: i32 = ctx3.pos;
    mut consumed: Token = consume(addr(ctx3));
    mut pos_after_consume: i32 = ctx3.pos;
    assert pos_after_peek == 0 and pos_after_consume == 1, "Expected position to advance after consume";

    println "\nTest 4: expect";
    mut tokens4: list(Token) = lex(str("def function_name"));
    mut ctx4: ParserContext;
    ctx4.tokens = addr(tokens4);
    ctx4.pos = 0;
    assert expect(addr(ctx4), TokenType.DEF), "Expected to find 'def' token";

    println "\nTest 5: parse_type with ref type";
    mut tokens5: list(Token) = lex(str("ref i32"));
    mut ctx5: ParserContext;
    ctx5.tokens = addr(tokens5);
    ctx5.pos = 0;
    mut type5: string = parse_type(addr(ctx5));
    assert str_len(type5) > 0, "Expected non-empty type string for 'ref i32'";
    assert str_contains_c(type5, "i32"), "Expected type to contain 'i32'";

    println "\nTest 6: parse_type with list type";
    mut tokens6: list(Token) = lex(str("list(Token)"));
    mut ctx6: ParserContext;
    ctx6.tokens = addr(tokens6);
    ctx6.pos = 0;
    mut type6: string = parse_type(addr(ctx6));
    assert str_len(type6) > 0, "Expected non-empty type for list(Token)";
    assert str_contains_c(type6, "Token"), "Expected type to contain 'Token'";

    println "\nTest 7: parse simple function with parse_function";
    mut tokens7: list(Token) = lex(str("foo(): i32 { return 42; }"));
    mut ctx7: ParserContext;
    ctx7.tokens = addr(tokens7);
    ctx7.pos = 0;
    mut func7: ASTNode = parse_function(addr(ctx7));
    assert equals_c(func7.node_type, "Function"), "Expected Function node type";

    println "\nTest 8: parse function with parameters";
    mut tokens8: list(Token) = lex(str("add(a: i32): i32 { return a; }"));
    mut ctx8: ParserContext;
    ctx8.tokens = addr(tokens8);
    ctx8.pos = 0;
    mut func8: ASTNode = parse_function(addr(ctx8));
    assert equals_c(func8.node_type, "Function"), "Expected Function node for function with params";

    println "\nTest 9: parse full program with def main";
    mut tokens9: list(Token) = lex(str("def main() { }"));
    mut empty_module: string = str("");
    mut ast9: ASTNode = parse(addr(tokens9), false, false, empty_module, str("test9"));
    assert equals_c(ast9.node_type, "Program"), "Expected Program AST node";

    println "\nTest 10: parse program with model definition";
    mut tokens10: list(Token) = lex(str("model Point { x: i32 } def main() { }"));
    mut ast10: ASTNode = parse(addr(tokens10), false, false, str(""), str("test10"));
    assert equals_c(ast10.node_type, "Program"), "Expected Program node with model";

    println "\nTest 11: parse program with enum definition";
    mut tokens11: list(Token) = lex(str("enum Color { Red } def main() { }"));
    mut ast11: ASTNode = parse(addr(tokens11), false, false, str(""), str("test11"));
    assert equals_c(ast11.node_type, "Program"), "Expected Program node with enum";

    println "\nTest 12: parse program with use statement";
    mut tokens12: list(Token) = lex(str("use std.io; def main() { }"));
    mut ast12: ASTNode = parse(addr(tokens12), false, false, str(""), str("test12"));
    assert equals_c(ast12.node_type, "Program"), "Expected Program node with use statement";

    println "\nTest 13: parse program with global val";
    mut tokens13: list(Token) = lex(str("val CONSTANT: i32 = 42; def main() { }"));
    mut ast13: ASTNode = parse(addr(tokens13), false, false, str(""), str("test13"));
    assert equals_c(ast13.node_type, "Program"), "Expected Program node with global val";

    println "\nTest 14: parse program with mut val";
    mut tokens14: list(Token) = lex(str("mut val counter: i32 = 0; def main() { }"));
    mut ast14: ASTNode = parse(addr(tokens14), false, false, str(""), str("test14"));
    assert equals_c(ast14.node_type, "Program"), "Expected Program node with mut val";

    println "\nTest 15: parse program with pub function";
    mut tokens15: list(Token) = lex(str("pub def helper() { } def main() { }"));
    mut ast15: ASTNode = parse(addr(tokens15), false, false, str(""), str("test15"));
    assert equals_c(ast15.node_type, "Program"), "Expected Program node with pub function";

    println "\nTest 16: parse empty test block";
    mut tokens16: list(Token) = lex(str("test { }"));
    mut ast16: ASTNode = parse(addr(tokens16), false, false, str(""), str("test16"));
    assert equals_c(ast16.node_type, "Program"), "Expected Program node with test block";

    println "\nTest 17: parse_type with pointer syntax";
    mut tokens17: list(Token) = lex(str("i32*"));
    mut ctx17: ParserContext;
    ctx17.tokens = addr(tokens17);
    ctx17.pos = 0;
    mut type17: string = parse_type(addr(ctx17));
    assert str_len(type17) > 0, "Expected non-empty type for i32*";
    assert str_contains_c(type17, "i32"), "Expected type to contain 'i32'";

    println "\nTest 18: parse multiple functions";
    mut tokens18: list(Token) = lex(str("def foo() { } def bar() { } def main() { }"));
    mut ast18: ASTNode = parse(addr(tokens18), false, false, str(""), str("test18"));
    assert equals_c(ast18.node_type, "Program"), "Expected Program node with multiple functions";

    println "\nTest 19: parse_statement_helper with break";
    mut tokens19: list(Token) = lex(str("break;"));
    mut ctx19: ParserContext;
    ctx19.tokens = addr(tokens19);
    ctx19.pos = 0;
    ctx19.is_axec = false;
    ctx19.check_entry_point = false;
    ctx19.current_module = str("");
    val stmt19: ASTNode = parse_statement_helper(addr(ctx19), addr(ctx19.current_scope));
    assert equals_c(stmt19.node_type, "Break"), "Expected Break node";

    println "\nTest 20: parse_statement_helper with return";
    mut tokens20: list(Token) = lex(str("return 42;"));
    mut ctx20: ParserContext;
    ctx20.tokens = addr(tokens20);
    ctx20.pos = 0;
    ctx20.is_axec = false;
    val stmt20: ASTNode = parse_statement_helper(addr(ctx20), addr(ctx20.current_scope));
    assert equals_c(stmt20.node_type, "Return"), "Expected Return node";
    assert str_contains_c(stmt20.data.return_node.expression, "42"), "Expected return expression to contain '42'";

    println "\nTest 21: parse_statement_helper with assert";
    mut tokens21: list(Token) = lex(str("assert x > 0, \"x must be positive\";"));
    mut ctx21: ParserContext;
    ctx21.tokens = addr(tokens21);
    ctx21.pos = 0;
    ctx21.is_axec = false;
    val stmt21: ASTNode = parse_statement_helper(addr(ctx21), addr(ctx21.current_scope));
    assert equals_c(stmt21.node_type, "Assert"), "Expected Assert node";
    assert str_len(stmt21.data.assert_node.condition) > 0, "Expected assert condition";
    assert str_len(stmt21.data.assert_node.message) > 0, "Expected assert message";

    println "\nTest 22: parse_statement_helper with unsafe block";
    mut tokens22: list(Token) = lex(str("unsafe { }"));
    mut ctx22: ParserContext;
    ctx22.tokens = addr(tokens22);
    ctx22.pos = 0;
    ctx22.is_axec = false;
    val stmt22: ASTNode = parse_statement_helper(addr(ctx22), addr(ctx22.current_scope));
    assert equals_c(stmt22.node_type, "Unsafe"), "Expected Unsafe node";

    println "\nTest 23: parse_statement_helper with if-elif-else";
    mut tokens23: list(Token) = lex(str("if x > 0 { println x; } elif x < 0 { println x; } else { println x; }"));
    mut ctx23: ParserContext;
    ctx23.tokens = addr(tokens23);
    ctx23.pos = 0;
    ctx23.is_axec = false;
    val stmt23: ASTNode = parse_statement_helper(addr(ctx23), addr(ctx23.current_scope));
    assert equals_c(stmt23.node_type, "If"), "Expected If node with elif and else";

    println "\nTest 24: parse_statement_helper with use statement";
    mut tokens24: list(Token) = lex(str("use std.io;"));
    mut ctx24: ParserContext;
    ctx24.tokens = addr(tokens24);
    ctx24.pos = 0;
    ctx24.is_axec = false;
    val stmt24: ASTNode = parse_statement_helper(addr(ctx24), addr(ctx24.current_scope));
    assert equals_c(stmt24.node_type, "Use"), "Expected Use node";
    assert stmt24.data.use_node.import_all == true, "Expected import_all to be true";

    println "\nTest 25: parse_statement_helper with use selective imports";
    mut tokens25: list(Token) = lex(str("use std.maps (StringIntMap, StringStringMap);"));
    mut ctx25: ParserContext;
    ctx25.tokens = addr(tokens25);
    ctx25.pos = 0;
    ctx25.is_axec = false;
    val stmt25: ASTNode = parse_statement_helper(addr(ctx25), addr(ctx25.current_scope));
    assert equals_c(stmt25.node_type, "Use"), "Expected Use node with selective imports";
    assert stmt25.data.use_node.import_all == false, "Expected import_all to be false";

    println "\nTest 26: parse_statement_helper with case";
    mut tokens26: list(Token) = lex(str("case 1 { println \"one\"; }"));
    mut ctx26: ParserContext;
    ctx26.tokens = addr(tokens26);
    ctx26.pos = 0;
    ctx26.is_axec = false;
    val stmt26: ASTNode = parse_statement_helper(addr(ctx26), addr(ctx26.current_scope));
    assert equals_c(stmt26.node_type, "Case"), "Expected Case node";
    assert stmt26.data.case_node.is_default == false, "Expected non-default case";

    println "\nTest 27: parse_statement_helper with default";
    mut tokens27: list(Token) = lex(str("default { println \"other\"; }"));
    mut ctx27: ParserContext;
    ctx27.tokens = addr(tokens27);
    ctx27.pos = 0;
    ctx27.is_axec = false;
    val stmt27: ASTNode = parse_statement_helper(addr(ctx27), addr(ctx27.current_scope));
    assert equals_c(stmt27.node_type, "Case"), "Expected Case node for default";
    assert stmt27.data.case_node.is_default == true, "Expected default case";

    println "\nTest 28: parse_statement_helper with member access assignment";
    mut tokens28: list(Token) = lex(str("obj.field = 42;"));
    mut ctx28: ParserContext;
    ctx28.tokens = addr(tokens28);
    ctx28.pos = 0;
    ctx28.is_axec = false;
    val stmt28: ASTNode = parse_statement_helper(addr(ctx28), addr(ctx28.current_scope));
    assert equals_c(stmt28.node_type, "MemberAccess"), "Expected MemberAccess node";
    assert equals_c(stmt28.data.member_access.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt28.data.member_access.member_name, "field"), "Expected member name 'field'";
    assert str_contains_c(stmt28.data.member_access.value, "42"), "Expected value to contain '42'";

    println "\nTest 29: parse_statement_helper with member access read";
    mut tokens29: list(Token) = lex(str("obj.field;"));
    mut ctx29: ParserContext;
    ctx29.tokens = addr(tokens29);
    ctx29.pos = 0;
    ctx29.is_axec = false;
    val stmt29: ASTNode = parse_statement_helper(addr(ctx29), addr(ctx29.current_scope));
    assert equals_c(stmt29.node_type, "MemberAccess"), "Expected MemberAccess node";
    assert equals_c(stmt29.data.member_access.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt29.data.member_access.member_name, "field"), "Expected member name 'field'";
    assert equals_c(stmt29.data.member_access.value, ""), "Expected empty value for read access";

    println "\nTest 30: parse_statement_helper with array access";
    mut tokens30: list(Token) = lex(str("arr[5];"));
    mut ctx30: ParserContext;
    ctx30.tokens = addr(tokens30);
    ctx30.pos = 0;
    ctx30.is_axec = false;
    val stmt30: ASTNode = parse_statement_helper(addr(ctx30), addr(ctx30.current_scope));
    assert equals_c(stmt30.node_type, "ArrayAccess"), "Expected ArrayAccess node";
    assert equals_c(stmt30.data.array_access.array_name, "arr"), "Expected array name 'arr'";
    assert str_contains_c(stmt30.data.array_access.index, "5"), "Expected index to contain '5'";

    println "\nTest 31: parse_statement_helper with array assignment";
    mut tokens31: list(Token) = lex(str("arr[i] = 42;"));
    mut ctx31: ParserContext;
    ctx31.tokens = addr(tokens31);
    ctx31.pos = 0;
    ctx31.is_axec = false;
    val stmt31: ASTNode = parse_statement_helper(addr(ctx31), addr(ctx31.current_scope));
    assert equals_c(stmt31.node_type, "ArrayAssign"), "Expected ArrayAssign node";
    assert equals_c(stmt31.data.array_assign.array_name, "arr"), "Expected array name 'arr'";
    assert str_contains_c(stmt31.data.array_assign.index, "i"), "Expected index to contain 'i'";
    assert str_contains_c(stmt31.data.array_assign.value, "42"), "Expected value to contain '42'";

    println "\nTest 32: parse_statement_helper with 2D array access";
    mut tokens32: list(Token) = lex(str("matrix[i][j];"));
    mut ctx32: ParserContext;
    ctx32.tokens = addr(tokens32);
    ctx32.pos = 0;
    ctx32.is_axec = false;
    val stmt32: ASTNode = parse_statement_helper(addr(ctx32), addr(ctx32.current_scope));
    assert equals_c(stmt32.node_type, "ArrayAccess"), "Expected ArrayAccess node for 2D array";
    assert equals_c(stmt32.data.array_access.array_name, "matrix"), "Expected array name 'matrix'";
    assert str_contains_c(stmt32.data.array_access.index, "i"), "Expected first index to contain 'i'";
    assert str_contains_c(stmt32.data.array_access.index2, "j"), "Expected second index to contain 'j'";

    println "\nTest 33: parse_statement_helper with increment";
    mut tokens33: list(Token) = lex(str("x++;"));
    mut ctx33: ParserContext;
    ctx33.tokens = addr(tokens33);
    ctx33.pos = 0;
    ctx33.is_axec = false;
    val stmt33: ASTNode = parse_statement_helper(addr(ctx33), addr(ctx33.current_scope));
    assert equals_c(stmt33.node_type, "IncDec"), "Expected IncDec node";
    assert equals_c(stmt33.data.inc_dec.variable, "x"), "Expected variable name 'x'";
    assert stmt33.data.inc_dec.is_increment == true, "Expected is_increment to be true";

    println "\nTest 34: parse_statement_helper with decrement";
    mut tokens34: list(Token) = lex(str("x--;"));
    mut ctx34: ParserContext;
    ctx34.tokens = addr(tokens34);
    ctx34.pos = 0;
    ctx34.is_axec = false;
    val stmt34: ASTNode = parse_statement_helper(addr(ctx34), addr(ctx34.current_scope));
    assert equals_c(stmt34.node_type, "IncDec"), "Expected IncDec node";
    assert equals_c(stmt34.data.inc_dec.variable, "x"), "Expected variable name 'x'";
    assert stmt34.data.inc_dec.is_increment == false, "Expected is_increment to be false";

    println "\nTest 35: parse_statement_helper with member increment";
    mut tokens35: list(Token) = lex(str("obj.count++;"));
    mut ctx35: ParserContext;
    ctx35.tokens = addr(tokens35);
    ctx35.pos = 0;
    ctx35.is_axec = false;
    val stmt35: ASTNode = parse_statement_helper(addr(ctx35), addr(ctx35.current_scope));
    assert equals_c(stmt35.node_type, "MemberIncDec"), "Expected MemberIncDec node";
    assert equals_c(stmt35.data.member_inc_dec.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt35.data.member_inc_dec.member_name, "count"), "Expected member name 'count'";
    assert stmt35.data.member_inc_dec.is_increment == true, "Expected is_increment to be true";

    println "\nTest 36: parse_statement_helper with member decrement";
    mut tokens36: list(Token) = lex(str("obj.count--;"));
    mut ctx36: ParserContext;
    ctx36.tokens = addr(tokens36);
    ctx36.pos = 0;
    ctx36.is_axec = false;
    val stmt36: ASTNode = parse_statement_helper(addr(ctx36), addr(ctx36.current_scope));
    assert equals_c(stmt36.node_type, "MemberIncDec"), "Expected MemberIncDec node";
    assert equals_c(stmt36.data.member_inc_dec.object_name, "obj"), "Expected object name 'obj'";
    assert equals_c(stmt36.data.member_inc_dec.member_name, "count"), "Expected member name 'count'";
    assert stmt36.data.member_inc_dec.is_increment == false, "Expected is_increment to be false";

    println "\nTest 37: A complete program parse";
    mut tokens37: list(Token) = lex(str(`use std.io;
        
        model Point {
            x: i32;
            y: i32;
        }
        
        enum Color {
            Red,
            Green,
            Blue
        }
        
        pub def main() {
            val p: Point = Point { x: 10, y: 20 };
            println p.x;
        }
    `));
    
    mut ctx37: ParserContext;

    ctx37.tokens = addr(tokens37);
    ctx37.pos = 0;
    ctx37.is_axec = false;

    val stmt37: ASTNode = parse_statement_helper(addr(ctx37), addr(ctx37.current_scope));
    
    assert equals_c(stmt37.node_type, "Use"), "Expected Use node as first statement in program";
    assert equals_c(stmt37.data.use_node.module_name, "std.io"), "Expected module name 'std.io'";
}
