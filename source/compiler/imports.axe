/// Author: Navid Momtahen (C) 2025
/// License: GPL-3.0
/// 
/// Handles imports and module processing

use structs (
    ASTNode,
    MacroDef
);

use lexer (
    Token,
    lex
);

use parser (
    parse,
    add_child_to_ast,
    macros_add,
    macros_mark_non_public,
    set_parse_location,
    expand_macros_in_expression
);

use std.io;
use std.string;
use std.lists;
use std.maps;
use std.os;

/// Global map tracking processed module paths
mut g_processed_modules: StringBoolMap;

/// Global map tracking model short names to their prefixed C names
/// e.g., "string" -> "std__string__string", "Token" -> "lexer__Token"
mut g_import_model_names: StringStringMap;

/// Global arena for model name storage
mut g_model_names_arena: Arena;

/// Global set tracking all imported symbol names (models, functions, enums)
/// Used for import checking to ensure symbols are explicitly imported
mut g_imported_symbols: StringBoolMap;

/// Global arena for imported symbols storage
mut g_imported_symbols_arena: Arena;

/// Resets the processed modules and model name mappings
pub def reset_processed_modules() {
    mut arena: Arena = Arena.create(1024 * 16);
    g_processed_modules = deref(StringBoolMap.create(addr(arena), 128));
    g_model_names_arena = Arena.create(1024 * 16);
    g_import_model_names = deref(StringStringMap.create(addr(g_model_names_arena), 128));
    g_imported_symbols_arena = Arena.create(1024 * 16);
    g_imported_symbols = deref(StringBoolMap.create(addr(g_imported_symbols_arena), 128));
}

/// Register a model name mapping (short name -> prefixed name)
def register_model_name(short_name: string, prefixed_name: string) {
    StringStringMap.set(addr(g_import_model_names), addr(g_model_names_arena), short_name, prefixed_name);
}

/// Look up a model's prefixed name by its short name
def lookup_model_name(short_name: string): string {
    if StringStringMap.contains(addr(g_import_model_names), short_name) {
        return StringStringMap.get(addr(g_import_model_names), short_name);
    }
    return str("");
}

/// Register a symbol as imported (for import checking)
def register_imported_symbol(symbol_name: string) {
    StringBoolMap.set(addr(g_imported_symbols), addr(g_imported_symbols_arena), symbol_name, true);
}

/// Check if a symbol has been imported
pub def is_symbol_imported(symbol_name: string): bool {
    if g_imported_symbols.keys == nil {
        return false;
    }
    return StringBoolMap.contains(addr(g_imported_symbols), symbol_name);
}

/// Check if a module has been imported
pub def has_imported_module(name: string): bool {
    if StringBoolMap.contains(addr(g_processed_modules), name) {
        return true;
    }
    return false;
}

/// Mark a module as processed
def add_processed_module(path: string) {
    mut arena: Arena = Arena.create(1024);
    StringBoolMap.set(addr(g_processed_modules), addr(arena), path, true);
}

/// Check if a module path has been processed
def is_module_processed(path: string): bool {
    return StringBoolMap.contains(addr(g_processed_modules), path);
}

/// Generate a module prefix from its name
def get_module_prefix(module_name: string): string {
    mut normalized_name: string = module_name;
    
    if has_prefix(module_name, str("./")) or has_prefix(module_name, str("../")) {
        val lenp: i32 = cast[i32](str_len(module_name));
        mut last_slash: i32 = -1;
        mut i: i32 = 0;
        loop {
            if i >= lenp {
                break;
            }
            val ch: char = get_char(module_name, i);
            if ch == '/' or ch == '\\' {
                last_slash = i;
            }
            i++;
        }
        if last_slash >= 0 and last_slash + 1 < lenp {
            normalized_name = substring_se(module_name, last_slash + 1, lenp);
        }
    }
    
    mut result: string = str("");
    mut j: i32 = 0;
    val n: i32 = cast[i32](str_len(normalized_name));
    loop {
        if j >= n {
            break;
        }
        val ch: char = get_char(normalized_name, j);
        if ch == '.' {
            result = concat(result, str("__"));
        } elif ch == '-' {
            result = concat(result, str("_"));
        } else {
            val tmp: string = substring_se(normalized_name, j, j + 1);
            result = concat(result, tmp);
        }
        j++;
    }
    return result;
}

def get_dir_from_path(path: string): string {
    val lenp: i32 = cast[i32](str_len(path));
    mut i: i32 = lenp - 1;
    loop {
        if i < 0 {
            return str(".");
        }
        val ch: char = get_char(path, i);
        if ch == '/' or ch == '\\' {
            return substring_se(path, 0, i);
        }
        i--;
    }
}

def normalize_path(path: string): string {
    val components: ref StringList = StringList.create(addr(g_model_names_arena), 32);
    mut current: string = str("");
    val path_len: i32 = cast[i32](str_len(path));
    mut i: i32 = 0;
    
    loop {
        if i >= path_len {
            if str_len(current) > 0 {
                StringList.push(components, addr(g_model_names_arena), current);
            }
            break;
        }
        
        val ch: char = get_char(path, i);
        if ch == '/' or ch == '\\' {
            if str_len(current) > 0 {
                StringList.push(components, addr(g_model_names_arena), current);
                current = str("");
            }
        } else {
            current = concat(current, substring_se(path, i, i + 1));
        }
        i++;
    }
    
    mut normalized: ref StringList = StringList.create(addr(g_model_names_arena), 32);
    mut j: i32 = 0;
    loop {
        if j >= components.len {
            break;
        }
        
        val component: string = StringList.get(components, j);
        if equals_c(component, "..") {
            if normalized.len > 0 {
                normalized.len--;
            }
        } elif !equals_c(component, ".") and str_len(component) > 0 {
            StringList.push(normalized, addr(g_model_names_arena), component);
        }
        j++;
    }
    
    mut result: string = str("");
    mut k: i32 = 0;
    loop {
        if k >= normalized.len {
            break;
        }
        
        if k > 0 {
            result = concat(result, str("/"));
        }
        result = concat(result, StringList.get(normalized, k));
        k++;
    }
    
    if str_len(path) > 0 and get_char(path, 0) == '/' {
        result = concat(str("/"), result);
    }
    
    return result;
}

def join_path(base_dir: string, rel: string): string {
    if str_len(base_dir) == 0 or equals_c(base_dir, ".") {
        return rel;
    }

    val last: char = get_char(base_dir, str_len(base_dir) - 1);
    mut path: string;
    if last == '/' or last == '\\' {
        path = concat(base_dir, rel);
    } else {
        path = concat(concat(base_dir, str("/")), rel);
    }

    if find_substr(path, str("../")) >= 0 {
        return normalize_path(path);
    }

    return path;
}

def make_module_path(base_dir: string, use_module: string): string {
    if has_prefix(use_module, str("std.")) {
        val rest: string = substring_se(use_module, 4, cast[i32](str_len(use_module)));
        mut path_rest: string = str("");
        mut i: i32 = 0;
        val n: i32 = cast[i32](str_len(rest));
        loop {
            if i >= n {
                break;
            }
            val ch: char = get_char(rest, i);
            if ch == '.' {
                path_rest = concat(path_rest, str("/"));
            } else {
                val tmp: string = substring_se(rest, i, i + 1);
                path_rest = concat(path_rest, tmp);
            }
            i++;
        }

        val rel: string = concat(path_rest, str(".axe"));
        val axe_home: string = get_env(str("AXE_HOME"));

        if str_len(axe_home) > 0 {
            val axe_home_std: string = join_path(axe_home, str("std"));
            val axe_home_path: string = join_path(axe_home_std, rel);
            if file_exists(axe_home_path) {
                return axe_home_path;
            }
        }

        val std_base: string = join_path(base_dir, str("std"));
        val local_path: string = join_path(std_base, rel);
        if file_exists(local_path) {
            return local_path;
        }

        val cwd: string = get_cwd();
        val cwd_parent: string = get_dir_from_path(cwd);
        val proj_std: string = join_path(cwd_parent, str("std"));
        val proj_path: string = join_path(proj_std, rel);
        if file_exists(proj_path) {
            return proj_path;
        }

        val exe_dir: string = get_executable_dir();
        if str_len(exe_dir) > 0 {
            val exe_std: string = join_path(exe_dir, str("std"));
            val exe_path: string = join_path(exe_std, rel);
            if file_exists(exe_path) {
                return exe_path;
            }
        }

        val home: string = get_user_home_dir();
        if str_len(home) > 0 {
            val home_axe: string = join_path(home, str(".axe"));
            val home_std: string = join_path(home_axe, str("std"));
            val home_path: string = join_path(home_std, rel);
            if file_exists(home_path) {
                return home_path;
            }
        }

        return local_path;
    }

    if has_prefix(use_module, str("./")) or has_prefix(use_module, str("../")) {
        val rel2: string = concat(use_module, str(".axe"));
        return join_path(base_dir, rel2);
    }

    mut path_mod: string = str("");
    mut j: i32 = 0;
    val mlen: i32 = cast[i32](str_len(use_module));
    loop {
        if j >= mlen {
            break;
        }
        val ch2: char = get_char(use_module, j);
        if ch2 == '.' {
            path_mod = concat(path_mod, str("/"));
        } else {
            val tmp2: string = substring_se(use_module, j, j + 1);
            path_mod = concat(path_mod, tmp2);
        }
        j++;
    }

    val rel3: string = concat(path_mod, str(".axe"));
    return join_path(base_dir, rel3);
}

def append_child(program: ref ASTNode, child: ASTNode) {
    if program.children == nil {
        unsafe {
            mut lst: list(ASTNode);
            val sz: usize = C.sizeof(list(ASTNode));
            val heap_lst: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz));
            if heap_lst != nil {
                C.memcpy(heap_lst, addr(lst), sz);
                program.children = heap_lst;
            }
        }
    }

    if program.children != nil {
        unsafe {
            mut tmp: list(ASTNode);
            val sz2: usize = C.sizeof(list(ASTNode));
            C.memcpy(addr(tmp), program.children, sz2);
            append(tmp, child);
            C.memcpy(program.children, addr(tmp), sz2);
        }
    }
}

def prefix_function_node(node: ref ASTNode, module_prefix: string, exported: ref StringBoolMap) {
    val name: string = node.data.function.name;

    if find_char_from(name, '_', cast[usize](0)) >= 0 {
        val len_name: i32 = cast[i32](str_len(name));
        mut has_double_underscore: bool = false;
        mut first_underscore_idx: i32 = -1;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                first_underscore_idx = i;
                break;
            }
            i++;
        }

        if has_double_underscore {
            val potential_model: string = substring_se(name, 0, first_underscore_idx);
            if equals_c(potential_model, module_prefix.data) {
                return;
            }

            if !StringBoolMap.contains(exported, potential_model) {
                return;
            }
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.function.name = pref;
}

def prefix_model_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.model_node.name;

    if find_char_from(name, '_', cast[usize](0)) >= 0 {
        val len_name: i32 = cast[i32](str_len(name));
        mut has_double_underscore: bool = false;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return;
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.model_node.name = pref;
}

def prefix_enum_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.enum_node.name;

    if find_char_from(name, '_', cast[usize](0)) >= 0 {
        val len_name: i32 = cast[i32](str_len(name));
        mut has_double_underscore: bool = false;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return;
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.enum_node.name = pref;
}

def build_exported_name_map(imported: ref ASTNode): StringBoolMap {
    mut arena: Arena = Arena.create(1024);
    mut m: StringBoolMap = deref(StringBoolMap.create(addr(arena), 128));
    if imported.children == nil {
        return m;
    }

    val children: ref list(ASTNode) = imported.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }
        val child: ASTNode = children.data[i];
        if equals_c(child.node_type, "Function") {
            if child.data.function.is_public {
                StringBoolMap.set(addr(m), addr(arena), child.data.function.name, true);
            }
        } elif equals_c(child.node_type, "Model") {
            StringBoolMap.set(addr(m), addr(arena), child.data.model_node.name, true);
        } elif equals_c(child.node_type, "Enum") {
            if child.data.enum_node.is_public {
                StringBoolMap.set(addr(m), addr(arena), child.data.enum_node.name, true);
            }
        } elif equals_c(child.node_type, "Overload") {
            if child.data.overload_node.is_public {
                StringBoolMap.set(addr(m), addr(arena), child.data.overload_node.name, true);
            }
        } elif equals_c(child.node_type, "Macro") {
            if child.data.macro_node.is_public {
                StringBoolMap.set(addr(m), addr(arena), child.data.macro_node.name, true);
            }
        } elif equals_c(child.node_type, "Extern") {
            if child.data.extern_node.is_public {
                StringBoolMap.set(addr(m), addr(arena), child.data.extern_node.function_name, true);
            }
        }
        i++;
    }

    return m;
}

def prefix_type_name(type_name: string, module_prefix: string, exported: ref StringBoolMap): string {
    if str_len(type_name) == 0 {
        return type_name;
    }

    val t: string = type_name;

    if has_prefix(t, str("ref ")) {
        val rest: string = strip(substr(t, 4, str_len(t) - 4));
        return concat(str("ref "), prefix_type_name(rest, module_prefix, exported));
    }
    
    if has_prefix(t, str("mut ")) {
        val rest: string = strip(substr(t, 4, str_len(t) - 4));
        return concat(str("mut "), prefix_type_name(rest, module_prefix, exported));
    }

    if has_suffix(t, str("*")) {
        val base: string = strip(substring_se(t, 0, str_len(t) - 1));
        return concat(prefix_type_name(base, module_prefix, exported), str("*"));
    }

    if has_suffix(t, str("[999]")) {
        val base: string = strip(substring_se(t, 0, str_len(t) - 5));
        return concat(prefix_type_name(base, module_prefix, exported), str("[999]"));
    }

    if find_char_from(t, '_', cast[usize](0)) >= 0 {
        val len_t: usize = str_len(t);
        mut has_double_underscore: bool = false;
        mut i: usize = 0;
        loop {
            if i + 1 >= len_t {
                break;
            }
            val c1: char = get_char(t, cast[i32](i));
            val c2: char = get_char(t, cast[i32](i + 1));
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return t;
        }
    }

    if StringBoolMap.contains(exported, t) {
        if !has_prefix(t, concat(module_prefix, str("__"))) {
            return concat(concat(module_prefix, str("__")), t);
        }
    }

    val known_prefixed: string = lookup_model_name(t);
    if str_len(known_prefixed) > 0 {
        return known_prefixed;
    }

    return type_name;
}

def prefix_types_in_node(node: ref ASTNode, module_prefix: string, exported: ref StringBoolMap) {
    if node == nil {
        return;
    }

    val nt: string = node.node_type;

    if equals_c(nt, "Function") {
        node.data.function.return_type = prefix_type_name(node.data.function.return_type, module_prefix, exported);

        mut params: ref list(string) = node.data.function.params;
        if params != nil {
            mut i: i32 = 0;
            loop {
                if i >= len(deref(params)) {
                    break;
                }
                val p: string = params.data[i];
                val colon_pos: i32 = find_char_from(p, ':', cast[usize](0));
                if colon_pos >= 0 {
                    val pname: string = strip(substring_se(p, 0, colon_pos));
                    val ptype: string = strip(substr(p, colon_pos + 1, str_len(p) - colon_pos - 1));
                    val new_ptype: string = prefix_type_name(ptype, module_prefix, exported);
                    mut newp: string = concat(pname, str(":"));
                    if str_len(new_ptype) > 0 {
                        newp = concat(concat(newp, str(" ")), new_ptype);
                    }
                    params.data[i] = newp;
                }
                i++;
            }
        }
    } elif equals_c(nt, "Declaration") {
        node.data.declaration.type_name = prefix_type_name(node.data.declaration.type_name, module_prefix, exported);
    } elif equals_c(nt, "ArrayDecl") {
        node.data.array_decl.element_type = prefix_type_name(node.data.array_decl.element_type, module_prefix, exported);
    } elif equals_c(nt, "ArrayLiteral") {
        node.data.array_literal.element_type = prefix_type_name(node.data.array_literal.element_type, module_prefix, exported);
    } elif equals_c(nt, "Macro") {
        mut ptypes: ref list(string) = node.data.macro_node.param_types;
        if ptypes != nil {
            mut j: i32 = 0;
            loop {
                if j >= len(deref(ptypes)) {
                    break;
                }
                ptypes.data[j] = prefix_type_name(ptypes.data[j], module_prefix, exported);
                j = j + 1;
            }
        }
    } elif equals_c(nt, "For") {
        node.data.for_loop.var_type = prefix_type_name(node.data.for_loop.var_type, module_prefix, exported);
    } elif equals_c(nt, "Model") {
        mut ftypes: ref list(string) = node.data.model_node.field_types;
        if ftypes != nil {
            mut k: i32 = 0;
            loop {
                if k >= len(deref(ftypes)) {
                    break;
                }
                ftypes.data[k] = prefix_type_name(ftypes.data[k], module_prefix, exported);
                k = k + 1;
            }
        }

        mut umtypes: ref list(string) = node.data.model_node.union_member_types;
        if umtypes != nil {
            mut x: i32 = 0;
            loop {
                if x >= len(deref(umtypes)) {
                    break;
                }
                umtypes.data[x] = prefix_type_name(umtypes.data[x], module_prefix, exported);
                x = x + 1;
            }
        }
    } elif equals_c(nt, "Overload") {
        val ovl_name: string = node.data.overload_node.name;
        val ovl_already_prefixed: bool = str_contains_c(ovl_name, "__");
        if !ovl_already_prefixed {
            node.data.overload_node.name = concat(concat(module_prefix, str("__")), ovl_name);
        }
        
        mut type_names_ref: ref list(string) = node.data.overload_node.type_names;
        if type_names_ref != nil {
            mut iov: i32 = 0;
            loop {
                if iov >= len(deref(type_names_ref)) {
                    break;
                }
                type_names_ref.data[iov] = prefix_type_name(type_names_ref.data[iov], module_prefix, exported);
                iov = iov + 1;
            }
        }
        
        mut target_funcs_ref: ref list(string) = node.data.overload_node.target_functions;
        if target_funcs_ref != nil {
            mut itf: i32 = 0;
            loop {
                if itf >= len(deref(target_funcs_ref)) {
                    break;
                }

                val target_name: string = target_funcs_ref.data[itf];
                val already_prefixed: bool = str_contains_c(target_name, "__");
                
                if !already_prefixed {
                    target_funcs_ref.data[itf] = concat(concat(module_prefix, str("__")), target_name);
                }

                itf++;
            }
        }
    } elif equals_c(nt, "Opaque") {
        mut tnames: ref list(string) = node.data.opaque_node.type_names;
        if tnames != nil {
            mut iy: i32 = 0;
            loop {
                if iy >= len(deref(tnames)) {
                    break;
                }
                tnames.data[iy] = prefix_type_name(tnames.data[iy], module_prefix, exported);
                iy = iy + 1;
            }
        }
    } elif equals_c(nt, "Extern") {
        mut eparams: ref list(string) = node.data.extern_node.params;
        if eparams != nil {
            mut ep: i32 = 0;
            loop {
                if ep >= len(deref(eparams)) {
                    break;
                }
                eparams.data[ep] = prefix_type_name(eparams.data[ep], module_prefix, exported);
                ep = ep + 1;
            }
        }

        node.data.extern_node.return_type = prefix_type_name(node.data.extern_node.return_type, module_prefix, exported);
    }

    if node.children != nil {
        mut children: ref list(ASTNode) = node.children;
        mut ii: i32 = 0;
        loop {
            if ii >= len(deref(children)) {
                break;
            }
            prefix_types_in_node(addr(children.data[ii]), module_prefix, exported);
            ii = ii + 1;
        }
    }
}

/// Check if a symbol name already exists in the program AST (original user code only)
///
/// Skips already-imported symbols (which have __ in their names)
def check_symbol_exists_in_program(program: ref ASTNode, symbol_name: string): bool {
    if program.children == nil {
        return false;
    }
    
    val children: ref list(ASTNode) = program.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }
        val child: ASTNode = children.data[i];
        
        if equals_c(child.node_type, "Function") {
            val func_name: string = child.data.function.name;
            if find_char_from(func_name, '_', cast[usize](0)) >= 0 {
                if str_contains_c(func_name, "__") {
                    i++;
                    continue;
                }
            }
            if compare(func_name, symbol_name) == 0 {
                return true;
            }
        } elif equals_c(child.node_type, "Declaration") {
            if compare(child.data.declaration.name, symbol_name) == 0 {
                return true;
            }
        } elif equals_c(child.node_type, "Model") {
            val model_name: string = child.data.model_node.name;
            if str_contains_c(model_name, "__") {
                i++;
                continue;
            }
            if compare(model_name, symbol_name) == 0 {
                return true;
            }
        } elif equals_c(child.node_type, "Enum") {
            val enum_name: string = child.data.enum_node.name;
            if str_contains_c(enum_name, "__") {
                i++;
                continue;
            }
            if compare(enum_name, symbol_name) == 0 {
                return true;
            }
        }
        
        i++;
    }
    return false;
}

def merge_imported_module(program: ref ASTNode, imported: ref ASTNode, use_module: string) {
    val module_prefix: string = get_module_prefix(use_module);

    if imported.children == nil {
        return;
    }

    val children: ref list(ASTNode) = imported.children;
    mut exported: StringBoolMap = build_exported_name_map(imported);
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }

        mut child: ASTNode = children.data[i];

        if equals_c(child.node_type, "Use") {
            i++;
            continue;
        }

        if equals_c(child.node_type, "Test") {
            i++;
            continue;
        }

        if equals_c(child.node_type, "Function") {
            if equals_c(child.data.function.name, "main") {
                i++;
                continue;
            }
            val func_name: string = child.data.function.name;

            if check_symbol_exists_in_program(program, func_name) {
                print "error: imported symbol '";
                print func_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }

            register_imported_symbol(func_name);
            prefix_function_node(addr(child), module_prefix, addr(exported));
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Model") {
            val original_name: string = child.data.model_node.name;

            if check_symbol_exists_in_program(program, original_name) {
                print "error: imported symbol '";
                print original_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }

            register_imported_symbol(original_name);
            prefix_model_node(addr(child), module_prefix);
            val prefixed_name: string = child.data.model_node.name;
            register_model_name(original_name, prefixed_name);
            
            if child.children != nil {
                val model_children: ref list(ASTNode) = child.children;
                mut mi: i32 = 0;
                loop {
                    if mi >= len(deref(model_children)) {
                        break;
                    }
                    if equals_c(model_children.data[mi].node_type, "Function") {
                        prefix_function_node(addr(model_children.data[mi]), module_prefix, addr(exported));
                    }
                    mi++;
                }
            }
            
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Enum") {
            val enum_name: string = child.data.enum_node.name;
            
            if !child.data.enum_node.is_public {
                i++;
                continue;
            }

            if check_symbol_exists_in_program(program, enum_name) {
                print "error: imported symbol '";
                print enum_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }

            register_imported_symbol(enum_name);
            prefix_enum_node(addr(child), module_prefix);
        } elif equals_c(child.node_type, "Declaration") {
            val var_name: string = child.data.declaration.name;
            register_imported_symbol(var_name);
        } elif equals_c(child.node_type, "Extern") {
            val func_name: string = child.data.extern_node.function_name;
            
            if child.data.extern_node.is_public {
                if check_symbol_exists_in_program(program, func_name) {
                    print "error: imported symbol '";
                    print func_name;
                    print "' from module '";
                    print use_module;
                    println "' shadows a local declaration";
                    unsafe {
                        C.exit(1);
                    }
                }

                register_imported_symbol(func_name);
            }
            
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Platform") {
            if child.children != nil {
                val plat_children: ref list(ASTNode) = child.children;
                mut j: i32 = 0;
                loop {
                    if j >= len(deref(plat_children)) { break; }
                    mut pchild: ASTNode = plat_children.data[j];
                    
                    if equals_c(pchild.node_type, "Function") {
                        val func_name: string = pchild.data.function.name;
                        register_imported_symbol(func_name);
                        prefix_function_node(addr(pchild), module_prefix, addr(exported));
                        prefix_types_in_node(addr(pchild), module_prefix, addr(exported));
                        plat_children.data[j] = pchild;
                    } elif equals_c(pchild.node_type, "Extern") {
                        val func_name: string = pchild.data.extern_node.function_name;
                        if pchild.data.extern_node.is_public {
                            register_imported_symbol(func_name);
                        }
                        prefix_types_in_node(addr(pchild), module_prefix, addr(exported));
                        plat_children.data[j] = pchild;
                    } elif equals_c(pchild.node_type, "Declaration") {
                        val var_name: string = pchild.data.declaration.name;
                        register_imported_symbol(var_name);
                    }
                    j++;
                }
            }
        } elif equals_c(child.node_type, "Overload") {
            val ovl_name: string = child.data.overload_node.name;
            if !child.data.overload_node.is_public {
                i++;
                continue;
            }

            if check_symbol_exists_in_program(program, ovl_name) {
                print "error: imported symbol '";
                print ovl_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }

            register_imported_symbol(ovl_name);
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Macro") {
            val macro_name: string = child.data.macro_node.name;
            if !child.data.macro_node.is_public {
                i++;
                continue;
            }

            if check_symbol_exists_in_program(program, macro_name) {
                print "error: imported symbol '";
                print macro_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }

            register_imported_symbol(macro_name);
            val prefixed_name: string = concat(concat(module_prefix, str("__")), macro_name);
            child.data.macro_node.name = prefixed_name;

            mut defn: MacroDef;
            defn.params = child.data.macro_node.params;
            defn.body = child.data.macro_node.body_tokens;

            macros_add(prefixed_name, defn);
        }

        append_child(program, child);
        i++;
    }
}

/// Build a set of requested import names for O(1) lookup
def build_import_set(imports: ref list(string)): StringBoolMap {
    mut arena: Arena = Arena.create(1024);
    mut import_set: StringBoolMap = deref(StringBoolMap.create(addr(arena), 64));
    
    mut i: i32 = 0;
    loop {
        if i >= len(deref(imports)) {
            break;
        }
        StringBoolMap.set(addr(import_set), addr(arena), imports.data[i], true);
        i++;
    }
    
    return import_set;
}

/// Check if symbol is requested and validate visibility
def validate_import_visibility(
    symbol_name: string,
    is_public: bool,
    use_mod: string,
    import_set: ref StringBoolMap,
    symbol_type: string
) {
    if !StringBoolMap.contains(import_set, symbol_name) {
        return;
    }
    
    if !is_public and !has_prefix(use_mod, str("std.")) {
        print "error: cannot import non-public ";
        print symbol_type;
        print " '";
        print symbol_name;
        print "' from module '";
        print use_mod;
        println "'";
        unsafe {
            C.exit(1);
        }
    }
}

pub def process_imports(
    ast: ref ASTNode,
    base_dir: string,
    is_axec: bool,
    current_file: string,
    is_top_level: bool,
    module_name: string
): ASTNode {
    if !equals_c(ast.node_type, "Program") {
        return deref(ast);
    }

    if str_len(current_file) > 0 {
        if is_module_processed(current_file) {
            return deref(ast);
        }
        add_processed_module(current_file);
    }

    mut effective_base: string = base_dir;
    if str_len(effective_base) == 0 {
        if str_len(current_file) > 0 {
            effective_base = get_dir_from_path(current_file);
        } else {
            effective_base = str(".");
        }
    }

    if ast.children == nil {
        return deref(ast);
    }

    val program_children: ref list(ASTNode) = ast.children;
    mut idx: i32 = 0;
    loop {
        if idx >= len(deref(program_children)) {
            break;
        }

        mut child: ASTNode = program_children.data[idx];

        if equals_c(child.node_type, "Use") {
            val use_mod: string = child.data.use_node.module_name;
            val module_path: string = make_module_path(effective_base, use_mod);
            
            if !file_exists(module_path) {
                print("Cannot find module '");
                print(use_mod);
                print("'\n");
                print("Searched for: ");
                print(module_path);
                print("\n");
                if has_prefix(use_mod, str("std.")) {
                    print("Note: Standard library modules are searched in:\n");
                    print("    - $AXE_HOME/std/\n");
                    print("    - compiler/std/\n");
                    print("    - ../std/\n");
                    print("    - executable_dir/std/\n");
                    print("    - ~/.axe/std/\n");
                } elif has_prefix(use_mod, str("./")) or has_prefix(use_mod, str("../")) {
                    print("Note: Relative imports are resolved from: ");
                    print(effective_base);
                    print("\n");
                } else {
                    print("Note: Module imports are resolved from: ");
                    print(effective_base);
                    print("\n");
                }
                panic(error.create("Module not found"));
            }
            
            val src: string = read_file(module_path);
            if str_len(src) == 0 {
                print(str("Error: Failed to read module file: "));
                print(module_path);
                print(str("\n"));
                panic(error.create("Failed to read module"));
            }

            val toks: list(Token) = lex(src);
            mut import_is_axec: bool = false;
            if str_len(module_path) >= 5 {
                val ext: string = substring_se(module_path, cast[i32](str_len(module_path) - 5), cast[i32](str_len(module_path)));
                if equals_c(ext, ".axe") {
                    import_is_axec = true;
                }
            }

            mut import_ast: ASTNode = parse(addr(toks), import_is_axec, false, use_mod, module_path);
            val import_base: string = get_dir_from_path(module_path);

            if import_ast.children != nil {
                val import_children: ref list(ASTNode) = import_ast.children;
                mut macro_idx: i32 = 0;
                loop {
                    if macro_idx >= len(deref(import_children)) {
                        break;
                    }
                    val import_child: ASTNode = import_children.data[macro_idx];
                    if equals_c(import_child.node_type, "Macro") {
                        if !import_child.data.macro_node.is_public {
                            macros_mark_non_public(import_child.data.macro_node.name);
                        }
                    }
                    macro_idx++;
                }
            }

            if !child.data.use_node.import_all and child.data.use_node.imports != nil {
                val import_set: StringBoolMap = build_import_set(child.data.use_node.imports);
                val is_std: bool = has_prefix(use_mod, str("std."));
                
                val import_children: ref list(ASTNode) = import_ast.children;
                if import_children != nil {
                    mut j: i32 = 0;
                    loop {
                        if j >= len(deref(import_children)) {
                            break;
                        }
                        val import_child: ASTNode = import_children.data[j];
                        val node_type: string = import_child.node_type;

                        if equals_c(node_type, "Function") {
                            val func_name: string = import_child.data.function.name;
                            validate_import_visibility(func_name, import_child.data.function.is_public, use_mod, addr(import_set), str("function"));
                        } elif equals_c(node_type, "Model") {
                            val model_name: string = import_child.data.model_node.name;
                            if StringBoolMap.contains(addr(import_set), model_name) and !import_child.data.model_node.is_public and !is_std {
                                print "error: cannot import non-public model '";
                                print model_name;
                                print "' from module '";
                                print use_mod;
                                println "'";
                                unsafe {
                                    C.exit(1);
                                }
                            }
                        } elif equals_c(node_type, "Enum") {
                            val enum_name: string = import_child.data.enum_node.name;
                            if StringBoolMap.contains(addr(import_set), enum_name) and !import_child.data.enum_node.is_public and !is_std {
                                print "error: cannot import non-public enum '";
                                print enum_name;
                                print "' from module '";
                                print use_mod;
                                println "'";
                                unsafe {
                                    C.exit(1);
                                }
                            }
                        } elif equals_c(node_type, "Overload") {
                            val ovl_name: string = import_child.data.overload_node.name;
                            validate_import_visibility(ovl_name, import_child.data.overload_node.is_public, use_mod, addr(import_set), str("overload"));
                        } elif equals_c(node_type, "Macro") {
                            val macro_name: string = import_child.data.macro_node.name;
                            if StringBoolMap.contains(addr(import_set), macro_name) and !import_child.data.macro_node.is_public and !is_std {
                                print "error: cannot import non-public macro '";
                                print macro_name;
                                print "' from module '";
                                print use_mod;
                                println "'";
                                unsafe {
                                    C.exit(1);
                                }
                            }
                        } elif equals_c(node_type, "Extern") {
                            val extern_name: string = import_child.data.extern_node.function_name;
                            validate_import_visibility(extern_name, import_child.data.extern_node.is_public, use_mod, addr(import_set), str("extern"));
                        }

                        j++;
                    }
                }
            }

            import_ast = process_imports(addr(import_ast), import_base, import_is_axec, module_path, false, use_mod);

            merge_imported_module(ast, addr(import_ast), use_mod);
        }

        idx++;
    }

    expand_macros_in_ast(ast);

    return deref(ast);
}

/// Expand macros in an AST after imports have been processed
def expand_macros_in_ast(ast: ref ASTNode) {
    if ast == nil {
        return;
    }

    val node_type: string = ast.node_type;

    if equals_c(node_type, "Declaration") {
        val initializer: string = ast.data.declaration.initializer;
        if str_len(initializer) > 0 {
            set_parse_location(ast.line, ast.source_file);
            val expanded: string = expand_macros_in_expression(initializer);
            ast.data.declaration.initializer = expanded;
        }
    } elif equals_c(node_type, "Assignment") {
        val expression: string = ast.data.assignment.expression;
        if str_len(expression) > 0 {
            set_parse_location(ast.line, ast.source_file);
            val expanded: string = expand_macros_in_expression(expression);
            ast.data.assignment.expression = expanded;
        }
    } elif equals_c(node_type, "Return") {
        val expr: string = ast.data.return_node.expression;
        if str_len(expr) > 0 {
            set_parse_location(ast.line, ast.source_file);
            val expanded: string = expand_macros_in_expression(expr);
            ast.data.return_node.expression = expanded;
        }
    } elif equals_c(node_type, "FunctionCall") or equals_c(node_type, "FuncCall") {
        mut args: ref list(string) = ast.data.func_call.args;
        if args != nil {
            set_parse_location(ast.line, ast.source_file);
            mut i: i32 = 0;
            loop {
                if i >= len(deref(args)) {
                    break;
                }
                val arg: string = args.data[i];
                val expanded: string = expand_macros_in_expression(arg);
                args.data[i] = expanded;
                i++;
            }
        }
    } elif equals_c(node_type, "If") {
        val condition: string = ast.data.if_node.condition;
        if str_len(condition) > 0 {
            set_parse_location(ast.line, ast.source_file);
            val expanded: string = expand_macros_in_expression(condition);
            ast.data.if_node.condition = expanded;
        }
    } elif equals_c(node_type, "While") {
        val condition: string = ast.data.if_node.condition;
        if str_len(condition) > 0 {
            set_parse_location(ast.line, ast.source_file);
            val expanded: string = expand_macros_in_expression(condition);
            ast.data.if_node.condition = expanded;
        }
    } elif equals_c(node_type, "For") {
        val condition: string = ast.data.for_loop.condition;
        if str_len(condition) > 0 {
            set_parse_location(ast.line, ast.source_file);
            val expanded: string = expand_macros_in_expression(condition);
            ast.data.for_loop.condition = expanded;
        }
    }

    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            expand_macros_in_ast(addr(children.data[i]));
            i++;
        }
    }
}

test {
    println "\nTest 1: get_module_prefix";
    val prefix1: string = get_module_prefix(str("std.io"));
    assert equals_c(prefix1, "std__io"), "Expected std__io";
    
    println "\nTest 2: get_module_prefix with dashes";
    val prefix2: string = get_module_prefix(str("my-module"));
    assert equals_c(prefix2, "my_module"), "Expected my_module";
    
    println "\nTest 3: join_path";
    val joined: string = join_path(str("foo"), str("bar"));
    assert str_contains_c(joined, "foo"), "Expected path to contain foo";
    assert str_contains_c(joined, "bar"), "Expected path to contain bar";
    
    println "\nTest 4: get_dir_from_path";
    val dir: string = get_dir_from_path(str("foo/bar/baz.axe"));
    assert equals_c(dir, "foo/bar"), "Expected foo/bar";
    
    println "\nTest 5: is_symbol_imported (initially empty)";
    reset_processed_modules();
    val is_imported: bool = is_symbol_imported(str("nonexistent"));
    assert is_imported == false, "Expected false for nonexistent symbol";
}
