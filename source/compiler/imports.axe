/// Author: Navid Momtahen (C) 2025
/// License: GPL-3.0
/// 
/// Handles imports and module processing

use structs (
    ASTNode
);

use lexer (
    Token, 
    lex
);

use parser (
    parse,
    add_child_to_ast
);

use std.io;
use std.string;
use std.lists;
use std.maps;
use std.os;

/// Global map tracking processed module paths
mut g_processed_modules: StringBoolMap;

/// Global map tracking model short names to their prefixed C names
/// e.g., "string" -> "std__string__string", "Token" -> "lexer__Token"
mut g_import_model_names: StringStringMap;

/// Global arena for model name storage
mut g_model_names_arena: Arena;

/// Global set tracking all imported symbol names (models, functions, enums)
/// Used for import checking to ensure symbols are explicitly imported
mut g_imported_symbols: StringBoolMap;

/// Global arena for imported symbols storage
mut g_imported_symbols_arena: Arena;

/// Resets the processed modules and model name mappings
pub def reset_processed_modules() {
    mut arena: Arena = Arena.create(1024 * 16);
    g_processed_modules = deref(StringBoolMap.create(addr(arena), 128));
    g_model_names_arena = Arena.create(1024 * 16);
    g_import_model_names = deref(StringStringMap.create(addr(g_model_names_arena), 128));
    g_imported_symbols_arena = Arena.create(1024 * 16);
    g_imported_symbols = deref(StringBoolMap.create(addr(g_imported_symbols_arena), 128));
}

/// Register a model name mapping (short name -> prefixed name)
def register_model_name(short_name: string, prefixed_name: string) {
    StringStringMap.set(addr(g_import_model_names), addr(g_model_names_arena), short_name, prefixed_name);
}

/// Look up a model's prefixed name by its short name
def lookup_model_name(short_name: string): string {
    if StringStringMap.contains(addr(g_import_model_names), short_name) {
        return StringStringMap.get(addr(g_import_model_names), short_name);
    }
    return str("");
}

/// Register a symbol as imported (for import checking)
def register_imported_symbol(symbol_name: string) {
    StringBoolMap.set(addr(g_imported_symbols), addr(g_imported_symbols_arena), symbol_name, true);
}

/// Check if a symbol has been imported
pub def is_symbol_imported(symbol_name: string): bool {
    if g_imported_symbols.keys == nil {
        return false;
    }
    return StringBoolMap.contains(addr(g_imported_symbols), symbol_name);
}

/// Check if a module has been imported
pub def has_imported_module(name: string): bool {
    if StringBoolMap.contains(addr(g_processed_modules), name) {
        return true;
    }
    return false;
}

/// Mark a module as processed
def add_processed_module(path: string) {
    mut arena: Arena = Arena.create(1024);
    StringBoolMap.set(addr(g_processed_modules), addr(arena), path, true);
}

/// Check if a module path has been processed
def is_module_processed(path: string): bool {
    return StringBoolMap.contains(addr(g_processed_modules), path);
}

/// Generate a module prefix from its name
def get_module_prefix(module_name: string): string {
    mut result: string = str("");
    mut i: i32 = 0;
    val n: i32 = str_len(module_name);
    loop {
        if i >= n {
            break;
        }
        val ch: char = get_char(module_name, i);
        if ch == '.' {
            result = concat(result, str("__"));
        } elif ch == '-' {
            result = concat(result, str("_"));
        } else {
            val tmp: string = substring_se(module_name, i, i + 1);
            result = concat(result, tmp);
        }
        i++;
    }
    return result;
}

def get_dir_from_path(path: string): string {
    val lenp: i32 = str_len(path);
    mut i: i32 = lenp - 1;
    loop {
        if i < 0 {
            return str(".");
        }
        val ch: char = get_char(path, i);
        if ch == '/' or ch == '\\' {
            return substring_se(path, 0, i);
        }
        i = i - 1;
    }
}

def join_path(base_dir: string, rel: string): string {
    if str_len(base_dir) == 0 or equals_c(base_dir, ".") {
        return rel;
    }

    val last: char = get_char(base_dir, str_len(base_dir) - 1);
    if last == '/' or last == '\\' {
        return concat(base_dir, rel);
    }

    return concat(concat(base_dir, str("/")), rel);
}

def make_module_path(base_dir: string, use_module: string): string {
    if has_prefix(use_module, str("std.")) {
        val rest: string = substring_se(use_module, 4, cast[i32](str_len(use_module)));
        mut path_rest: string = str("");
        mut i: i32 = 0;
        val n: i32 = str_len(rest);
        loop {
            if i >= n {
                break;
            }
            val ch: char = get_char(rest, i);
            if ch == '.' {
                path_rest = concat(path_rest, str("/"));
            } else {
                val tmp: string = substring_se(rest, i, i + 1);
                path_rest = concat(path_rest, tmp);
            }
            i++;
        }

        val rel: string = concat(path_rest, str(".axec"));
        val axe_home: string = get_env(str("AXE_HOME"));

        if str_len(axe_home) > 0 {
            val axe_home_std: string = join_path(axe_home, str("std"));
            val axe_home_path: string = join_path(axe_home_std, rel);
            if file_exists(axe_home_path) {
                return axe_home_path;
            }
        }

        val std_base: string = join_path(base_dir, str("std"));
        val local_path: string = join_path(std_base, rel);
        if file_exists(local_path) {
            return local_path;
        }

        val cwd: string = get_cwd();
        val cwd_parent: string = get_dir_from_path(cwd);
        val proj_std: string = join_path(cwd_parent, str("std"));
        val proj_path: string = join_path(proj_std, rel);
        if file_exists(proj_path) {
            return proj_path;
        }

        val exe_dir: string = get_executable_dir();
        if str_len(exe_dir) > 0 {
            val exe_std: string = join_path(exe_dir, str("std"));
            val exe_path: string = join_path(exe_std, rel);
            if file_exists(exe_path) {
                return exe_path;
            }
        }

        val home: string = get_user_home_dir();
        if str_len(home) > 0 {
            val home_axe: string = join_path(home, str(".axe"));
            val home_std: string = join_path(home_axe, str("std"));
            val home_path: string = join_path(home_std, rel);
            if file_exists(home_path) {
                return home_path;
            }
        }

        return local_path;
    }

    if has_prefix(use_module, str("./")) or has_prefix(use_module, str("../")) {
        val rel2: string = concat(use_module, str(".axe"));
        return join_path(base_dir, rel2);
    }

    mut path_mod: string = str("");
    mut j: i32 = 0;
    val mlen: i32 = str_len(use_module);
    loop {
        if j >= mlen {
            break;
        }
        val ch2: char = get_char(use_module, j);
        if ch2 == '.' {
            path_mod = concat(path_mod, str("/"));
        } else {
            val tmp2: string = substring_se(use_module, j, j + 1);
            path_mod = concat(path_mod, tmp2);
        }
        j++;
    }

    val rel3: string = concat(path_mod, str(".axe"));
    return join_path(base_dir, rel3);
}

def append_child(program: ref ASTNode, child: ASTNode) {
    if program.children == nil {
        unsafe {
            mut lst: list(ASTNode);
            val sz: usize = C.sizeof(list(ASTNode));
            val heap_lst: ref list(ASTNode) = cast[ref list(ASTNode)](C.malloc(sz));
            if heap_lst != nil {
                C.memcpy(heap_lst, addr(lst), sz);
                program.children = heap_lst;
            }
        }
    }

    if program.children != nil {
        unsafe {
            mut tmp: list(ASTNode);
            val sz2: usize = C.sizeof(list(ASTNode));
            C.memcpy(addr(tmp), program.children, sz2);
            append(tmp, child);
            C.memcpy(program.children, addr(tmp), sz2);
        }
    }
}

def prefix_function_node(node: ref ASTNode, module_prefix: string, exported: ref StringBoolMap) {
    val name: string = node.data.function.name;

    if find_char_from(name, '_', cast[usize](0)) >= 0 {
        val len_name: i32 = str_len(name);
        mut has_double_underscore: bool = false;
        mut first_underscore_idx: i32 = -1;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                first_underscore_idx = i;
                break;
            }
            i++;
        }

        if has_double_underscore {
            val potential_model: string = substring_se(name, 0, first_underscore_idx);
            if !StringBoolMap.contains(exported, potential_model) {
                return;
            }
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.function.name = pref;
}

def prefix_model_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.model_node.name;

    if find_char_from(name, '_', cast[usize](0)) >= 0 {
        val len_name: i32 = str_len(name);
        mut has_double_underscore: bool = false;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return;
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.model_node.name = pref;
}

def prefix_enum_node(node: ref ASTNode, module_prefix: string) {
    val name: string = node.data.enum_node.name;

    if find_char_from(name, '_', cast[usize](0)) >= 0 {
        val len_name: i32 = str_len(name);
        mut has_double_underscore: bool = false;
        mut i: i32 = 0;
        loop {
            if i + 1 >= len_name {
                break;
            }
            val c1: char = get_char(name, i);
            val c2: char = get_char(name, i + 1);
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return;
        }
    }

    val pref: string = concat(concat(module_prefix, str("__")), name);
    node.data.enum_node.name = pref;
}

def build_exported_name_map(imported: ref ASTNode): StringBoolMap {
    mut arena: Arena = Arena.create(1024);
    mut m: StringBoolMap = deref(StringBoolMap.create(addr(arena), 128));
    if imported.children == nil {
        return m;
    }

    val children: ref list(ASTNode) = imported.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }
        val child: ASTNode = children.data[i];
        if equals_c(child.node_type, "Function") {
            if child.data.function.is_public {
                StringBoolMap.set(addr(m), addr(arena), child.data.function.name, true);
            }
        } elif equals_c(child.node_type, "Model") {
            if child.data.model_node.is_public {
                StringBoolMap.set(addr(m), addr(arena), child.data.model_node.name, true);
            }
        } elif equals_c(child.node_type, "Enum") {
            StringBoolMap.set(addr(m), addr(arena), child.data.enum_node.name, true);
        }
        i++;
    }

    return m;
}

def prefix_type_name(type_name: string, module_prefix: string, exported: ref StringBoolMap): string {
    if str_len(type_name) == 0 {
        return type_name;
    }

    val t: string = type_name;

    if has_prefix(t, str("ref ")) {
        val rest: string = strip(substr(t, 4, str_len(t) - 4));
        return concat(str("ref "), prefix_type_name(rest, module_prefix, exported));
    }
    
    if has_prefix(t, str("mut ")) {
        val rest: string = strip(substr(t, 4, str_len(t) - 4));
        return concat(str("mut "), prefix_type_name(rest, module_prefix, exported));
    }

    if has_suffix(t, str("*")) {
        val base: string = strip(substring_se(t, 0, str_len(t) - 1));
        return concat(prefix_type_name(base, module_prefix, exported), str("*"));
    }

    if has_suffix(t, str("[999]")) {
        val base: string = strip(substring_se(t, 0, str_len(t) - 5));
        return concat(prefix_type_name(base, module_prefix, exported), str("[999]"));
    }

    if find_char_from(t, '_', cast[usize](0)) >= 0 {
        val len_t: usize = str_len(t);
        mut has_double_underscore: bool = false;
        mut i: usize = 0;
        loop {
            if i + 1 >= len_t {
                break;
            }
            val c1: char = get_char(t, cast[i32](i));
            val c2: char = get_char(t, cast[i32](i + 1));
            if c1 == '_' and c2 == '_' {
                has_double_underscore = true;
                break;
            }
            i++;
        }

        if has_double_underscore {
            return t;
        }
    }

    if StringBoolMap.contains(exported, t) {
        if !has_prefix(t, concat(module_prefix, str("__"))) {
            return concat(concat(module_prefix, str("__")), t);
        }
    }

    val known_prefixed: string = lookup_model_name(t);
    if str_len(known_prefixed) > 0 {
        return known_prefixed;
    }

    return type_name;
}

def prefix_types_in_node(node: ref ASTNode, module_prefix: string, exported: ref StringBoolMap) {
    if node == nil {
        return;
    }

    val nt: string = node.node_type;

    if equals_c(nt, "Function") {
        node.data.function.return_type = prefix_type_name(node.data.function.return_type, module_prefix, exported);

        mut params: ref list(string) = node.data.function.params;
        if params != nil {
            mut i: i32 = 0;
            loop {
                if i >= len(deref(params)) {
                    break;
                }
                val p: string = params.data[i];
                val colon_pos: i32 = find_char_from(p, ':', cast[usize](0));
                if colon_pos >= 0 {
                    val pname: string = strip(substring_se(p, 0, colon_pos));
                    val ptype: string = strip(substr(p, colon_pos + 1, str_len(p) - colon_pos - 1));
                    val new_ptype: string = prefix_type_name(ptype, module_prefix, exported);
                    mut newp: string = concat(pname, str(":"));
                    if str_len(new_ptype) > 0 {
                        newp = concat(concat(newp, str(" ")), new_ptype);
                    }
                    params.data[i] = newp;
                }
                i++;
            }
        }
    } elif equals_c(nt, "Declaration") {
        node.data.declaration.type_name = prefix_type_name(node.data.declaration.type_name, module_prefix, exported);
    } elif equals_c(nt, "ArrayDecl") {
        node.data.array_decl.element_type = prefix_type_name(node.data.array_decl.element_type, module_prefix, exported);
    } elif equals_c(nt, "ArrayLiteral") {
        node.data.array_literal.element_type = prefix_type_name(node.data.array_literal.element_type, module_prefix, exported);
    } elif equals_c(nt, "Macro") {
        mut ptypes: ref list(string) = node.data.macro_node.param_types;
        if ptypes != nil {
            mut j: i32 = 0;
            loop {
                if j >= len(deref(ptypes)) {
                    break;
                }
                ptypes.data[j] = prefix_type_name(ptypes.data[j], module_prefix, exported);
                j = j + 1;
            }
        }
    } elif equals_c(nt, "For") {
        node.data.for_loop.var_type = prefix_type_name(node.data.for_loop.var_type, module_prefix, exported);
    } elif equals_c(nt, "Model") {
        mut ftypes: ref list(string) = node.data.model_node.field_types;
        if ftypes != nil {
            mut k: i32 = 0;
            loop {
                if k >= len(deref(ftypes)) {
                    break;
                }
                ftypes.data[k] = prefix_type_name(ftypes.data[k], module_prefix, exported);
                k = k + 1;
            }
        }

        mut umtypes: ref list(string) = node.data.model_node.union_member_types;
        if umtypes != nil {
            mut x: i32 = 0;
            loop {
                if x >= len(deref(umtypes)) {
                    break;
                }
                umtypes.data[x] = prefix_type_name(umtypes.data[x], module_prefix, exported);
                x = x + 1;
            }
        }
    } elif equals_c(nt, "Overload") {
        val ovl_name: string = node.data.overload_node.name;
        val ovl_already_prefixed: bool = str_contains_c(ovl_name, "__");
        if !ovl_already_prefixed {
            node.data.overload_node.name = concat(concat(module_prefix, str("__")), ovl_name);
        }
        
        mut type_names_ref: ref list(string) = node.data.overload_node.type_names;
        if type_names_ref != nil {
            mut iov: i32 = 0;
            loop {
                if iov >= len(deref(type_names_ref)) {
                    break;
                }
                type_names_ref.data[iov] = prefix_type_name(type_names_ref.data[iov], module_prefix, exported);
                iov = iov + 1;
            }
        }
        
        mut target_funcs_ref: ref list(string) = node.data.overload_node.target_functions;
        if target_funcs_ref != nil {
            mut itf: i32 = 0;
            loop {
                if itf >= len(deref(target_funcs_ref)) {
                    break;
                }

                val target_name: string = target_funcs_ref.data[itf];
                val already_prefixed: bool = str_contains_c(target_name, "__");
                
                if !already_prefixed {
                    target_funcs_ref.data[itf] = concat(concat(module_prefix, str("__")), target_name);
                }

                itf++;
            }
        }
    } elif equals_c(nt, "Opaque") {
        mut tnames: ref list(string) = node.data.opaque_node.type_names;
        if tnames != nil {
            mut iy: i32 = 0;
            loop {
                if iy >= len(deref(tnames)) {
                    break;
                }
                tnames.data[iy] = prefix_type_name(tnames.data[iy], module_prefix, exported);
                iy = iy + 1;
            }
        }
    } elif equals_c(nt, "Extern") {
        mut eparams: ref list(string) = node.data.extern_node.params;
        if eparams != nil {
            mut ep: i32 = 0;
            loop {
                if ep >= len(deref(eparams)) {
                    break;
                }
                eparams.data[ep] = prefix_type_name(eparams.data[ep], module_prefix, exported);
                ep = ep + 1;
            }
        }

        node.data.extern_node.return_type = prefix_type_name(node.data.extern_node.return_type, module_prefix, exported);
    }

    if node.children != nil {
        mut children: ref list(ASTNode) = node.children;
        mut ii: i32 = 0;
        loop {
            if ii >= len(deref(children)) {
                break;
            }
            prefix_types_in_node(addr(children.data[ii]), module_prefix, exported);
            ii = ii + 1;
        }
    }
}

/// Check if a symbol name already exists in the program AST (original user code only)
///
/// Skips already-imported symbols (which have __ in their names)
def check_symbol_exists_in_program(program: ref ASTNode, symbol_name: string): bool {
    if program.children == nil {
        return false;
    }
    
    val children: ref list(ASTNode) = program.children;
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }
        val child: ASTNode = children.data[i];
        
        if equals_c(child.node_type, "Function") {
            val func_name: string = child.data.function.name;
            if find_char_from(func_name, '_', cast[usize](0)) >= 0 {
                if str_contains_c(func_name, "__") {
                    i++;
                    continue;
                }
            }
            if compare(func_name, symbol_name) == 0 {
                return true;
            }
        } elif equals_c(child.node_type, "Declaration") {
            if compare(child.data.declaration.name, symbol_name) == 0 {
                return true;
            }
        } elif equals_c(child.node_type, "Model") {
            val model_name: string = child.data.model_node.name;
            if str_contains_c(model_name, "__") {
                i++;
                continue;
            }
            if compare(model_name, symbol_name) == 0 {
                return true;
            }
        } elif equals_c(child.node_type, "Enum") {
            val enum_name: string = child.data.enum_node.name;
            if str_contains_c(enum_name, "__") {
                i++;
                continue;
            }
            if compare(enum_name, symbol_name) == 0 {
                return true;
            }
        }
        
        i++;
    }
    return false;
}

def merge_imported_module(program: ref ASTNode, imported: ref ASTNode, use_module: string) {
    val module_prefix: string = get_module_prefix(use_module);

    if imported.children == nil {
        return;
    }

    val children: ref list(ASTNode) = imported.children;
    mut exported: StringBoolMap = build_exported_name_map(imported);
    mut i: i32 = 0;
    loop {
        if i >= len(deref(children)) {
            break;
        }

        val child: ASTNode = children.data[i];

        if equals_c(child.node_type, "Use") {
            i++;
            continue;
        }

        if equals_c(child.node_type, "Test") {
            i++;
            continue;
        }

        if equals_c(child.node_type, "Function") {
            if equals_c(child.data.function.name, "main") {
                i++;
                continue;
            }
            val func_name: string = child.data.function.name;

            if check_symbol_exists_in_program(program, func_name) {
                print "error: imported symbol '";
                print func_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }

            register_imported_symbol(func_name);
            prefix_function_node(addr(child), module_prefix, addr(exported));
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Model") {
            val original_name: string = child.data.model_node.name;

            if check_symbol_exists_in_program(program, original_name) {
                print "error: imported symbol '";
                print original_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }

            register_imported_symbol(original_name);
            prefix_model_node(addr(child), module_prefix);
            val prefixed_name: string = child.data.model_node.name;
            register_model_name(original_name, prefixed_name);
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        } elif equals_c(child.node_type, "Enum") {
            val enum_name: string = child.data.enum_node.name;
            
            if check_symbol_exists_in_program(program, enum_name) {
                print "error: imported symbol '";
                print enum_name;
                print "' from module '";
                print use_module;
                println "' shadows a local declaration";
                unsafe {
                    C.exit(1);
                }
            }
            
            register_imported_symbol(enum_name);
            prefix_enum_node(addr(child), module_prefix);
        } elif equals_c(child.node_type, "Declaration") {
            val var_name: string = child.data.declaration.name;
            register_imported_symbol(var_name);
        } elif equals_c(child.node_type, "Extern") {
            val func_name: string = child.data.extern_node.function_name;
            register_imported_symbol(func_name);
        } elif equals_c(child.node_type, "Platform") {
            if child.children != nil {
                val plat_children: ref list(ASTNode) = child.children;
                mut j: i32 = 0;
                loop {
                    if j >= len(deref(plat_children)) { break; }
                    mut pchild: ASTNode = plat_children.data[j];
                    
                    if equals_c(pchild.node_type, "Function") {
                        val func_name: string = pchild.data.function.name;
                        register_imported_symbol(func_name);
                        prefix_function_node(addr(pchild), module_prefix, addr(exported));
                        prefix_types_in_node(addr(pchild), module_prefix, addr(exported));
                        plat_children.data[j] = pchild;
                    } elif equals_c(pchild.node_type, "Extern") {
                        val func_name: string = pchild.data.extern_node.function_name;
                        register_imported_symbol(func_name);
                    } elif equals_c(pchild.node_type, "Declaration") {
                        val var_name: string = pchild.data.declaration.name;
                        register_imported_symbol(var_name);
                    }
                    j++;
                }
            }
        } elif equals_c(child.node_type, "Overload") {
            prefix_types_in_node(addr(child), module_prefix, addr(exported));
        }

        append_child(program, child);
        i++;
    }
}

pub def process_imports(ast: ref ASTNode, base_dir: string, is_axec: bool, current_file: string, is_top_level: bool, module_name: string): ASTNode {
    if !equals_c(ast.node_type, "Program") {
        return *ast;
    }

    if str_len(current_file) > 0 {
        if is_module_processed(current_file) {
            return *ast;
        }
        add_processed_module(current_file);
    }

    mut effective_base: string = base_dir;
    if str_len(effective_base) == 0 {
        if str_len(current_file) > 0 {
            effective_base = get_dir_from_path(current_file);
        } else {
            effective_base = str(".");
        }
    }

    if ast.children == nil {
        return *ast;
    }

    val program_children: ref list(ASTNode) = ast.children;
    mut idx: i32 = 0;
    loop {
        if idx >= len(deref(program_children)) {
            break;
        }

        mut child: ASTNode = program_children.data[idx];

        if equals_c(child.node_type, "Use") {
            val use_mod: string = child.data.use_node.module_name;
            val module_path: string = make_module_path(effective_base, use_mod);
            val src: string = read_file(module_path);
            if str_len(src) == 0 {
                idx = idx + 1;
                continue;
            }

            val toks: list(Token) = lex(src);
            mut import_is_axec: bool = false;
            if str_len(module_path) >= 5 {
                val ext: string = substring_se(module_path, cast[i32](str_len(module_path) - 5), cast[i32](str_len(module_path)));
                if equals_c(ext, ".axec") {
                    import_is_axec = true;
                }
            }

            mut import_ast: ASTNode = parse(addr(toks), import_is_axec, false, use_mod, module_path);
            val import_base: string = get_dir_from_path(module_path);

            if !child.data.use_node.import_all && child.data.use_node.imports != nil {
                val import_children: ref list(ASTNode) = import_ast.children;
                if import_children != nil {
                    mut j: i32 = 0;
                    loop {
                        if j >= len(deref(import_children)) {
                            break;
                        }
                        val import_child: ASTNode = import_children.data[j];

                        if equals_c(import_child.node_type, "Function") {
                            val func_name: string = import_child.data.function.name;
                            mut is_requested: bool = false;
                            mut k: i32 = 0;
                            loop {
                                if k >= len(deref(child.data.use_node.imports)) {
                                    break;
                                }
                                if compare(child.data.use_node.imports*.data[k], func_name) == 0{
                                    is_requested = true;
                                    break;
                                }
                                k++;
                            }
                            if is_requested and !import_child.data.function.is_public {
                                if !has_prefix(use_mod, str("std.")) {
                                    print "error: cannot import non-public function '";
                                    print func_name;
                                    print "' from module '";
                                    print use_mod;
                                    println "'";
                                    unsafe {
                                        C.exit(1);
                                    }
                                }
                            }
                        } elif equals_c(import_child.node_type, "Model") {
                            val model_name: string = import_child.data.model_node.name;
                            mut is_requested: bool = false;
                            mut k: i32 = 0;
                            loop {
                                if k >= len(deref(child.data.use_node.imports)) {
                                    break;
                                }
                                if compare(child.data.use_node.imports*.data[k], model_name) == 0{
                                    is_requested = true;
                                    break;
                                }
                                k++;
                            }

                            if is_requested and !import_child.data.model_node.is_public {
                                if has_prefix(use_mod, str("std.")) {
                                    // Temporary: Allow it to maintain compatibility
                                } else {
                                    print "error: cannot import non-public model '";
                                    print model_name;
                                    print "' from module '";
                                    print use_mod;
                                    println "'";
                                    unsafe {
                                        C.exit(1);
                                    }
                                }
                            }
                        } elif equals_c(import_child.node_type, "Enum") {
                            val enum_name: string = import_child.data.enum_node.name;
                            mut is_requested: bool = false;
                            mut k: i32 = 0;
                            loop {
                                if k >= len(deref(child.data.use_node.imports)) {
                                    break;
                                }
                                if compare(child.data.use_node.imports*.data[k], enum_name) == 0{
                                    is_requested = true;
                                    break;
                                }
                                k++;
                            }
                        }

                        j++;
                    }
                }
            }

            import_ast = process_imports(addr(import_ast), import_base, import_is_axec, module_path, false, use_mod);

            merge_imported_module(ast, addr(import_ast), use_mod);
        }

        idx++;
    }

    return *ast;
}

test {
    println "\nTest 1: get_module_prefix";
    val prefix1: string = get_module_prefix(str("std.io"));
    assert equals_c(prefix1, "std__io"), "Expected std__io";
    
    println "\nTest 2: get_module_prefix with dashes";
    val prefix2: string = get_module_prefix(str("my-module"));
    assert equals_c(prefix2, "my_module"), "Expected my_module";
    
    println "\nTest 3: join_path";
    val joined: string = join_path(str("foo"), str("bar"));
    assert str_contains_c(joined, "foo"), "Expected path to contain foo";
    assert str_contains_c(joined, "bar"), "Expected path to contain bar";
    
    println "\nTest 4: get_dir_from_path";
    val dir: string = get_dir_from_path(str("foo/bar/baz.axe"));
    assert equals_c(dir, "foo/bar"), "Expected foo/bar";
    
    println "\nTest 5: is_symbol_imported (initially empty)";
    reset_processed_modules();
    val is_imported: bool = is_symbol_imported(str("nonexistent"));
    assert is_imported == false, "Expected false for nonexistent symbol";
}
