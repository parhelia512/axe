/// Author: Navid Momtahen (C) 2025
/// License: GPL-3.0
/// 
/// Handles the rendering process.

use gstate;
use structs     (ASTNode);
use imports     (is_symbol_imported);
use std.lists   (StringList, IntList);
use std.string;
use std.io;
use std.os;
use std.maps;
use std.errors;

/// Type mappings from Axe to C
mut g_type_mappings: StringStringMap;

/// Track reference depths for variables
mut g_ref_depths: StringIntMap;

/// Track mutability
mut g_is_mutable: StringBoolMap;

/// Function prefixes for imported modules
mut g_function_prefixes: StringStringMap;

/// Model name mappings
mut g_model_names: StringStringMap;

/// Enum names
mut g_enum_names: StringBoolMap;

/// Opaque types (external C types that don't need import checking)
mut g_opaque_types: StringBoolMap;

/// Foreign types (declared in foreign blocks)
mut g_foreign_types: StringBoolMap;

/// Generated typedefs to avoid duplicates
mut g_generated_typedefs: StringBoolMap;

/// Generated functions to avoid duplicates
mut g_generated_functions: StringBoolMap;

/// Field types for models
mut g_field_types: StringStringMap;

/// Pointer fields - tracks which model.field entries are pointer types
mut g_pointer_fields: StringBoolMap;

/// Variable types
mut g_var_types: StringStringMap;

/// Track list variable types for append operations (variable name -> element type)
mut g_list_of_types: StringStringMap;

/// Track discovered list element types used in generated code (for C list helpers)
mut g_list_element_types: StringBoolMap;

/// Ordered list of discovered element type strings (for deterministic emission)
mut g_list_elements: ref StringList;

/// Global external headers (from use external statements)
mut g_global_external_headers: ref StringList;

/// Windows-specific external headers
mut g_windows_external_headers: ref StringList;

/// POSIX-specific external headers
mut g_posix_external_headers: ref StringList;

/// Global SB.
mut g_renderer_sb: ref StringBuilder;

/// Track emitted global variable names to avoid duplicates
mut g_emitted_globals: StringBoolMap;

/// Global variable prefixes mapping (logical name -> C symbol like gvar__name)
mut g_global_var_prefixes: StringStringMap;

/// Function parameter types (function_name -> "type1,type2,type3")
mut g_function_param_types: StringStringMap;

/// Function return types (function_name -> "type")
mut g_function_return_types: StringStringMap;

/// Extern functions
mut g_extern_functions: StringBoolMap;

/// Current source file name for #line directives
mut g_current_source_file: string;

/// Current source line number
mut g_current_line: i32;

/// Whether to emit #line directives
mut g_emit_line_directives: bool;

/// Set the current source file for #line directives
pub def set_source_file(filename: string) {
    g_current_source_file = filename;
}

/// Check if a specific external header was used (e.g., "pcre.h", "curl/curl.h")
pub def has_external_header(header_name: string): bool {
    if StringList.contains(g_global_external_headers, header_name) {
        return true;
    }
    if StringList.contains(g_windows_external_headers, header_name) {
        return true;
    }
    if StringList.contains(g_posix_external_headers, header_name) {
        return true;
    }
    return false;
}

/// Emit a #line directive for error mapping
[inline]
def emit_line_directive(line: i32): string {
    if !g_emit_line_directives or line <= 0 {
        return str("");
    }
    mut sb: StringBuilder = StringBuilder.init(64);
    StringBuilder.append_c(addr(sb), "#line ");
    StringBuilder.append(addr(sb), i32_to_string(line));
    if str_len(g_current_source_file) > 0 {
        StringBuilder.append_c(addr(sb), " \"");
        StringBuilder.append(addr(sb), g_current_source_file);
        StringBuilder.append_c(addr(sb), "\"");
    }
    StringBuilder.append_c(addr(sb), "\n");
    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Initialize renderer globals.
///
/// This must be called before using the renderer at all.
pub def initialize_renderer() {
    mut arena: Arena = Arena.create(1024 * 1024 * 100);
    
    g_type_mappings = deref(StringStringMap.create(addr(arena), 128));
    g_function_return_types = deref(StringStringMap.create(addr(arena), 1024));
    g_ref_depths = deref(StringIntMap.create(addr(arena), 128));
    g_is_mutable = deref(StringBoolMap.create(addr(arena), 128));
    g_function_prefixes = deref(StringStringMap.create(addr(arena), 128));
    g_model_names = deref(StringStringMap.create(addr(arena), 128));
    g_enum_names = deref(StringBoolMap.create(addr(arena), 128));
    g_opaque_types = deref(StringBoolMap.create(addr(arena), 128));
    g_foreign_types = deref(StringBoolMap.create(addr(arena), 128));
    g_generated_typedefs = deref(StringBoolMap.create(addr(arena), 128));
    g_generated_functions = deref(StringBoolMap.create(addr(arena), 128));
    g_field_types = deref(StringStringMap.create(addr(arena), 128));
    g_pointer_fields = deref(StringBoolMap.create(addr(arena), 128));
    g_var_types = deref(StringStringMap.create(addr(arena), 128));
    g_list_of_types = deref(StringStringMap.create(addr(arena), 128));
    g_list_element_types = deref(StringBoolMap.create(addr(arena), 128));
    g_list_elements = StringList.create(addr(arena), 64);
    g_global_external_headers = StringList.create(addr(arena), 32);
    g_windows_external_headers = StringList.create(addr(arena), 32);
    g_posix_external_headers = StringList.create(addr(arena), 32);
    g_emitted_globals = deref(StringBoolMap.create(addr(arena), 128));
    g_global_var_prefixes = deref(StringStringMap.create(addr(arena), 128));
    g_function_param_types = deref(StringStringMap.create(addr(arena), 256));
    g_extern_functions = deref(StringBoolMap.create(addr(arena), 128));
    
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i8"), str("int8_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u8"), str("uint8_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i16"), str("int16_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u16"), str("uint16_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i32"), str("int32_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u32"), str("uint32_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("i64"), str("int64_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("u64"), str("uint64_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("isize"), str("intptr_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("usize"), str("uintptr_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("f32"), str("float"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("f64"), str("double"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("bool"), str("bool"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("char"), str("char"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("rchar"), str("char*"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("byte"), str("uint8_t"));
    StringStringMap.set(addr(g_type_mappings), addr(arena), str("ptrdiff"), str("isize"));
}

/// Check if a type is a builtin primitive type
[inline]
def is_builtin_type(type_name: string): bool {
    return equals_c(type_name, "i8") or equals_c(type_name, "u8") or
        equals_c(type_name, "i16") or equals_c(type_name, "u16") or
        equals_c(type_name, "i32") or equals_c(type_name, "u32") or
        equals_c(type_name, "i64") or equals_c(type_name, "u64") or
        equals_c(type_name, "isize") or equals_c(type_name, "usize") or
        equals_c(type_name, "f32") or equals_c(type_name, "f64") or
        equals_c(type_name, "bool") or equals_c(type_name, "char") or
        equals_c(type_name, "void") or equals_c(type_name, "byte") or
        equals_c(type_name, "rchar") or equals_c(type_name, "ptrdiff");
}

/// Extract the base type name from a complex type (removing ref, list, mut, etc.)
def extract_base_type(type_name: string): string {
    mut result: string = strip(type_name);
    
    loop {
        mut changed: bool = false;
        
        if has_prefix(result, str("mut ")) {
            result = strip(substr(result, 4, str_len(result) - 4));
            changed = true;
        }
        
        if has_prefix(result, str("ref ")) {
            result = strip(substr(result, 4, str_len(result) - 4));
            changed = true;
        }
        
        if !changed {
            break;
        }
    }
    
    if has_prefix(result, str("list(")) {
        val close_paren: i32 = find_char_from(result, cast[char](41), 0);
        if close_paren > 5 {
            result = strip(substring_se(result, 5, close_paren));
            return extract_base_type(result);
        }
    }
    
    val br_idx: i32 = find_char_from(result, '[', 0);
    if br_idx > 0 {
        result = strip(substring_se(result, 0, br_idx));
    }
    
    loop {
        if has_suffix(result, str("*")) {
            result = strip(substring_se(result, 0, str_len(result) - 1));
        } else {
            break;
        }
    }
    
    return result;
}

/// Check if a type is a language keyword (not a user-defined type)
[inline]
def is_language_keyword(name: string): bool {
    if equals_c(name, "union") or equals_c(name, "generic") {
        return true;
    }
    if equals_c(name, "untyped") {
        return true;
    }
    return false;
}

/// Check if a string is all uppercase letters or underscores (constant naming convention)
def is_all_upper_or_underscore(name: string): bool {
    if str_len(name) == 0 {
        return false;
    }
    
    mut i: i32 = 0;
    val n: i32 = str_len(name);
    loop {
        if i >= n {
            break;
        }
        val ch: char = get_char(name, i);
        if !((ch >= 'A' and ch <= 'Z') or (ch >= '0' and ch <= '9') or ch == '_') {
            return false;
        }
        i++;
    }
    return true;
}

/// Check if a name is a C standard constant
[inline]
def is_c_constant(name: string): bool {
    return equals_c(name, "NULL") or equals_c(name, "TRUE") or equals_c(name, "FALSE")
        or equals_c(name, "EOF") or equals_c(name, "SEEK_SET") or equals_c(name, "SEEK_CUR") or equals_c(name, "SEEK_END")
        or has_prefix(name, str("STDIN")) or has_prefix(name, str("STDOUT")) or has_prefix(name, str("STDERR"))
        or has_prefix(name, str("INT_")) or has_prefix(name, str("UINT_")) or has_prefix(name, str("SIZE_"))
        or has_prefix(name, str("PATH_")) or has_prefix(name, str("NAME_"))
        or has_prefix(name, str("S_IS")) or has_prefix(name, str("_S_IF")) or has_prefix(name, str("_A_"))
        or has_prefix(name, str("WEXITSTATUS")) or equals_c(name, "RAND_MAX");
}

/// Check if a function name is a built-in function or C stdlib function
[inline]
def is_builtin_function(name: string): bool {
    return equals_c(name, "append") or equals_c(name, "len")
        or equals_c(name, "assert") or equals_c(name, "cast")
        or equals_c(name, "deref") or equals_c(name, "addr")
        or equals_c(name, "sizeof") or equals_c(name, "malloc") or equals_c(name, "free")
        or equals_c(name, "memcpy") or equals_c(name, "memset") or equals_c(name, "memmove")
        or equals_c(name, "strlen") or equals_c(name, "strcmp") or equals_c(name, "strcpy")
        or equals_c(name, "printf") or equals_c(name, "sprintf") or equals_c(name, "fprintf")
        or equals_c(name, "fopen") or equals_c(name, "fclose") or equals_c(name, "fread") or equals_c(name, "fwrite")
        or equals_c(name, "exit") or equals_c(name, "abort") or equals_c(name, "atexit")
        or (name.len >= 2 and name.data[0] == 'C' and name.data[1] == '.');
}

/// Check if a symbol is valid (either builtin, imported, or a known model/enum)
def is_valid_symbol(symbol_name: string): bool {
    if str_len(symbol_name) == 0 {
        return true;
    }
    
    if is_builtin_type(symbol_name) {
        return true;
    }
    
    if is_language_keyword(symbol_name) {
        return true;
    }
    
    if StringBoolMap.contains(addr(g_opaque_types), symbol_name) {
        return true;
    }
    
    if StringBoolMap.contains(addr(g_foreign_types), symbol_name) {
        return true;
    }
    
    if is_symbol_imported(symbol_name) {
        return true;
    }
    
    if StringStringMap.contains(addr(g_model_names), symbol_name) {
        return true;
    }
    
    if StringBoolMap.contains(addr(g_enum_names), symbol_name) {
        return true;
    }
    
    return false;
}

/// Validate that a type is properly imported (call this for user-facing types)
def validate_type_imported(type_name: string) {
    if str_len(type_name) == 0 {
        return;
    }
    
    val base_type: string = extract_base_type(type_name);
    
    if str_len(base_type) == 0 {
        return;
    }
    
    if !is_valid_symbol(base_type) {
        print(get_short_filename(g_current_source_file));
        print ":";
        print(i32_to_string(g_current_line));
        print ": error: undefined symbol: ";
        print base_type;
        println ", perhaps missing 'use' statement?";
        unsafe {
            C.exit(1);
        }
    }
}

/// Register a function's parameter types for later validation
def register_function_signature(func_name: string, params: ref list(string), ret_type: string, arena: ref Arena) {
    if str_len(ret_type) > 0 {
        StringStringMap.set(addr(g_function_return_types), arena, func_name, ret_type);
    } else {
        StringStringMap.set(addr(g_function_return_types), arena, func_name, str("void"));
    }

    if params == nil {
        StringStringMap.set(addr(g_function_param_types), arena, func_name, str(""));
        return;
    }
    
    mut sb_types: StringBuilder = StringBuilder.init(256);
    mut i: i32 = 0;
    loop {
        if i >= len(deref(params)) {
            break;
        }
        val param: string = params.data[i];
        
        if equals_c(param, "...") {
            if i > 0 {
                StringBuilder.append_c(addr(sb_types), ",");
            }
            StringBuilder.append_c(addr(sb_types), "...");
        } else {
            val colon_pos: i32 = find_char_from(param, ':', 0);
            if colon_pos >= 0 {
                val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                if i > 0 {
                    StringBuilder.append_c(addr(sb_types), ",");
                }
                StringBuilder.append(addr(sb_types), param_type);
            }
        }
        i++;
    }
    val types_str: string = StringBuilder.to_string(addr(sb_types));
    StringBuilder.destroy(addr(sb_types));
    StringStringMap.set(addr(g_function_param_types), arena, func_name, types_str);
}

/// Infer the type of an expression (simplified type inference, non-recursive)
def infer_expression_type(expr: string): string {
    val trimmed: string = strip(expr);
    
    if str_len(trimmed) == 0 {
        return str("void");
    }
    
    // String literal
    if has_prefix(trimmed, str("\"")) and has_suffix(trimmed, str("\"")) {
        return str("ref char");
    }
    
    // Character literal
    if has_prefix(trimmed, str("'")) and has_suffix(trimmed, str("'")) {
        return str("char");
    }
    
    // Numeric literal - check for decimal point for float
    val first_char: char = get_char(trimmed, 0);
    if (first_char >= '0' and first_char <= '9') or first_char == '-' {
        if find_char_from(trimmed, '.', 0) >= 0 {
            return str("f64");
        }
        return str("i32");
    }
    
    // Boolean literals
    if equals_c(trimmed, "true") or equals_c(trimmed, "false") {
        return str("bool");
    }
    
    // nil literal
    if equals_c(trimmed, "nil") {
        return str("ref void");
    }
    
    // Variable reference - look up in g_var_types
    if StringStringMap.contains(addr(g_var_types), trimmed) {
        return StringStringMap.get(addr(g_var_types), trimmed);
    }

    // Function call
    val paren_idx: i32 = find_char_from(trimmed, '(', 0);
    if paren_idx > 0 and has_suffix(trimmed, str(")")) {
        val func_name: string = strip(substring_se(trimmed, 0, paren_idx));
        val args_start: i32 = paren_idx + 1;
        val args_end: i32 = str_len(trimmed) - 1;
        if args_end > args_start {
            val args_str: string = strip(substring_se(trimmed, args_start, args_end));
            validate_function_call(func_name, args_str, 0);
        } else {
            validate_function_call(func_name, str(""), 0);
        }

        mut lookup_name: string = func_name;
        if StringStringMap.contains(addr(g_function_prefixes), func_name) {
            lookup_name = StringStringMap.get(addr(g_function_prefixes), func_name);
        }
        
        if StringStringMap.contains(addr(g_function_return_types), lookup_name) {
            return StringStringMap.get(addr(g_function_return_types), lookup_name);
        }
        
        if equals_c(func_name, "len") { return str("i32"); }
        if equals_c(func_name, "sizeof") { return str("usize"); }
    }
    
    return str("");
}

/// Validate a function call's arguments against its signature
def validate_function_call(func_name: string, args_str: string, depth: i32) {
    // Prevent infinite recursion
    if depth > 10 {
        return;
    }

    // Skip validation for builtin functions as they are polymorphic or handled specially
    if is_builtin_function(func_name) {
        return;
    }
    
    mut arg_list: list(string);
    mut sb_arg: StringBuilder = StringBuilder.init(256);
    mut paren_depth: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    mut i: i32 = 0;
    val args_len: i32 = cast[i32](str_len(args_str));

    loop {
        if i >= args_len {
            break;
        }
        val ch: char = get_char(args_str, i);
        
        if ch == '\'' and !in_string and !is_escaped_quote(args_str, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb_arg), ch);
        } elif ch == '\"' and !in_char_literal and !is_escaped_quote(args_str, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb_arg), ch);
        } elif !in_string and !in_char_literal {
            if ch == '(' {
                paren_depth = paren_depth + 1;
                StringBuilder.append_char(addr(sb_arg), ch);
            } elif ch == ')' {
                paren_depth = paren_depth - 1;
                StringBuilder.append_char(addr(sb_arg), ch);
            } elif ch == ',' and paren_depth == 0 {
                val built_arg: string = StringBuilder.to_string(addr(sb_arg));
                append(arg_list, strip(built_arg));
                sb_arg = StringBuilder.init(256);
            } else {
                StringBuilder.append_char(addr(sb_arg), ch);
            }
        } else {
            StringBuilder.append_char(addr(sb_arg), ch);
        }
        i++;
    }

    val final_arg: string = StringBuilder.to_string(addr(sb_arg));
    if str_len(strip(final_arg)) > 0 {
        append(arg_list, strip(final_arg));
    }

    mut arg_idx_nested: i32 = 0;
    loop {
        if arg_idx_nested >= len(arg_list) {
            break;
        }
        val arg_expr: string = arg_list.data[arg_idx_nested];
        
        // First check if this argument itself is a function call
        val arg_paren: i32 = find_char_from(arg_expr, '(', 0);
        if arg_paren > 0 {
            val nested_func: string = strip(substring_se(arg_expr, 0, arg_paren));
            val nested_args_start: i32 = arg_paren + 1;
            val nested_args_end: i32 = str_len(arg_expr) - 1;
            if nested_args_end > nested_args_start {
                val nested_args: string = strip(substring_se(arg_expr, nested_args_start, nested_args_end));
                validate_function_call(nested_func, nested_args, depth + 1);
            }
        }
        arg_idx_nested++;
    }

    mut lookup_name: string = func_name;
    if StringStringMap.contains(addr(g_function_prefixes), func_name) {
        lookup_name = StringStringMap.get(addr(g_function_prefixes), func_name);
    }
    
    if !StringStringMap.contains(addr(g_function_param_types), lookup_name) {
        return;
    }
    
    val expected_types_str: string = StringStringMap.get(addr(g_function_param_types), lookup_name);
    if str_len(expected_types_str) == 0 {
        if len(arg_list) > 0 {
             print(get_short_filename(g_current_source_file));
             print ":";
             print(i32_to_string(g_current_line));
             print ": error: function '";
             print func_name;
             print "' expects 0 argument(s), but ";
             print(i32_to_string(len(arg_list)));
             println " were provided";
             unsafe {
                 C.exit(1);
             }
        }
        return;
    }
    
    mut expected_types: list(string);
    mut sb_type: StringBuilder = StringBuilder.init(128);
    mut j: usize = 0;
    loop {
        if j >= str_len(expected_types_str) {
            break;
        }
        val ch2: char = get_char(expected_types_str, j);
        if ch2 == ',' {
            val built_type: string = StringBuilder.to_string(addr(sb_type));
            if str_len(strip(built_type)) > 0 {
                append(expected_types, strip(built_type));
            }
            sb_type = StringBuilder.init(128);
        } else {
            StringBuilder.append_char(addr(sb_type), ch2);
        }
        j++;
    }

    val final_type: string = StringBuilder.to_string(addr(sb_type));
    if str_len(strip(final_type)) > 0 {
        append(expected_types, strip(final_type));
    }
    
    mut is_variadic: bool = false;
    if len(expected_types) > 0 {
        val last_type: string = expected_types.data[len(expected_types) - 1];
        if equals_c(last_type, "...") {
            is_variadic = true;
        }
    }
    
    mut arg_count_ok: bool = false;
    if is_variadic {
        if len(arg_list) >= len(expected_types) - 1 {
            arg_count_ok = true;
        }
    } else {
        if len(arg_list) == len(expected_types) {
            arg_count_ok = true;
        }
    }
    
    if !arg_count_ok {
        print(get_short_filename(g_current_source_file));
        print ":";
        print(i32_to_string(g_current_line));
        print ": error: function '";
        print func_name;
        if is_variadic {
            print "' expects at least ";
            print(i32_to_string(len(expected_types) - 1));
        } else {
            print "' expects ";
            print(i32_to_string(len(expected_types)));
        }
        print " argument(s), but ";
        print(i32_to_string(len(arg_list)));
        println " were provided";
        unsafe {
            C.exit(1);
        }
    }
    
    mut arg_idx: i32 = 0;

    loop {
        if arg_idx >= len(arg_list) {
            break;
        }
        
        if is_variadic and arg_idx >= len(expected_types) - 1 {
            arg_idx = arg_idx + 1;
            continue;
        }

        val arg_expr: string = arg_list.data[arg_idx];
        val inferred_type: string = infer_expression_type(arg_expr);
        val expected_type: string = expected_types.data[arg_idx];
        
        if equals_c(expected_type, "...") {
            arg_idx = arg_idx + 1;
            continue;
        }
        
        val mapped_inferred: string = map_axe_type_to_c(inferred_type);
        val mapped_expected: string = map_axe_type_to_c(expected_type);
        
        if !StringBoolMap.contains(addr(g_extern_functions), func_name) {
            if str_len(inferred_type) > 0 and !equals_c(inferred_type, "auto") and compare(mapped_inferred, mapped_expected) != 0 {
                print(get_short_filename(g_current_source_file));
                print ":";
                print(i32_to_string(g_current_line));
                print ": error: type mismatch in call to '";
                print func_name;
                print "': argument ";
                print(i32_to_string(arg_idx + 1));
                print " expects type '";
                print expected_type;
                print "' but got '";
                print inferred_type;
                println "'";
                unsafe {
                    C.exit(1);
                }
            }
        }
        arg_idx = arg_idx + 1;
    }
}

/// Recursively collect function signatures from AST
def collect_function_signatures(node: ref ASTNode, arena: ref Arena) {
    if node == nil {
        return;
    }
    
    if equals_c(node.node_type, "Function") {
        val func_name: string = node.data.function.name;
        val params: ref list(string) = node.data.function.params;
        val ret_type: string = node.data.function.return_type;
        register_function_signature(func_name, params, ret_type, arena);
    }
    
    if equals_c(node.node_type, "Extern") {
        val func_name: string = node.data.extern_node.function_name;
        val params: ref list(string) = node.data.extern_node.params;
        val ret_type: string = node.data.extern_node.return_type;
        register_function_signature(func_name, params, ret_type, arena);
        StringBoolMap.set(addr(g_extern_functions), arena, func_name, true);
    }
    
    if node.children != nil {
        val children: ref list(ASTNode) = node.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            collect_function_signatures(addr(children.data[i]), arena);
            i++;
        }
    }
}

/// Collect foreign types from Foreign nodes before processing functions
def collect_foreign_types(node: ref ASTNode) {
    if node == nil {
        return;
    }
    
    if equals_c(node.node_type, "Foreign") {
        val fnames: ref list(string) = node.data.foreign_node.type_names;
        if fnames != nil {
            mut arena_foreign: Arena = Arena.create(2560);
            mut fi: i32 = 0;
            loop {
                if fi >= len(deref(fnames)) {
                    break;
                }
                val type_name: string = fnames.data[fi];
                StringBoolMap.set(addr(g_foreign_types), addr(arena_foreign), type_name, true);
                fi++;
            }
        }
    }
    
    if node.children != nil {
        val children: ref list(ASTNode) = node.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            collect_foreign_types(addr(children.data[i]));
            i++;
        }
    }
}

/// Build the g_function_param_types map from the AST
def build_function_signatures(ast: ref ASTNode) {
    mut arena: Arena = Arena.create(1024 * 1024);
    collect_function_signatures(ast, addr(arena));
}

/// Collect external imports from AST recursively.
/// current_platform is "" for global, "windows" or "posix" for platform-specific.
def collect_external_imports(node: ref ASTNode, current_platform: string, arena: ref Arena) {
    if node == nil {
        return;
    }
    
    if equals_c(node.node_type, "ExternalImport") {
        val header: string = node.data.external_import.header_file;
        
        if equals_c(current_platform, "") {
            if !StringList.contains(g_global_external_headers, header) {
                StringList.push(g_global_external_headers, arena, header);
            }
        } elif equals_c(current_platform, "windows") {
            if !StringList.contains(g_windows_external_headers, header) {
                StringList.push(g_windows_external_headers, arena, header);
            }
        } elif equals_c(current_platform, "posix") {
            if !StringList.contains(g_posix_external_headers, header) {
                StringList.push(g_posix_external_headers, arena, header);
            }
        }
        return;
    }
    
    if equals_c(node.node_type, "Platform") {
        val platform_name: string = node.data.platform_node.platform_name;
        // Recurse into platform children with platform context
        if node.children != nil {
            val children: ref list(ASTNode) = node.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                collect_external_imports(addr(children.data[i]), platform_name, arena);
                i++;
            }
        }
        return;
    }
    
    // Recurse into all children with current platform context
    if node.children != nil {
        val children: ref list(ASTNode) = node.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            collect_external_imports(addr(children.data[i]), current_platform, arena);
            i++;
        }
    }
}

/// Extract the base type name from a field type string.
/// For example: "ref string" -> "string", "i32*" -> "i32", "list(Token)" -> "Token"
def get_base_type_from_field(field_type: string): string {
    mut t: string = strip(field_type);
    
    if has_prefix(t, str("mut ")) {
        t = strip(substr(t, 4, str_len(t) - 4));
    }
    
    loop {
        if !has_prefix(t, str("ref ")) {
            break;
        }
        t = strip(substr(t, 4, str_len(t) - 4));
    }
    
    loop {
        if !has_prefix(t, str("& ")) {
            break;
        }
        t = strip(substr(t, 2, str_len(t) - 2));
    }
    
    if has_prefix(t, str("list(")) {
        mut paren_pos: i32 = 5;
        mut depth: i32 = 1;
        loop {
            if paren_pos >= str_len(t) {
                break;
            }
            val ch: char = get_char(t, paren_pos);
            if ch == '(' {
                depth = depth + 1;
            } elif ch == ')' {
                depth = depth - 1;
                if depth == 0 {
                    break;
                }
            }
            paren_pos = paren_pos + 1;
        }
        t = strip(substr(t, 5, paren_pos - 5));
    }
    
    val bracket_pos: i32 = find_substr(t, str("["));

    if bracket_pos >= 0 {
        t = strip(substr(t, 0, bracket_pos));
    }
    
    loop {
        if str_len(t) == 0 {
            break;
        }
        if get_char(t, str_len(t) - 1) != '*' {
            break;
        }
        t = strip(substr(t, 0, str_len(t) - 1));
    }
    
    return t;
}

/// Remove stray spaces around '.' in numeric C literals.
def normalize_numeric_dots(s: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(s) + 16);
    val n: i32 = cast[i32](str_len(s));
    mut i: i32 = 0;

    loop {
        if i >= n {
            break;
        }

        val ch: char = get_char(s, i);

        if ch >= '0' and ch <= '9' and i + 1 < n and get_char(s, i + 1) == '.' {
            StringBuilder.append_char(addr(sb), ch);
            StringBuilder.append_char(addr(sb), '.');

            mut j: i32 = i + 2;
            loop {
                if j >= n {
                    break;
                }
                val cj: char = get_char(s, j);
                if cj != ' ' and cj != '\t' and cj != '\n' {
                    break;
                }
                j++;
            }

            if j < n and get_char(s, j) >= '0' and get_char(s, j) <= '9' {
                StringBuilder.append_char(addr(sb), get_char(s, j));
                i = j + 1;
                continue;
            } else {
                i = j;
                continue;
            }
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Check if a quote character at position `pos` is escaped by counting
/// consecutive backslashes before it. Returns true if odd number of backslashes
/// (meaning the quote is escaped), false if even number (quote is real delimiter).
def is_escaped_quote(expr: string, pos: i32): bool {
    mut backslash_count: i32 = 0;
    mut j: i32 = pos - 1;
    loop {
        if j < 0 {
            break;
        }
        if get_char(expr, j) != '\\' {
            break;
        }
        backslash_count = backslash_count + 1;
        j = j - 1;
    }
    // Odd number of backslashes means the quote is escaped
    return (backslash_count mod 2) == 1;
}

/// Replace a keyword with another string, but only when it's a standalone word
/// (not part of a larger identifier) and not inside a string literal.
def replace_keyword_outside_strings(expr: string, keyword: string, replacement: string): string {
    val expr_len: i32 = str_len(expr);
    val kw_len: i32 = str_len(keyword);
    if expr_len == 0 or kw_len == 0 {
        return expr;
    }
    
    mut sb: StringBuilder = StringBuilder.init(cast[usize](expr_len + 32));
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    mut i: i32 = 0;
    
    loop {
        if i >= expr_len {
            break;
        }
        
        val ch: char = get_char(expr, i);
        
        if ch == '\'' and !in_string and !is_escaped_quote(expr, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }
        
        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }
        
        if in_string or in_char_literal {
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }
        
        mut matches: bool = true;
        if i + kw_len > expr_len {
            matches = false;
        } else {
            mut ki: i32 = 0;
            loop {
                if ki >= kw_len {
                    break;
                }
                if get_char(expr, i + ki) != get_char(keyword, ki) {
                    matches = false;
                    break;
                }
                ki = ki + 1;
            }
        }
        
        if matches {
            mut is_word: bool = true;
            
            if i > 0 {
                val prev: char = get_char(expr, i - 1);
                val prev_is_alpha_lower: bool = prev >= 'a' and prev <= 'z';
                val prev_is_alpha_upper: bool = prev >= 'A' and prev <= 'Z';
                val prev_is_digit: bool = prev >= '0' and prev <= '9';
                val prev_is_underscore: bool = prev == '_';
                if prev_is_alpha_lower or prev_is_alpha_upper or prev_is_digit or prev_is_underscore {
                    is_word = false;
                }
            }
            
            if is_word and i + kw_len < expr_len {
                val next: char = get_char(expr, i + kw_len);
                val next_is_alpha_lower: bool = next >= 'a' and next <= 'z';
                val next_is_alpha_upper: bool = next >= 'A' and next <= 'Z';
                val next_is_digit: bool = next >= '0' and next <= '9';
                val next_is_underscore: bool = next == '_';
                if next_is_alpha_lower or next_is_alpha_upper or next_is_digit or next_is_underscore {
                    is_word = false;
                }
            }
            
            if is_word {
                if i > 0 {
                    val prev_ch: char = get_char(expr, i - 1);
                    if prev_ch != ' ' {
                        StringBuilder.append_char(addr(sb), ' ');
                    }
                }
                StringBuilder.append(addr(sb), replacement);
                if i + kw_len < expr_len {
                    val next_ch: char = get_char(expr, i + kw_len);
                    if next_ch != ' ' {
                        StringBuilder.append_char(addr(sb), ' ');
                    }
                }
                i = i + kw_len;
                continue;
            }
        }
        
        StringBuilder.append_char(addr(sb), ch);
        i++;
    }
    
    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite member access on pointer-typed variables...
def rewrite_pointer_member_accesses(expr: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(expr) + 64);
    mut i: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val expr_len: i32 = cast[i32](str_len(expr));

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '\'' and !in_string and !is_escaped_quote(expr, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if !in_string and !in_char_literal and is_ident_start(ch) {
            val base_start: i32 = i;
            mut j: i32 = i;
            loop {
                if j >= expr_len {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                j++;
            }

            val base: string = substring_se(expr, base_start, j);
            mut k: i32 = j;

            loop {
                if k >= expr_len {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k++;
            }

            if k < expr_len and get_char(expr, k) == '.' {
                val start_slice: i32 = i;

                mut p: i32 = k + 1;
                loop {
                    if p >= expr_len {
                        break;
                    }
                    val ws2: char = get_char(expr, p);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    p++;
                }

                val member_start: i32 = p;
                mut m: i32 = p;
                if m < expr_len and is_ident_start(get_char(expr, m)) {
                    loop {
                        if m >= expr_len {
                            break;
                        }
                        val cm: char = get_char(expr, m);
                        if !is_token_char(cm) {
                            break;
                        }
                        m++;
                    }
                }
                val member: string = substring_se(expr, member_start, m);

                if str_len(member) > 0 {
                    val trimmed_base: string = strip(base);
                    mut is_pointer: bool = false;

                    if StringStringMap.contains(addr(g_var_types), trimmed_base) {
                        val raw_type: string = StringStringMap.get(addr(g_var_types), trimmed_base);
                        mut t: string = strip(raw_type);

                        if has_prefix(t, str("mut ")) {
                            t = strip(substr(t, 4, str_len(t) - 4));
                        }

                        if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                            is_pointer = true;
                        }
                    }

                    if is_pointer {
                        StringBuilder.append(addr(sb), trimmed_base);
                        StringBuilder.append_c(addr(sb), "->");
                        StringBuilder.append(addr(sb), member);
                        i = m;
                        continue;
                    }

                    // Not a pointer: fall through and emit original slice
                    val original: string = substring_se(expr, start_slice, m);
                    StringBuilder.append(addr(sb), original);
                    i = m;
                    continue;
                }
            }

            // Not a member access; emit the identifier as-is
            StringBuilder.append(addr(sb), base);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Register a single function name in g_function_prefixes
def register_function_prefix(full_name: string) {
    mut last_sep: i32 = -1;
    mut j: i32 = 0;
    val n: i32 = str_len(full_name);
    loop {
        if j + 1 >= n {
            break;
        }
        val c1: char = get_char(full_name, j);
        val c2: char = get_char(full_name, j + 1);
        if c1 == '_' and c2 == '_' {
            last_sep = j;
        }
        j++;
    }

    if last_sep >= 0 and last_sep + 2 < n {
        val short_name: string = substring_se(full_name, last_sep + 2, n);

        if str_len(short_name) > 0 {
            if !StringStringMap.contains(addr(g_function_prefixes), short_name) {
                mut arena: Arena = Arena.create(1256);
                StringStringMap.set(addr(g_function_prefixes), addr(arena), short_name, full_name);
            }
        }
        
        mut second_last_sep: i32 = -1;
        mut k: i32 = 0;
        loop {
            if k >= last_sep {
                break;
            }
            val c1b: char = get_char(full_name, k);
            val c2b: char = get_char(full_name, k + 1);
            if c1b == '_' and c2b == '_' {
                second_last_sep = k;
            }
            k++;
        }
        
        if second_last_sep >= 0 and second_last_sep + 2 < n {
            val partial_name: string = substring_se(full_name, second_last_sep + 2, n);
            if str_len(partial_name) > 0 {
                if !StringStringMap.contains(addr(g_function_prefixes), partial_name) {
                    mut arena2: Arena = Arena.create(1256);
                    StringStringMap.set(addr(g_function_prefixes), addr(arena2), partial_name, full_name);
                }
            }
        }
    }
}

/// Recursively collect function prefixes from an AST node
def collect_function_prefixes(node: ref ASTNode) {
    if node == nil {
        return;
    }
    
    if equals_c(node.node_type, "Function") {
        register_function_prefix(node.data.function.name);
    }
    
    if equals_c(node.node_type, "Overload") {
        register_function_prefix(node.data.overload_node.name);
    }
    
    if node.children != nil {
        val children: ref list(ASTNode) = node.children;
        mut i: i32 = 0;
        loop {
            if i >= len(deref(children)) {
                break;
            }
            collect_function_prefixes(addr(children.data[i]));
            i++;
        }
    }
}

/// Build the g_function_prefixes map from the AST
def build_function_prefixes(ast: ref ASTNode) {
    StringStringMap.clear(addr(g_function_prefixes));
    collect_function_prefixes(ast);
}

/// Map Axe type to C type
def map_type(axe_type: string): string {
    if StringStringMap.contains(addr(g_type_mappings), axe_type) {
        return StringStringMap.get(addr(g_type_mappings), axe_type);
    }
    return axe_type;
}

/// Get canonical model C name from g_model_names
[inline]
def canonical_model_c_name(name: string): string {
    if StringStringMap.contains(addr(g_model_names), name) {
        return StringStringMap.get(addr(g_model_names), name);
    }
    return str("");
}

/// Map Axe type to C type (comprehensive version for model fields)
def map_axe_type_to_c(axe_type: string): string {
    mut result: string = axe_type;
    
    if has_prefix(result, str("mut ")) {
        result = strip(substr(result, 4, str_len(result) - 4));
        return map_axe_type_to_c(result);
    }
    
    if has_prefix(result, str("list(")) {
        val close_paren: i32 = find_char_from(result, cast[char](41), 0);
        if close_paren > 5 {
            val inner_type: string = strip(substring_se(result, 5, close_paren));
            val converted: string = concat(inner_type, str("[999]"));
            return map_axe_type_to_c(converted);
        }
    }
    
    if has_suffix(result, str("[999]")) {
        val element_type: string = strip(substring_se(result, 0, str_len(result) - 5));
        if has_prefix(element_type, str("ref ")) {
            val base_elem: string = strip(substr(element_type, 4, str_len(element_type) - 4));
            val mapped_elem: string = map_axe_type_to_c(base_elem);
            add_list_element(mapped_elem);
            mut sb_struct: StringBuilder = StringBuilder.init(str_len(mapped_elem) + 10);
            StringBuilder.append_c(addr(sb_struct), "__list_");
            StringBuilder.append(addr(sb_struct), mapped_elem);
            StringBuilder.append_c(addr(sb_struct), "_t*");
            val struct_name: string = StringBuilder.to_string(addr(sb_struct));
            StringBuilder.destroy(addr(sb_struct));
            return struct_name;
        } else {
            val mapped_elem: string = map_axe_type_to_c(element_type);
            add_list_element(mapped_elem);
            mut sb_struct: StringBuilder = StringBuilder.init(str_len(mapped_elem) + 10);
            StringBuilder.append_c(addr(sb_struct), "__list_");
            StringBuilder.append(addr(sb_struct), mapped_elem);
            StringBuilder.append_c(addr(sb_struct), "_t");
            val struct_name: string = StringBuilder.to_string(addr(sb_struct));
            StringBuilder.destroy(addr(sb_struct));
            return struct_name;
        }
    }
    
    if has_prefix(result, str("ref ")) {
        val base_type: string = strip(substr(result, 4, str_len(result) - 4));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    if has_suffix(result, str("*")) {
        val base_type: string = strip(substring_se(result, 0, str_len(result) - 1));
        val mapped_base: string = map_axe_type_to_c(base_type);
        return concat(mapped_base, str("*"));
    }
    
    val br_idx: i32 = find_char_from(result, '[', 0);
    if br_idx >= 0 and find_char_from(result, ']', br_idx) >= 0 {
        val base_raw: string = strip(substring_se(result, 0, br_idx));
        val suffix: string = substring_se(result, br_idx, str_len(result));
        if str_len(base_raw) > 0 {
            val mapped_base2: string = map_axe_type_to_c(base_raw);
            return concat(mapped_base2, suffix);
        }
    }
    
    if StringStringMap.contains(addr(g_type_mappings), result) {
        return StringStringMap.get(addr(g_type_mappings), result);
    }
    
    if StringStringMap.contains(addr(g_model_names), result) {
        return StringStringMap.get(addr(g_model_names), result);
    }
    
    return result;
}

/// Sanitize a C element type string to be used as part of a generated list type name
def sanitize_list_element_name(c_elem: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(c_elem) + 32);
    mut i: i32 = 0;
    val n_len: i32 = cast[i32](str_len(c_elem));
    loop {
        if i >= n_len {
            break;
        }
        val ch: char = get_char(c_elem, i);
        if ch == '*' {
            StringBuilder.append_c(addr(sb), "_ptr");
        } elif ch == ' ' {
            StringBuilder.append_c(addr(sb), "_");
        } else {
            StringBuilder.append_char(addr(sb), ch);
        }
        i++;
    }
    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Collapse all duplicate segments in the specified string expression.
def collapse_duplicate_segments(s: string): string {
    mut current: string = s;
    loop {
        val next: string = collapse_duplicate_segments_once(current);
        if compare(next, current) == 0 {
            return current;
        }
        current = next;
    }
}

/// Check if a type string indicates a pointer/reference type
def is_pointer_type(type_str: string): bool {
    mut t: string = strip(type_str);
    if has_prefix(t, str("mut ")) {
        t = strip(substr(t, 4, str_len(t) - 4));
    }
    if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
        return true;
    }
    return false;
}

/// Extract the base model/struct name from a type string.
/// For example: "ref ParserContext" -> "ParserContext", "list(Token)*" -> "list(Token)"
def extract_base_model_name(type_str: string): string {
    mut t: string = strip(type_str);
    if has_prefix(t, str("mut ")) {
        t = strip(substr(t, 4, str_len(t) - 4));
    }
    if has_prefix(t, str("ref ")) {
        t = strip(substr(t, 4, str_len(t) - 4));
    }
    loop {
        if str_len(t) == 0 {
            break;
        }
        if get_char(t, str_len(t) - 1) != '*' {
            break;
        }
        t = strip(substr(t, 0, str_len(t) - 1));
    }
    return t;
}

/// Look up a field's type from g_field_types by trying various model prefixes.
/// Returns the field type if found, or empty string if not found.
def lookup_field_type(model_name: string, field_name: string): string {
    mut sb_key: StringBuilder = StringBuilder.init(str_len(model_name) + str_len(field_name) + 1);
    StringBuilder.append(addr(sb_key), model_name);
    StringBuilder.append_c(addr(sb_key), ".");
    StringBuilder.append(addr(sb_key), field_name);
    val field_key: string = StringBuilder.to_string(addr(sb_key));
    StringBuilder.destroy(addr(sb_key));

    if StringStringMap.contains(addr(g_field_types), field_key) {
        return StringStringMap.get(addr(g_field_types), field_key);
    }
    
    if StringStringMap.contains(addr(g_model_names), model_name) {
        val canonical_name: string = StringStringMap.get(addr(g_model_names), model_name);
        mut sb_canon: StringBuilder = StringBuilder.init(str_len(canonical_name) + str_len(field_name) + 1);
        StringBuilder.append(addr(sb_canon), canonical_name);
        StringBuilder.append_c(addr(sb_canon), ".");
        StringBuilder.append(addr(sb_canon), field_name);
        val canon_key: string = StringBuilder.to_string(addr(sb_canon));
        StringBuilder.destroy(addr(sb_canon));
        if StringStringMap.contains(addr(g_field_types), canon_key) {
            return StringStringMap.get(addr(g_field_types), canon_key);
        }
    }
    
    if has_prefix(model_name, str("list(")) or has_prefix(model_name, str("__list_")) {
        if equals_c(field_name, "data") {
            return str("ref void");
        }
    }

    return str("");
}

/// Check if a field is a pointer type by looking it up in g_pointer_fields
def is_pointer_field(model_name: string, field_name: string): bool {
    mut sb_fkey: StringBuilder = StringBuilder.init(str_len(model_name) + str_len(field_name) + 1);
    StringBuilder.append(addr(sb_fkey), model_name);
    StringBuilder.append_c(addr(sb_fkey), ".");
    StringBuilder.append(addr(sb_fkey), field_name);
    val field_key: string = StringBuilder.to_string(addr(sb_fkey));
    StringBuilder.destroy(addr(sb_fkey));
    if StringBoolMap.contains(addr(g_pointer_fields), field_key) {
        return true;
    }
    
    if StringStringMap.contains(addr(g_model_names), model_name) {
        val canonical_name: string = StringStringMap.get(addr(g_model_names), model_name);
        mut sb_ckey: StringBuilder = StringBuilder.init(str_len(canonical_name) + str_len(field_name) + 1);
        StringBuilder.append(addr(sb_ckey), canonical_name);
        StringBuilder.append_c(addr(sb_ckey), ".");
        StringBuilder.append(addr(sb_ckey), field_name);
        val canon_key: string = StringBuilder.to_string(addr(sb_ckey));
        StringBuilder.destroy(addr(sb_ckey));
        if StringBoolMap.contains(addr(g_pointer_fields), canon_key) {
            return true;
        }
    }
    
    if has_prefix(model_name, str("list(")) or has_prefix(model_name, str("__list_")) {
        if equals_c(field_name, "data") {
            return true;
        }
    }
    return false;
}

/// Parse an identifier from expr starting at position pos.
/// Updates pos to point past the identifier.
def parse_ident_at(expr: string, pos: ref i32): string {
    val expr_len: i32 = cast[i32](str_len(expr));
    if deref(pos) >= expr_len {
        return str("");
    }
    val ch: char = get_char(expr, deref(pos));
    if !is_ident_start(ch) {
        return str("");
    }
    val start: i32 = deref(pos);
    loop {
        if deref(pos) >= expr_len {
            break;
        }
        val c: char = get_char(expr, deref(pos));
        if !is_token_char(c) {
            break;
        }
        deref(pos) = deref(pos) + 1;
    }
    return substring_se(expr, start, deref(pos));
}

/// Skip whitespace in expr starting at position pos.
def skip_ws_at(expr: string, pos: ref i32) {
    val expr_len: i32 = cast[i32](str_len(expr));
    loop {
        if deref(pos) >= expr_len {
            break;
        }
        val c: char = get_char(expr, deref(pos));
        if c != ' ' and c != '\t' and c != '\n' {
            break;
        }
        deref(pos) = deref(pos) + 1;
    }
}

/// Rewrite member access operators from `.` to `->` when the base identifier
/// is known to be a pointer type (ref or pointer) according to g_var_types.
/// Also handles nested member accesses by tracking types through the chain.
/// For example, if `ctx` has type `ref ParserContext` and `tokens` field has type `ref list(Token)`,
/// then `ctx.tokens.data` becomes `ctx->tokens->data`.
def rewrite_ref_member_access(expr: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(expr) + 64);
    mut pos: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val expr_len: i32 = cast[i32](str_len(expr));

    loop {
        if pos >= expr_len {
            break;
        }

        val ch: char = get_char(expr, pos);

        if ch == '\'' and !in_string and !is_escaped_quote(expr, pos) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            pos = pos + 1;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, pos) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            pos = pos + 1;
            continue;
        }

        if in_string or in_char_literal {
            StringBuilder.append_char(addr(sb), ch);
            pos = pos + 1;
            continue;
        }

        if is_ident_start(ch) {
            val ident: string = parse_ident_at(expr, addr(pos));
            
            mut lookahead: i32 = pos;
            skip_ws_at(expr, addr(lookahead));
            
            mut is_member_chain: bool = false;
            if lookahead < expr_len and get_char(expr, lookahead) == '.' {
                if lookahead + 1 < expr_len and get_char(expr, lookahead + 1) != '>' {
                    is_member_chain = true;
                }
            } elif lookahead + 1 < expr_len and get_char(expr, lookahead) == '-' and get_char(expr, lookahead + 1) == '>' {
                is_member_chain = true;
            }
            
            if is_member_chain {
                mut chain: string = ident;
                mut is_pointer: bool = false;
                mut current_type: string = str("");
                
                if StringStringMap.contains(addr(g_var_types), ident) {
                    current_type = StringStringMap.get(addr(g_var_types), ident);
                    if is_pointer_type(current_type) {
                        is_pointer = true;
                    }
                }
                
                mut base_model_name: string = extract_base_model_name(current_type);
                
                pos = lookahead;
                loop {
                    if pos >= expr_len {
                        break;
                    }
                    
                    skip_ws_at(expr, addr(pos));
                    
                    if pos >= expr_len {
                        break;
                    }
                    
                    mut has_dot: bool = false;
                    mut has_arrow: bool = false;
                    if get_char(expr, pos) == '.' {
                        if pos + 1 < expr_len and get_char(expr, pos + 1) == '>' {
                            break;
                        }
                        has_dot = true;
                    } elif pos + 1 < expr_len and get_char(expr, pos) == '-' and get_char(expr, pos + 1) == '>' {
                        has_arrow = true;
                    }
                    
                    if !has_dot and !has_arrow {
                        break;
                    }
                    
                    if has_arrow {
                        pos = pos + 2;
                    } else {
                        pos = pos + 1;
                    }
                    
                    skip_ws_at(expr, addr(pos));
                    
                    val field_name: string = parse_ident_at(expr, addr(pos));
                    if str_len(field_name) == 0 {
                        if has_arrow {
                            chain = concat(chain, str("->"));
                        } else {
                            if is_pointer {
                                chain = concat(chain, str("->"));
                            } else {
                                chain = concat(chain, str("."));
                            }
                        }
                        break;
                    }
                    
                    mut array_suffix: string = str("");
                    skip_ws_at(expr, addr(pos));
                    if pos < expr_len and get_char(expr, pos) == '[' {
                        val bracket_start: i32 = pos;
                        pos = pos + 1;
                        mut depth: i32 = 1;
                        loop {
                            if pos >= expr_len or depth == 0 {
                                break;
                            }
                            val bc: char = get_char(expr, pos);
                            if bc == '[' {
                                depth = depth + 1;
                            } elif bc == ']' {
                                depth = depth - 1;
                            }
                            pos = pos + 1;
                        }
                        val bracket_content: string = substring_se(expr, bracket_start + 1, pos - 1);
                        val processed_bracket: string = rewrite_ref_member_access(bracket_content);
                        array_suffix = concat(str("["), processed_bracket);
                        array_suffix = concat(array_suffix, str("]"));
                    }
                    
                    mut op: string = str(".");
                    if has_arrow {
                        op = str("->");
                    } elif is_pointer {
                        op = str("->");
                    }
                    
                    chain = concat(chain, op);
                    chain = concat(chain, field_name);
                    chain = concat(chain, array_suffix);
                    
                    val had_array_access: bool = str_len(array_suffix) > 0;
                    if had_array_access {
                        is_pointer = false;
                    }
                    
                    if str_len(base_model_name) > 0 {
                        val field_type: string = lookup_field_type(base_model_name, field_name);
                        if str_len(field_type) > 0 {
                            if is_pointer_type(field_type) {
                                if !had_array_access {
                                    is_pointer = true;
                                }
                            } else {
                                is_pointer = false;
                            }
                            base_model_name = extract_base_model_name(field_type);
                        } elif is_pointer_field(base_model_name, field_name) {
                            if !had_array_access {
                                is_pointer = true;
                            }
                            base_model_name = str("");
                        } else {
                            if !had_array_access {
                                if equals_c(field_name, "keys") or equals_c(field_name, "values") or 
                                   equals_c(field_name, "data") or equals_c(field_name, "items") or
                                   equals_c(field_name, "elements") or equals_c(field_name, "children") or
                                   equals_c(field_name, "params") or equals_c(field_name, "body") {
                                    is_pointer = true;
                                } else {
                                    is_pointer = false;
                                }
                            }
                            base_model_name = str("");
                        }
                    } else {
                        if !had_array_access {
                            if equals_c(field_name, "keys") or equals_c(field_name, "values") or 
                               equals_c(field_name, "data") or equals_c(field_name, "items") or
                               equals_c(field_name, "elements") or equals_c(field_name, "children") or
                               equals_c(field_name, "params") or equals_c(field_name, "body") {
                                is_pointer = true;
                            } else {
                                is_pointer = false;
                            }
                        }
                    }
                }
                
                StringBuilder.append(addr(sb), chain);
                continue;
            }
            
            // Not a member access chain, just output the identifier
            StringBuilder.append(addr(sb), ident);
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        pos = pos + 1;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite method-style calls of the form `Base.method(...)` into a single
/// C identifier using the canonical model name when available. 
/// 
/// For example:
///
///   Arena.alloc_array(arena, ...)
///
/// Becomes:
///
///   std__arena__Arena_Arena__alloc_array(arena, ...)
def rewrite_method_calls(expr: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(expr) + 128);
    mut i: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val expr_len: i32 = cast[i32](str_len(expr));

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '\'' and !in_string and !is_escaped_quote(expr, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if !in_string and !in_char_literal and is_ident_start(ch) {
            val base_start: i32 = i;
            mut j: i32 = i;
            loop {
                if j >= expr_len {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                j = j + 1;
            }
            val base: string = substring_se(expr, base_start, j);

            mut k: i32 = j;
            loop {
                if k >= expr_len {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }

            if k < expr_len and get_char(expr, k) == '.' {
                k = k + 1;

                loop {
                    if k >= expr_len {
                        break;
                    }
                    val ws2: char = get_char(expr, k);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                val method_start: i32 = k;
                mut m: i32 = k;
                if m < expr_len and is_ident_start(get_char(expr, m)) {
                    loop {
                        if m >= expr_len {
                            break;
                        }
                        val cm: char = get_char(expr, m);
                        if !is_token_char(cm) {
                            break;
                        }
                        m = m + 1;
                    }
                }
                val method: string = substring_se(expr, method_start, m);

                mut p: i32 = m;
                loop {
                    if p >= expr_len {
                        break;
                    }
                    val ws3: char = get_char(expr, p);
                    if ws3 != ' ' and ws3 != '\t' and ws3 != '\n' {
                        break;
                    }
                    p = p + 1;
                }

                if str_len(method) > 0 and p < expr_len and get_char(expr, p) == '(' {
                    mut fixed_method: string = method;
                    mut inner_sep: i32 = -1;
                    mut mi: i32 = 0;
                    val mlen: i32 = cast[i32](str_len(method));
                    loop {
                        if mi + 1 >= mlen {
                            break;
                        }
                        val mc1: char = get_char(method, mi);
                        val mc2: char = get_char(method, mi + 1);
                        if mc1 == '_' and mc2 == '_' {
                            inner_sep = mi;
                            break;
                        }
                        mi++;
                    }

                    if inner_sep > 0 {
                        val inner_model: string = substring_se(method, 0, inner_sep);
                        mut base_tail: string = base;
                        mut bsep: i32 = -1;
                        mut bi: i32 = 0;
                        val blen: i32 = cast[i32](str_len(base));

                        loop {
                            if bi + 1 >= blen {
                                break;
                            }
                            val bc1: char = get_char(base, bi);
                            val bc2: char = get_char(base, bi + 1);
                            if bc1 == '_' and bc2 == '_' {
                                bsep = bi;
                            }
                            bi = bi + 1;
                        }
                        if bsep >= 0 and bsep + 2 < blen {
                            base_tail = substring_se(base, bsep + 2, blen);
                        }

                        if compare(inner_model, base) == 0 or compare(inner_model, base_tail) == 0 {
                            fixed_method = substring_se(method, inner_sep + 2, mlen);
                        }
                    }

                    val canon: string = canonical_model_c_name(base);
                    mut full_name: string = str("");
                    if str_len(canon) > 0 {
                        full_name = canon;
                    } else {
                        full_name = base;
                    }
                    full_name = concat(full_name, str("__"));
                    full_name = concat(full_name, fixed_method);
                    StringBuilder.append(addr(sb), full_name);
                    i = m;
                    continue;
                }
            }

            StringBuilder.append(addr(sb), base);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite function calls to use their full module-prefixed names.
/// For example, `Arena__alloc(...)` becomes `std__arena__Arena__alloc(...)`
/// using the g_function_prefixes map.
def rewrite_function_prefixes(expr: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(expr) + 128);
    mut i: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val expr_len: i32 = cast[i32](str_len(expr));

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '\'' and !in_string and !is_escaped_quote(expr, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        val is_start: bool = is_ident_start(ch);

        if !in_string and !in_char_literal and is_start {
            val func_start: i32 = i;
            mut j: i32 = i;
            loop {
                if j >= expr_len {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                j++;
            }
            val func_name: string = substring_se(expr, func_start, j);

            mut k: i32 = j;
            loop {
                if k >= expr_len {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k++;
            }

            if k < expr_len and get_char(expr, k) == '[' {
                mut bracket_end: i32 = k + 1;
                loop {
                    if bracket_end >= expr_len {
                        break;
                    }
                    if get_char(expr, bracket_end) == ']' {
                        break;
                    }
                    bracket_end++;
                }
                
                if bracket_end < expr_len {
                    val type_arg: string = strip(substring_se(expr, k + 1, bracket_end));
                    mut m: i32 = bracket_end + 1;
                    loop {
                        if m >= expr_len {
                            break;
                        }
                        val wm: char = get_char(expr, m);
                        if wm != ' ' and wm != '\t' and wm != '\n' {
                            break;
                        }
                        m++;
                    }
                    
                    if m < expr_len and get_char(expr, m) == '(' {
                        mut sb_call: StringBuilder = StringBuilder.init(str_len(func_name) + str_len(type_arg) + 4);
                        StringBuilder.append(addr(sb_call), func_name);
                        StringBuilder.append_c(addr(sb_call), "[");
                        StringBuilder.append(addr(sb_call), type_arg);
                        StringBuilder.append_c(addr(sb_call), "]");
                        val call_key: string = StringBuilder.to_string(addr(sb_call));
                        StringBuilder.destroy(addr(sb_call));
                        
                        if StringStringMap.contains(addr(g_function_prefixes), call_key) {
                            val mangled: string = StringStringMap.get(addr(g_function_prefixes), call_key);
                            StringBuilder.append(addr(sb), mangled);
                            i = m;
                            continue;
                        }
                        
                        mut sb_mangle: StringBuilder = StringBuilder.init(str_len(func_name) + str_len(type_arg) + 8);
                        StringBuilder.append(addr(sb_mangle), func_name);
                        StringBuilder.append_c(addr(sb_mangle), "__T_");
                        StringBuilder.append(addr(sb_mangle), type_arg);
                        val mangled_fallback: string = StringBuilder.to_string(addr(sb_mangle));
                        StringBuilder.destroy(addr(sb_mangle));
                        
                        StringBuilder.append(addr(sb), mangled_fallback);
                        i = m;
                        continue;
                    }
                }
            }

            if k < expr_len and get_char(expr, k) == '(' {
                val has_double_underscore: bool = find_substr(func_name, str("__")) >= 0;
                if has_double_underscore {
                    StringBuilder.append(addr(sb), func_name);
                    i = j;
                    continue;
                }
                
                if StringStringMap.contains(addr(g_function_prefixes), func_name) {
                    val full_name: string = StringStringMap.get(addr(g_function_prefixes), func_name);
                    StringBuilder.append(addr(sb), full_name);
                    i = j;
                    continue;
                }
            }

            StringBuilder.append(addr(sb), func_name);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite sizeof argument types so that constructs like `sizeof(IntList)`
/// or `sizeof ( i32 )` use the mapped C type (e.g. `sizeof(std__lists__IntList)`.
def rewrite_sizeof_types(expr: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(expr) + 64);
    mut i: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val expr_len: i32 = cast[i32](str_len(expr));

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '\'' and !in_string and !is_escaped_quote(expr, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if !in_string and !in_char_literal and is_ident_start(ch) {
            val ident_start: i32 = i;
            mut j: i32 = i;
            loop {
                if j >= expr_len {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                j++;
            }
            val ident: string = substring_se(expr, ident_start, j);
            mut is_sizeof: bool = false;

            if str_len(ident) == 6 and get_char(ident, 0) == 's' and get_char(ident, 1) == 'i' 
                and get_char(ident, 2) == 'z' and get_char(ident, 3) == 'e' and get_char(ident, 4) == 'o' 
                and get_char(ident, 5) == 'f' {
                is_sizeof = true;
            } elif str_len(ident) == 9 and get_char(ident, 0) == 'C' and get_char(ident, 1) == '_'
                and get_char(ident, 2) == '_' and get_char(ident, 3) == 's' and get_char(ident, 4) == 'i'
                and get_char(ident, 5) == 'z' and get_char(ident, 6) == 'e' and get_char(ident, 7) == 'o'
                and get_char(ident, 8) == 'f' {
                is_sizeof = true;
            }

            if is_sizeof {
                StringBuilder.append_c(addr(sb), "sizeof");

                mut k: i32 = j;
                loop {
                    if k >= expr_len {
                        break;
                    }
                    val ws: char = get_char(expr, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k++;
                }

                if k < expr_len and get_char(expr, k) == '(' {
                    StringBuilder.append_char(addr(sb), '(');
                    k++;

                    mut start_type: i32 = k;
                    loop {
                        if start_type >= expr_len {
                            break;
                        }
                        val ws2: char = get_char(expr, start_type);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        start_type = start_type + 1;
                    }

                    mut end_type: i32 = start_type;
                    mut paren_depth: i32 = 0;
                    loop {
                        if end_type >= expr_len {
                            break;
                        }
                        val ct: char = get_char(expr, end_type);
                        if ct == '(' {
                            paren_depth = paren_depth + 1;
                        } elif ct == cast[char](41) {
                            if paren_depth == 0 {
                                break;
                            }
                            paren_depth--;
                        }
                        end_type++;
                    }

                    if end_type <= expr_len {
                        val raw_type: string = strip(substring_se(expr, start_type, end_type));
                        if str_len(raw_type) > 0 {
                            mut normalized_type: string = replace_all(raw_type, str("( "), str("("));
                            normalized_type = replace_all(normalized_type, str(" )"), str(")"));
                            normalized_type = replace_all(normalized_type, str(" ("), str("("));
                            normalized_type = replace_all(normalized_type, str(") "), str(")"));
                            val mapped: string = map_axe_type_to_c(normalized_type);
                            StringBuilder.append(addr(sb), mapped);
                        }

                        if end_type < expr_len and get_char(expr, end_type) == ')' {
                            StringBuilder.append_c(addr(sb), ")");
                            end_type = end_type + 1;
                        }

                        i = end_type;
                        continue;
                    }
                }

                i = j;
                continue;
            }

            StringBuilder.append(addr(sb), ident);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite Axe-style cast expressions of the form
///   `cast [ T ] ( expr )`
/// into  C-style casts using the mapped C type, e.g.:
///   `(int32_t)(expr)`
def rewrite_casts(expr: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(expr) + 64);
    mut i: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val expr_len: i32 = cast[i32](str_len(expr));

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '\'' and !in_string and !is_escaped_quote(expr, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if !in_string and !in_char_literal and is_ident_start(ch) {
            val ident_start: i32 = i;
            mut j: i32 = i;
            loop {
                if j >= expr_len {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                j = j + 1;
            }
            val ident: string = substring_se(expr, ident_start, j);

            if str_len(ident) == 4 and get_char(ident, 0) == 'c' and get_char(ident, 1) == 'a' and get_char(ident, 2) == 's' and get_char(ident, 3) == 't' {
                mut k: i32 = j;
                loop {
                    if k >= expr_len {
                        break;
                    }
                    val ws: char = get_char(expr, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < expr_len and get_char(expr, k) == '[' {
                    val t_start: i32 = k + 1;
                    mut t_end: i32 = -1;
                    mut in_str_type: bool = false;
                    mut p: i32 = t_start;
                    loop {
                        if p >= expr_len {
                            break;
                        }
                        val ct: char = get_char(expr, p);
                        if ct == '"' and !is_escaped_quote(expr, p) {
                            in_str_type = !in_str_type;
                        }
                        if !in_str_type and ct == ']' {
                            t_end = p;
                            break;
                        }
                        p = p + 1;
                    }

                    if t_end > t_start {
                        val type_raw: string = strip(substring_se(expr, t_start, t_end));

                        mut a: i32 = t_end + 1;
                        loop {
                            if a >= expr_len {
                                break;
                            }
                            val wa: char = get_char(expr, a);
                            if wa != ' ' and wa != '\t' and wa != '\n' {
                                break;
                            }
                            a = a + 1;
                        }

                        if a < expr_len and get_char(expr, a) == '(' {
                            mut depth: i32 = 0;
                            mut in_str_paren: bool = false;
                            mut q: i32 = a;
                            mut end_paren: i32 = -1;
                            loop {
                                if q >= expr_len {
                                    break;
                                }
                                val cp: char = get_char(expr, q);
                                if cp == '"' and !is_escaped_quote(expr, q) {
                                    in_str_paren = !in_str_paren;
                                }
                                if !in_str_paren {
                                    if cp == '(' {
                                        depth = depth + 1;
                                    } elif cp == cast[char](41) {
                                        depth = depth - 1;
                                        if depth == 0 {
                                            end_paren = q;
                                            break;
                                        }
                                    }
                                }
                                q = q + 1;
                            }

                            if end_paren >= 0 {
                                mut normalized_type: string = replace_all(type_raw, str("( "), str("("));
                                normalized_type = replace_all(normalized_type, str(" )"), str(")"));
                                normalized_type = replace_all(normalized_type, str(" ("), str("("));
                                normalized_type = replace_all(normalized_type, str(") "), str(")"));
                                val mapped_type: string = map_axe_type_to_c(normalized_type);
                                StringBuilder.append_char(addr(sb), '(');
                                StringBuilder.append(addr(sb), mapped_type);
                                StringBuilder.append_char(addr(sb), cast[char](41));

                                val inner_expr_str: string = substring_se(expr, a + 1, end_paren);
                                val rewritten_inner: string = rewrite_casts(inner_expr_str);
                                val inner_full: string = concat(str("("), concat(rewritten_inner, str(")")));
                                StringBuilder.append(addr(sb), inner_full);
                                i = end_paren + 1;

                                continue;
                            }
                        }
                    }
                }

                StringBuilder.append(addr(sb), ident);
                i = j;
                continue;
            }

            StringBuilder.append(addr(sb), ident);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Add a list element type to tracking structures (map + ordered list)
def add_list_element(c_elem: string) {
    if str_len(c_elem) == 0 {
        return;
    }

    if StringBoolMap.contains(addr(g_list_element_types), c_elem) {
        return;
    }

    mut arena: Arena = Arena.create(2560);
    StringBoolMap.set(addr(g_list_element_types), addr(arena), c_elem, true);

    if g_list_elements != nil {
        val listref: ref StringList = g_list_elements;
        mut i: i32 = 0;
        loop {
            if i >= listref*.len {
                break;
            }
            val it: string = StringList.get(listref, i);
            if compare(it, c_elem) == 0 {
                return;
            }
            i++;
        }
        StringList.push(g_list_elements, addr(arena), c_elem);
    }
}

/// Recursively scan AST for occurrences of list types (sugar: [999]) and register them
def scan_for_list_types(node: ref ASTNode) {
    if node == nil {
        return;
    }

    if equals_c(node.node_type, "Declaration") {
        val tname: string = node.data.declaration.type_name;
        if str_len(tname) > 0 {
            val br: i32 = find_char_from(tname, '[', 0);
            if br >= 0 {
                val suffix: string = substring_se(tname, br, str_len(tname));
                if equals_c(suffix, "[999]") {
                    mut element: string = strip(substring_se(tname, 0, br));
                    if has_prefix(element, str("ref ")) {
                        element = strip(substr(element, 4, str_len(element) - 4));
                    }
                    val mapped: string = map_axe_type_to_c(element);
                    add_list_element(mapped);
                }
            }
        }
    }

    if node.children != nil {
        val chs: ref list(ASTNode) = node.children;
        mut idx: i32 = 0;
        loop {
            if idx >= len(deref(chs)) {
                break;
            }
            scan_for_list_types(addr(chs.data[idx]));
            idx = idx + 1;
        }
    }
}

/// Format model field type with proper struct prefix
def format_model_field_type(field_type: string): string {
    mut trimmed: string = strip(field_type);
    mut qualifiers: string = str("");
    
    loop {
        if !has_prefix(trimmed, str("const ")) {
            break;
        }
        qualifiers = concat(qualifiers, str("const "));
        trimmed = strip(substr(trimmed, 6, str_len(trimmed) - 6));
    }
    
    mut had_struct_prefix: bool = false;
    if has_prefix(trimmed, str("struct ")) {
        had_struct_prefix = true;
        trimmed = strip(substr(trimmed, 7, str_len(trimmed) - 7));
    }
    
    mut pointer_suffix: string = str("");
    loop {
        val len: i32 = str_len(trimmed);
        if len == 0 {
            break;
        }
        val last_char: char = get_char(trimmed, len - 1);
        if last_char != '*' {
            break;
        }
        pointer_suffix = concat(pointer_suffix, str("*"));
        trimmed = strip(substring_se(trimmed, 0, len - 1));
    }
    
    val model_name: string = canonical_model_c_name(trimmed);
    if str_len(model_name) > 0 {
        if StringBoolMap.contains(addr(g_enum_names), model_name) {
            trimmed = model_name;
        } else {
            trimmed = concat(str("struct "), model_name);
        }
    } else {
        if had_struct_prefix {
            trimmed = concat(str("struct "), trimmed);
        }
    }
    
    mut final_result: string = qualifiers;
    final_result = concat(final_result, trimmed);
    final_result = concat(final_result, pointer_suffix);
    return final_result;
}

/// Process parameter type (handle ref, mut, pointers, etc.)
[inline]
def process_parameter_type(param_type: string): string {
    // Delegate to the comprehensive Axe->C mapper so that 'mut', repeated
    // 'ref' prefixes, list[999] sugar, and pointer suffixes are handled
    // consistently. Examples:
    //
    //   'char'          -> 'char'
    //   'ref char'      -> 'char*'
    //   'ref ref char'  -> 'char**'
    //   'ref MyModel*'  -> 'struct ...* *'

    val result: string = strip(param_type);
    val mapped: string = map_axe_type_to_c(result);
    
    if find_substr(mapped, str("__list_")) >= 0 and !has_suffix(mapped, str("*")) {
        return concat(mapped, str("*"));
    }
    
    return mapped;
}

def int_to_ascii(n: i32): string {
    if n == 0 {
        return str("0");
    }

    mut neg: bool = false;
    mut v: i32 = n;
    if v < 0 {
        neg = true;
        v = -v;
    }

    mut sb_rev: StringBuilder = StringBuilder.init(16);
    loop {
        if v == 0 {
            break;
        }
        val digit: i32 = v mod 10;
        StringBuilder.append_char(addr(sb_rev), cast[char]('0' + digit));
        v = v / 10;
    }

    val rev: string = StringBuilder.to_string(addr(sb_rev));
    StringBuilder.destroy(addr(sb_rev));

    mut sb_out: StringBuilder = StringBuilder.init(str_len(rev) + 2);
    mut i: i32 = cast[i32](str_len(rev)) - 1;
    loop {
        if i < 0 {
            break;
        }
        StringBuilder.append_char(addr(sb_out), get_char(rev, i));
        i = i - 1;
    }

    mut out: string = StringBuilder.to_string(addr(sb_out));
    StringBuilder.destroy(addr(sb_out));
    if neg {
        out = concat(str("-"), out);
    }

    return out;
}

def get_type_format_specifier(var_type: string): string {
    val t: string = strip(var_type);

    if equals_c(t, "int32_t") or has_suffix(t, str("int32_t")) {
        return str("%d");
    }
    if equals_c(t, "uint32_t") or has_suffix(t, str("uint32_t")) {
        return str("%u");
    }
    if equals_c(t, "int64_t") or has_suffix(t, str("int64_t")) {
        return str("%lld");
    }
    if equals_c(t, "uint64_t") or has_suffix(t, str("uint64_t")) {
        return str("%llu");
    }
    if equals_c(t, "float") or has_suffix(t, str("float")) {
        return str("%f");
    }
    if equals_c(t, "double") or has_suffix(t, str("double")) {
        return str("%f");
    }
    if has_prefix(t, str("ref char")) or has_suffix(t, str("char*")) {
        return str("%s");
    }
    if equals_c(t, "char") {
        return str("%c");
    }

    return str("%d");
}

def lookup_expression_type(expr: string): string {
    val e: string = strip(expr);

    if StringStringMap.contains(addr(g_var_types), e) {
        return StringStringMap.get(addr(g_var_types), e);
    }

    if str_len(e) >= 2 and get_char(e, 0) == '"' and get_char(e, str_len(e) - 1) == '"' {
        return str("string");
    }

    if str_len(e) >= 2 and get_char(e, 0) == '\'' and get_char(e, str_len(e) - 1) == '\'' {
        return str("char");
    }

    if str_len(e) > 0 {
        val c0: char = get_char(e, 0);
        if c0 >= '0' and c0 <= '9' {
            if find_char_from(e, '.', 0) >= 0 {
                return str("f64");
            }
            return str("i32");
        }
    }

    return str("i32");
}

def process_interpolated_string(interp_content: string, return_struct: bool): string {
    mut parts: list(string);
    mut expressions: list(string);

    mut pos: i32 = 0;
    mut sb_part: StringBuilder = StringBuilder.init(str_len(interp_content) + 16);
    val content_len: i32 = cast[i32](str_len(interp_content));

    loop {
        if pos >= content_len {
            break;
        }

        val ch: char = get_char(interp_content, pos);

        if ch == '{' and !is_escaped_quote(interp_content, pos) {
            if pos > 0 and get_char(interp_content, pos - 1) == '$' and sb_part.len > 0 {
                sb_part.len = sb_part.len - 1;
            }

            append(parts, StringBuilder.to_string(addr(sb_part)));
            StringBuilder.clear(addr(sb_part));

            val brace_start: i32 = pos + 1;
            mut brace_depth: i32 = 1;
            mut brace_end: i32 = brace_start;

            loop {
                if brace_end >= content_len or brace_depth == 0 {
                    break;
                }
                val cc: char = get_char(interp_content, brace_end);
                if cc == '{' {
                    brace_depth = brace_depth + 1;
                } elif cc == '}' {
                    brace_depth = brace_depth - 1;
                }
                brace_end = brace_end + 1;
            }

            if brace_depth != 0 {
                enforce_raw(false, "Unmatched braces in interpolated string");
            }

            val expr: string = strip(substring_se(interp_content, brace_start, brace_end - 1));
            append(expressions, expr);
            pos = brace_end;
            continue;
        }

        StringBuilder.append_char(addr(sb_part), ch);
        pos = pos + 1;
    }

    append(parts, StringBuilder.to_string(addr(sb_part)));
    StringBuilder.destroy(addr(sb_part));

    if len(parts) == 0 {
        return str("");
    }

    if len(expressions) == 0 {
        mut q: string = str("\"");
        q = concat(q, interp_content);
        q = concat(q, str("\""));
        return q;
    }

    mut code: string = str("({ size_t _axe_interp_len = 0");

    mut i_part_size: i32 = 0;
    loop {
        if i_part_size >= len(parts) {
            break;
        }

        val part_sz: string = parts.data[i_part_size];
        if str_len(part_sz) > 0 {
            mut escaped_sz: string = replace_all(part_sz, str("\\"), str("\\\\"));
            escaped_sz = replace_all(escaped_sz, str("\""), str("\\\""));
            escaped_sz = replace_all(escaped_sz, str("\n"), str("\\n"));
            escaped_sz = replace_all(escaped_sz, str("\t"), str("\\t"));

            code = concat(code, str(" + sizeof(\""));
            code = concat(code, escaped_sz);
            code = concat(code, str("\") - 1"));
        }

        if i_part_size < len(expressions) {
            code = concat(code, str(" + 32"));
        }

        i_part_size = i_part_size + 1;
    }

    code = concat(code, str("; char* _axe_interp = (char*)malloc(_axe_interp_len + 1); char* _axe_interp_p = _axe_interp; "));

    mut i_part: i32 = 0;
    loop {
        if i_part >= len(parts) {
            break;
        }

        val part: string = parts.data[i_part];
        if str_len(part) > 0 {
            mut escaped: string = replace_all(part, str("\\"), str("\\\\"));
            escaped = replace_all(escaped, str("\""), str("\\\""));
            escaped = replace_all(escaped, str("\n"), str("\\n"));
            escaped = replace_all(escaped, str("\t"), str("\\t"));

            code = concat(code, str("memcpy(_axe_interp_p, \""));
            code = concat(code, escaped);
            code = concat(code, str("\", sizeof(\""));
            code = concat(code, escaped);
            code = concat(code, str("\") - 1); _axe_interp_p += sizeof(\""));
            code = concat(code, escaped);
            code = concat(code, str("\") - 1; "));
        }

        if i_part < len(expressions) {
            val e: string = expressions.data[i_part];
            val etype: string = lookup_expression_type(e);
            val processed_e: string = process_expression(e);

            if str_len(etype) > 0 and (equals_c(etype, "string") or has_suffix(etype, str("_string")) or equals_c(etype, "std__string__string")) {
                code = concat(code, str("{ struct std__string__string _s = "));
                code = concat(code, processed_e);
                code = concat(code, str("; memcpy(_axe_interp_p, _s.data, _s.len); _axe_interp_p += _s.len; } "));
            } else {
                code = concat(code, str("{ int _len = snprintf(_axe_interp_p, 32, \""));
                code = concat(code, get_type_format_specifier(etype));
                code = concat(code, str("\", "));
                code = concat(code, processed_e);
                code = concat(code, str("); _axe_interp_p += _len; } "));
            }
        }

        i_part = i_part + 1;
    }

    code = concat(code, str("*_axe_interp_p = '\\0'; "));

    if return_struct {
        code = concat(code, str("struct std__string__string _sret = {0}; _sret.data = _axe_interp; _sret.len = _axe_interp_p - _axe_interp; _sret.cap = _axe_interp_len + 1; _sret; })"));
    } else {
        code = concat(code, str("_axe_interp; })"));
    }

    return code;
}

/// Process an expression string for C interop and pointer sugar
def is_token_char(c: char): bool {
    val c_code: i32 = cast[i32](c);
    // 'a' = 97, 'z' = 122, 'A' = 65, 'Z' = 90, '0' = 48, '9' = 57
    if c_code >= 97 and c_code <= 122 {
        return true;
    }
    if c_code >= 65 and c_code <= 90 {
        return true;
    }
    if c_code >= 48 and c_code <= 57 {
        return true;
    }
    if c == '_' {
        return true;
    }
    return false;
}

/// Check if a character can start an identifier (letter or underscore)
def is_ident_start(c: char): bool {
    val c_code: i32 = cast[i32](c);
    if c_code >= 97 and c_code <= 122 {
        return true;
    }
    if c_code >= 65 and c_code <= 90 {
        return true;
    }
    if c == '_' {
        return true;
    }
    return false;
}

def c_prefix_end_index(s: string): i32 {
    if str_len(s) < 2 {
        return -1;
    }

    if get_char(s, 0) != 'C' {
        return -1;
    }

    mut i: i32 = 1;
    loop {
        if i >= str_len(s) {
            return -1;
        }
        val ch: char = get_char(s, i);
        if ch != ' ' and ch != '\t' and ch != '\n' {
            break;
        }
        i++;
    }

    if get_char(s, i) != '.' {
        return -1;
    }

    i++;
    loop {
        if i >= str_len(s) {
            break;
        }
        val ch: char = get_char(s, i);
        if ch != ' ' and ch != '\t' and ch != '\n' {
            break;
        }
        i++;
    }

    return i;
}

/// Collapse duplicated '__segment__segment' patterns in identifiers.
/// For example, 'std__string__string__create' stays the same, but
/// 'std__string__string_string__create' becomes 'std__string__string__create'.
def collapse_duplicate_segments_once(s: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(s) + 16);
    mut i: i32 = 0;
    val n: i32 = cast[i32](str_len(s));

    loop {
        if i >= n {
            break;
        }

        if i + 2 < n and get_char(s, i) == '_' and get_char(s, i + 1) == '_' {
            mut j: i32 = i + 2;
            val seg1_start: i32 = j;
            loop {
                if j >= n {
                    break;
                }
                val ch: char = get_char(s, j);
                if ch == '_' {
                    break;
                }
                j = j + 1;
            }
            val seg1: string = substring_se(s, seg1_start, j);

            if str_len(seg1) > 0 {
                if j + 2 < n and get_char(s, j) == '_' and get_char(s, j + 1) == '_' {
                    mut k: i32 = j + 2;
                    val seg2_start: i32 = k;
                    loop {
                        if k >= n {
                            break;
                        }
                        val ch2: char = get_char(s, k);
                        if ch2 == '_' {
                            break;
                        }
                        k = k + 1;
                    }
                    val seg2: string = substring_se(s, seg2_start, k);

                    if compare(seg1, seg2) == 0 {
                        if (k < n and get_char(s, k) == '_' and (k + 1 >= n or get_char(s, k + 1) != '_')) {
                            StringBuilder.append_c(addr(sb), "__");
                            StringBuilder.append(addr(sb), seg1);
                            i = k;
                            continue;
                        }
                    }
                }

                if j + 3 < n and get_char(s, j) == '_' and get_char(s, j + 1) != '_' {
                    mut k2: i32 = j + 1;
                    val seg2b_start: i32 = k2;
                    loop {
                        if k2 >= n {
                            break;
                        }
                        val ch3: char = get_char(s, k2);
                        if ch3 == '_' {
                            break;
                        }
                        k2 = k2 + 1;
                    }
                    val seg2b: string = substring_se(s, seg2b_start, k2);

                    if k2 + 1 < n and get_char(s, k2) == '_' and get_char(s, k2 + 1) == '_' {
                        if compare(seg1, seg2b) == 0 {
                            StringBuilder.append_c(addr(sb), "__");
                            StringBuilder.append(addr(sb), seg1);
                            StringBuilder.append_c(addr(sb), "__");
                            i = k2 + 2;
                            continue;
                        }
                    }
                }
            }
        }

        StringBuilder.append_char(addr(sb), get_char(s, i));
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Strip any C. prefixes (C, optional spaces, '.', optional spaces) that may
/// appear anywhere in a C expression string, not just at the beginning.
def strip_all_c_prefixes(s: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(s) + 16);
    mut i: i32 = 0;
    val s_len: i32 = cast[i32](str_len(s));
    loop {
        if i >= s_len {
            break;
        }

        val ch: char = get_char(s, i);

        if ch == 'C' {
            mut prev_idx: i32 = i - 1;
            mut prev_ch: char = '\0';
            loop {
                if prev_idx < 0 {
                    break;
                }
                val pc: char = get_char(s, prev_idx);
                if pc != ' ' and pc != '\t' and pc != '\n' {
                    prev_ch = pc;
                    break;
                }
                prev_idx = prev_idx - 1;
            }

            if prev_idx < 0 or !is_ident_start(prev_ch) {
                mut k: i32 = i + 1;
                loop {
                    if k >= s_len {
                        break;
                    }
                    val ws: char = get_char(s, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < s_len and get_char(s, k) == '.' {
                    k = k + 1;
                    loop {
                        if k >= s_len {
                            break;
                        }
                        val ws2: char = get_char(s, k);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        k = k + 1;
                    }

                    i = k;
                    continue;
                }
            }
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite all enum member references (EnumName.MEMBER) within a string to the
/// proper C prefixed form (EnumName_MEMBER). This scans the entire expression
/// and transforms all occurrences, not just simple standalone patterns.
def rewrite_enum_member_refs(s: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(s) + 64);
    mut i: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val s_len: i32 = cast[i32](str_len(s));

    debug_print_raw "\n[DBG-ENUM] rewrite_enum_member_refs input:";
    debug_print_str s;

    loop {
        if i >= s_len {
            break;
        }

        val ch: char = get_char(s, i);

        if ch == '\'' and !in_string and !is_escaped_quote(s, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(s, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if in_string or in_char_literal {
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        // Look for identifier followed by '.' and another identifier
        if is_ident_start(ch) {
            val ident_start: i32 = i;
            mut j: i32 = i;
            loop {
                if j >= s_len {
                    break;
                }
                val cj: char = get_char(s, j);
                if !is_token_char(cj) {
                    break;
                }
                j = j + 1;
            }
            val ident: string = substring_se(s, ident_start, j);

            // Skip any whitespace after identifier
            mut k: i32 = j;
            loop {
                if k >= s_len {
                    break;
                }
                val ws: char = get_char(s, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }

            // Check for '.'
            if k < s_len and get_char(s, k) == '.' {
                k = k + 1;

                // Skip whitespace after '.'
                loop {
                    if k >= s_len {
                        break;
                    }
                    val ws2: char = get_char(s, k);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                // Parse member name
                if k < s_len and is_ident_start(get_char(s, k)) {
                    val member_start: i32 = k;
                    mut m: i32 = k;
                    loop {
                        if m >= s_len {
                            break;
                        }
                        val cm: char = get_char(s, m);
                        if !is_token_char(cm) {
                            break;
                        }
                        m = m + 1;
                    }
                    val member: string = substring_se(s, member_start, m);

                    if str_len(member) > 0 {
                        // Check if this identifier is a known enum name
                        val enum_c_name: string = canonical_model_c_name(ident);
                        if str_len(enum_c_name) > 0 and StringBoolMap.contains(addr(g_enum_names), enum_c_name) {
                            // This is an enum member access - emit EnumName_Member
                            StringBuilder.append(addr(sb), enum_c_name);
                            StringBuilder.append_char(addr(sb), '_');
                            StringBuilder.append(addr(sb), member);
                            i = m;
                            continue;
                        }
                    }
                }
            }

            // Not an enum member access, emit the identifier as-is
            StringBuilder.append(addr(sb), ident);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));

    debug_print_raw "\n[DBG-ENUM] rewrite_enum_member_refs output:";
    debug_print_str result;

    return result;
}

/// Rewrite addr(...) to &(...) or &var for C address-of operations
def rewrite_adr(expr: string): string {
    mut result: string = expr;
    
    loop {
        val start_idx: i32 = find_substr(result, str("addr"));
        if start_idx < 0 {
            break;
        }
        
        mut pos: i32 = start_idx + 4;
        loop {
            if pos >= str_len(result) {
                break;
            }
            val ws: char = get_char(result, pos);
            if ws != ' ' and ws != '\t' {
                break;
            }
            pos = pos + 1;
        }
        
        if pos >= str_len(result) or get_char(result, pos) != '(' {
            break;
        }
        
        val paren_start: i32 = pos + 1;
        mut depth: i32 = 1;
        mut paren_end: i32 = paren_start;
        
        loop {
            if paren_end >= str_len(result) or depth == 0 {
                break;
            }
            val ch: char = get_char(result, paren_end);
            if ch == '(' {
                depth = depth + 1;
            } elif ch == ')' {
                depth = depth - 1;
            }
            if depth > 0 {
                paren_end = paren_end + 1;
            }
        }
        
        if depth != 0 {
            break;
        }
        
        val var_name: string = strip(substring_se(result, paren_start, paren_end));
        val has_bracket: bool = find_char_from(var_name, '[', 0) >= 0;
        val has_dot: bool = find_char_from(var_name, '.', 0) >= 0;
        mut replacement: string = str("");

        if has_bracket or has_dot {
            replacement = concat(str("&("), var_name);
            replacement = concat(replacement, str(")"));
        } else {
            replacement = concat(str("&"), var_name);
        }
        
        val before: string = substring_se(result, 0, start_idx);
        val after: string = substring_se(result, paren_end + 1, str_len(result));

        result = concat(before, replacement);
        result = concat(result, after);
    }
    
    return result;
}

/// Rewrite deref(expr) to (*expr) for pointer dereference.
def rewrite_dereference(expr: string): string {
    mut result: string = expr;
    
    loop {
        val start_idx: i32 = find_substr(result, str("deref"));
        if start_idx < 0 {
            break;
        }
        
        mut pos: i32 = start_idx + 5;
        loop {
            if pos >= str_len(result) {
                break;
            }
            val ws: char = get_char(result, pos);
            if ws != ' ' and ws != '\t' {
                break;
            }
            pos++;
        }
        
        if pos >= str_len(result) or get_char(result, pos) != '(' {
            break;
        }
        
        val paren_start: i32 = pos + 1;
        mut depth: i32 = 1;
        mut paren_end: i32 = paren_start;
        
        loop {
            if paren_end >= str_len(result) or depth == 0 {
                break;
            }
            val ch: char = get_char(result, paren_end);
            if ch == '(' {
                depth++;
            } elif ch == cast[char](41) {
                depth--;
            }
            if depth > 0 {
                paren_end++;
            }
        }
        
        if depth != 0 {
            break;
        }
        
        val var_name: string = strip(substring_se(result, paren_start, paren_end));
        mut replacement: string = concat(str("(*"), var_name);
        replacement = concat_c(replacement, ")");
        
        val before: string = substring_se(result, 0, start_idx);
        val after: string = substring_se(result, paren_end + 1, str_len(result));
        result = concat(before, replacement);
        result = concat(result, after);
    }
    
    return result;
}

/// Rewrite len(expr) calls to len_ptr(expr) or len_v(expr) based on whether
/// the argument is a pointer type. 
/// 
/// This enables proper list length access.
def rewrite_len_calls(expr: string): string {
    mut result: string = expr;
    
    loop {
        mut start_idx: i32 = -1;
        mut paren_pos: i32 = -1;
        val search_pos: i32 = 0;
        val result_len: i32 = cast[i32](str_len(result));
        
        loop {
            if search_pos >= result_len - 3 {
                break;
            }
            
            mut found: bool = false;
            mut i: i32 = search_pos;
            loop {
                if i > result_len - 3 {
                    break;
                }
                if get_char(result, i) == 'l' and get_char(result, i + 1) == 'e' and 
                   get_char(result, i + 2) == 'n' {
                    mut in_string_check: bool = false;
                    mut qi: i32 = 0;
                    loop {
                        if qi >= i {
                            break;
                        }
                        val qc: char = get_char(result, qi);
                        if qc == '"' and (qi == 0 or get_char(result, qi - 1) != '\\') {
                            in_string_check = !in_string_check;
                        }
                        qi++;
                    }
                    
                    if in_string_check {
                        i++;
                        continue;
                    }
                    
                    mut is_standalone: bool = true;
                    if i > 0 {
                        val prev: char = get_char(result, i - 1);
                        if is_token_char(prev) {
                            is_standalone = false;
                        }
                    }
                    if is_standalone and i + 3 < result_len {
                        val after: char = get_char(result, i + 3);
                        if is_token_char(after) {
                            is_standalone = false;
                        }
                    }
                    
                    if is_standalone {
                        mut k: i32 = i + 3;
                        loop {
                            if k >= result_len {
                                break;
                            }
                            val ws: char = get_char(result, k);
                            if ws != ' ' and ws != '\t' and ws != '\n' {
                                break;
                            }
                            k++;
                        }
                        
                        if k < result_len and get_char(result, k) == '(' {
                            found = true;
                            paren_pos = k;
                            break;
                        }
                    }
                }
                i++;
            }
            
            if !found {
                break;
            }
            
            start_idx = i;
            break;
        }
        
        if start_idx < 0 {
            break;
        }
        
        val paren_start: i32 = paren_pos + 1;
        mut depth: i32 = 1;
        mut paren_end: i32 = paren_start;
        
        loop {
            if paren_end >= str_len(result) or depth == 0 {
                break;
            }
            val ch: char = get_char(result, paren_end);
            if ch == '(' {
                depth = depth + 1;
            } elif ch == ')' {
                depth = depth - 1;
            }
            if depth > 0 {
                paren_end = paren_end + 1;
            }
        }
        
        if depth != 0 {
            break;
        }
        
        val len_arg: string = strip(substring_se(result, paren_start, paren_end));
        mut is_pointer: bool = false;
        
        if find_substr(len_arg, str("->")) >= 0 {
            is_pointer = true;
        } elif find_char_from(len_arg, '.', 0) >= 0 {
            val len_arg_len: i32 = cast[i32](str_len(len_arg));
            mut last_dot: i32 = -1;
            mut di: i32 = 0;
            loop {
                if di >= len_arg_len {
                    break;
                }
                if get_char(len_arg, di) == '.' {
                    last_dot = di;
                }
                di++;
            }
            
            if last_dot >= 0 {
                mut field_name: string = strip(substring_se(len_arg, last_dot + 1, len_arg_len));
                val bracket_pos: i32 = find_char_from(field_name, '[', 0);

                if bracket_pos >= 0 {
                    field_name = strip(substring_se(field_name, 0, bracket_pos));
                }
                
                val first_dot: i32 = find_char_from(len_arg, '.', 0);

                if first_dot >= 0 {
                    val base_var: string = strip(substring_se(len_arg, 0, first_dot));
                    
                    if StringStringMap.contains(addr(g_var_types), base_var) {
                        val base_type: string = StringStringMap.get(addr(g_var_types), base_var);
                        val model_name: string = extract_base_model_name(base_type);
                        val field_type: string = lookup_field_type(model_name, field_name);
                        
                        if str_len(field_type) > 0 {
                            if is_pointer_type(field_type) {
                                is_pointer = true;
                            }
                        }
                        
                        if is_pointer_field(model_name, field_name) {
                            is_pointer = true;
                        }
                    }
                }
            }
        } else {
            mut base_var: string = len_arg;
            val bracket_pos: i32 = find_char_from(base_var, '[', 0);

            if bracket_pos >= 0 {
                base_var = strip(substring_se(base_var, 0, bracket_pos));
            }
            
            if StringStringMap.contains(addr(g_var_types), base_var) {
                val var_type: string = StringStringMap.get(addr(g_var_types), base_var);
                if is_pointer_type(var_type) {
                    is_pointer = true;
                }
            }
        }
        
        mut replacement: string = str("");

        if is_pointer {
            replacement = concat(str("len_ptr("), len_arg);
        } else {
            replacement = concat(str("len_v("), len_arg);
        }

        replacement = concat_c(replacement, ")");
        
        val before: string = substring_se(result, 0, start_idx);
        val after: string = substring_se(result, paren_end + 1, str_len(result));
        
        result = concat(before, replacement);
        result = concat(result, after);
    }
    
    return result;
}

def rewrite_function_calls(expr: string): string {
    mut sb: StringBuilder = StringBuilder.init(str_len(expr) + 64);
    mut i: i32 = 0;
    mut in_string: bool = false;
    mut in_char_literal: bool = false;
    val expr_len: i32 = cast[i32](str_len(expr));

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '\'' and !in_string and !is_escaped_quote(expr, i) {
            in_char_literal = !in_char_literal;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == '"' and !in_char_literal and !is_escaped_quote(expr, i) {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        val is_id_start: bool = is_ident_start(ch);
        if !in_string and !in_char_literal and is_id_start {
            val ident_start: i32 = i;
            mut j: i32 = i;
            loop {
                if j >= expr_len {
                    break;
                }
                val cj: char = get_char(expr, j);
                if !is_token_char(cj) {
                    break;
                }
                j = j + 1;
            }
            val ident: string = substring_se(expr, ident_start, j);

            mut k: i32 = j;
            loop {
                if k >= expr_len {
                    break;
                }
                val ws: char = get_char(expr, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }

            mut replaced_ident: string = ident;
            
            if str_len(ident) > 3 and get_char(ident, 0) == 'C' and get_char(ident, 1) == '_' and get_char(ident, 2) == '_' {
                replaced_ident = substring_se(ident, 3, str_len(ident));
            } elif k < expr_len and get_char(expr, k) == '(' {
                val has_double_underscore: bool = find_substr(ident, str("__")) >= 0;
                if !has_double_underscore and StringStringMap.contains(addr(g_function_prefixes), ident) {
                    replaced_ident = StringStringMap.get(addr(g_function_prefixes), ident);
                }
            }

            StringBuilder.append(addr(sb), replaced_ident);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite ::name (global scope access) to gvar__name.
/// Handles optional whitespace between the colons: :: name, : : name, etc.
def rewrite_global_scope_refs(expr: string): string {
    val expr_len: i32 = cast[i32](str_len(expr));
    if expr_len < 3 {
        return expr;
    }

    mut sb: StringBuilder = StringBuilder.init(cast[usize](expr_len + 32));
    mut in_string: bool = false;
    mut i: i32 = 0;

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if in_string {
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if ch == ':' {
            mut j: i32 = i + 1;
            loop {
                if j >= expr_len {
                    break;
                }
                val ws: char = get_char(expr, j);
                if ws != ' ' and ws != '\t' {
                    break;
                }
                j = j + 1;
            }

            if j < expr_len and get_char(expr, j) == ':' {
                j = j + 1;
                loop {
                    if j >= expr_len {
                        break;
                    }
                    val ws2: char = get_char(expr, j);
                    if ws2 != ' ' and ws2 != '\t' {
                        break;
                    }
                    j = j + 1;
                }

                if j < expr_len {
                    val first_ch: char = get_char(expr, j);
                    if (first_ch >= 'a' and first_ch <= 'z') or (first_ch >= 'A' and first_ch <= 'Z') or first_ch == '_' {
                        mut k: i32 = j;
                        loop {
                            if k >= expr_len {
                                break;
                            }
                            val id_ch: char = get_char(expr, k);
                            if !((id_ch >= 'a' and id_ch <= 'z') or (id_ch >= 'A' and id_ch <= 'Z') or (id_ch >= '0' and id_ch <= '9') or id_ch == '_') {
                                break;
                            }
                            k = k + 1;
                        }

                        val ident: string = substring_se(expr, j, k);
                        StringBuilder.append(addr(sb), ident);
                        i = k;
                        continue;
                    }
                }
            }
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Rewrite plain identifier references to global variables to use gvar__ prefix.
/// Only rewrites identifiers that are tracked in g_global_var_prefixes and
/// are not already prefixed or local variables (tracked in g_var_types).
def rewrite_global_var_refs(expr: string): string {
    val expr_len: i32 = cast[i32](str_len(expr));
    if expr_len == 0 {
        return expr;
    }

    mut sb: StringBuilder = StringBuilder.init(cast[usize](expr_len + 64));
    mut in_string: bool = false;
    mut i: i32 = 0;

    loop {
        if i >= expr_len {
            break;
        }

        val ch: char = get_char(expr, i);

        if ch == '"' and (i == 0 or get_char(expr, i - 1) != '\\') {
            in_string = !in_string;
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if in_string {
            StringBuilder.append_char(addr(sb), ch);
            i++;
            continue;
        }

        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' {
            if i > 0 {
                val prev_ch: char = get_char(expr, i - 1);
                if (prev_ch >= 'a' and prev_ch <= 'z') or (prev_ch >= 'A' and prev_ch <= 'Z') or (prev_ch >= '0' and prev_ch <= '9') or prev_ch == '_' {
                    StringBuilder.append_char(addr(sb), ch);
                    i++;
                    continue;
                }
            }

            mut j: i32 = i;
            loop {
                if j >= expr_len {
                    break;
                }
                val id_ch: char = get_char(expr, j);
                if !((id_ch >= 'a' and id_ch <= 'z') or (id_ch >= 'A' and id_ch <= 'Z') or (id_ch >= '0' and id_ch <= '9') or id_ch == '_') {
                    break;
                }
                j = j + 1;
            }

            val ident: string = substring_se(expr, i, j);

            if has_prefix(ident, str("gvar__")) {
                StringBuilder.append(addr(sb), ident);
                i = j;
                continue;
            }

            if StringStringMap.contains(addr(g_var_types), ident) {
                StringBuilder.append(addr(sb), ident);
                i = j;
                continue;
            }

            if StringStringMap.contains(addr(g_global_var_prefixes), ident) {
                val mapped: string = StringStringMap.get(addr(g_global_var_prefixes), ident);
                StringBuilder.append(addr(sb), mapped);
                i = j;
                continue;
            }
            
            if j < expr_len {
                val next_ch: char = get_char(expr, j);
                if next_ch != '(' and next_ch != '.' {
                    val is_upper_case_const: bool = is_all_upper_or_underscore(ident);
                    if is_upper_case_const and !is_builtin_type(ident) and !is_language_keyword(ident) and !is_c_constant(ident) {
                        if !is_symbol_imported(ident) and !StringBoolMap.contains(addr(g_emitted_globals), ident) and !StringBoolMap.contains(addr(g_foreign_types), ident) {
                            print(get_short_filename(g_current_source_file));
                            print ":";
                            print(i32_to_string(g_current_line));
                            print ": error: undefined symbol: ";
                            print ident;
                            println ", perhaps missing 'use' statement?";
                            unsafe {
                                C.exit(1);
                            }
                        }
                    }
                }
            }

            StringBuilder.append(addr(sb), ident);
            i = j;
            continue;
        }

        StringBuilder.append_char(addr(sb), ch);
        i++;
    }

    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Check if a variable is declared
def check_variable_declared(name: string) {
    if str_len(name) == 0 { return; }
    if !is_ident_start(get_char(name, 0)) { return; }
    
    mut i: i32 = 1;
    loop {
        if i >= str_len(name) { break; }
        if !is_token_char(get_char(name, i)) { return; }
        i++;
    }
 
    if is_language_keyword(name) { return; }
    if is_builtin_type(name) { return; }
    if is_builtin_function(name) { return; }
    if is_c_constant(name) { return; }
    if equals_c(name, "true") or equals_c(name, "false") or equals_c(name, "nil") { return; }
    if equals_c(name, "mod") or equals_c(name, "and") or equals_c(name, "or") or equals_c(name, "not") or equals_c(name, "xor") { return; }
    if StringStringMap.contains(addr(g_var_types), name) { return; }
    if StringStringMap.contains(addr(g_global_var_prefixes), name) { return; }
    if StringStringMap.contains(addr(g_function_param_types), name) { return; }
    if StringStringMap.contains(addr(g_function_prefixes), name) { return; }
    if StringStringMap.contains(addr(g_model_names), name) { return; }
    if StringBoolMap.contains(addr(g_enum_names), name) { if equals_c(name, "y") { println "DEBUG: y found in g_enum_names"; } return; }
    if StringBoolMap.contains(addr(g_opaque_types), name) { if equals_c(name, "y") { println "DEBUG: y found in g_opaque_types"; } return; }
    if is_symbol_imported(name) { if equals_c(name, "y") { println "DEBUG: y is imported"; } return; }
    if str_len(name) >= 2 and get_char(name, 0) == 'g' and get_char(name, 1) == '_' { return; }
    if has_prefix(name, str("gvar__")) { return; }
    if StringBoolMap.contains(addr(g_emitted_globals), name) { return; }
    if is_all_upper_or_underscore(name) { return; }
    
    print(get_short_filename(g_current_source_file));
    print ":";
    print(i32_to_string(g_current_line));
    print ": error: undefined symbol: ";
    print name;
    println "";

    unsafe { 
        C.exit(1); 
    }
}

def process_expression(expr: string): string {
    mut trimmed: string = strip(expr);
    
    check_variable_declared(trimmed);
    
    mut has_pointer_sugar: bool = false;
    mut in_string: bool = false;
    mut i: i32 = 0;

    trimmed = rewrite_global_scope_refs(trimmed);

    if has_prefix(trimmed, str("__INTERPOLATED__")) and has_suffix(trimmed, str("__INTERPOLATED__")) {
        val inner_len: i32 = str_len(trimmed) - 32;
        if inner_len > 0 {
            val inner: string = substring_se(trimmed, 16, 16 + inner_len);
            return process_interpolated_string(inner, false);
        }
    }

    val open_idx: i32 = find_char_from(trimmed, '(', 0);
    if open_idx > 0 {
        val func_name_raw: string = strip(substring_se(trimmed, 0, open_idx));
        if equals_c(func_name_raw, "str") or has_suffix(func_name_raw, str("__str")) {
            mut depth: i32 = 0;
            mut in_str_arg: bool = false;
            mut j: i32 = open_idx;
            loop {
                if j >= str_len(trimmed) {
                    break;
                }
                val chj: char = get_char(trimmed, j);
                if chj == '"' and (j == 0 or get_char(trimmed, j - 1) != '\\') {
                    in_str_arg = !in_str_arg;
                } elif !in_str_arg {
                    if chj == '(' {
                        depth = depth + 1;
                    } elif chj == ')' {
                        depth = depth - 1;
                        if depth == 0 {
                            break;
                        }
                    }
                }
                j = j + 1;
            }

            if depth == 0 and j > open_idx {
                val inner_raw: string = strip(substring_se(trimmed, open_idx + 1, j));
                if has_prefix(inner_raw, str("__INTERPOLATED__")) and has_suffix(inner_raw, str("__INTERPOLATED__")) {
                    val inner_len2: i32 = str_len(inner_raw) - 32;
                    if inner_len2 > 0 {
                        val inner2: string = substring_se(inner_raw, 16, 16 + inner_len2);
                        return process_interpolated_string(inner2, true);
                    }
                }
            }
        }
    }

    trimmed = rewrite_casts(trimmed);

    loop {
        if i >= str_len(trimmed) {
            break;
        }
        val ch: char = get_char(trimmed, i);
        if ch == '"' and (i == 0 or get_char(trimmed, i - 1) != '\\') {
            in_string = !in_string;
        } elif !in_string and ch == '*' {
            mut k: i32 = i + 1;
            loop {
                if k >= str_len(trimmed) {
                    break;
                }
                val ws: char = get_char(trimmed, k);
                if ws != ' ' and ws != '\t' and ws != '\n' {
                    break;
                }
                k = k + 1;
            }
            if k < str_len(trimmed) and get_char(trimmed, k) == '.' {
                has_pointer_sugar = true;
                break;
            }
        }
        i++;
    }

    mut has_c_prefix: bool = false;
    val c_prefix_end: i32 = c_prefix_end_index(trimmed);
    if c_prefix_end >= 0 {
        has_c_prefix = true;
    }

    if !has_pointer_sugar and !has_c_prefix {
        debug_print_raw "\n[DBG-EXPR] no-sugar/no-C expr raw:";
        debug_print_str expr;
        debug_print_raw "\n[DBG-EXPR] no-sugar/no-C trimmed:";
        debug_print_str trimmed;

        val single_quote_pos: i32 = find_char_from(trimmed, '\'', 0);
        if single_quote_pos >= 0 {
            val addr_fixed_chars: string = rewrite_adr(trimmed);
            val deref_fixed_chars: string = rewrite_dereference(addr_fixed_chars);
            val calls_fixed_chars: string = rewrite_function_calls(deref_fixed_chars);
            val len_fixed_chars: string = rewrite_len_calls(calls_fixed_chars);
            val enum_fixed_chars: string = rewrite_enum_member_refs(len_fixed_chars);
            val prefixes_fixed_chars: string = rewrite_function_prefixes(enum_fixed_chars);
            val mod_fixed_chars: string = replace_keyword_outside_strings(prefixes_fixed_chars, str("mod"), str("%"));
            val and_fixed_chars: string = replace_keyword_outside_strings(mod_fixed_chars, str("and"), str("&&"));
            val or_fixed_chars: string = replace_keyword_outside_strings(and_fixed_chars, str("or"), str("||"));
            return strip(or_fixed_chars);
        }

        // Even when there is no pointer sugar or C. prefix, we still need to
        // normalize spurious internal spaces that may have been introduced
        // between pieces of what should be a single token. Examples that have
        // shown up in generated C include:
        //
        //   "0 . 0"         -> "0.0"
        //   "0 . 0000001"   -> "0.0000001"
        //   "reduce _angle" -> "reduce_angle"
        //
        // To fix these without disturbing normal inter-token spacing, run the
        // normalization pass below on the already-trimmed expression.

        val normalized_only: string = trimmed;
        mut sb_norm: StringBuilder = StringBuilder.init(str_len(normalized_only) + 16);
        mut jn: i32 = 0;
        val norm_len: i32 = cast[i32](str_len(normalized_only));
        mut in_string_norm: bool = false;
        
        loop {
            if jn >= norm_len {
                break;
            }
            val chn: char = get_char(normalized_only, jn);

            if chn == '"' and (jn == 0 or get_char(normalized_only, jn - 1) != '\\') {
                in_string_norm = !in_string_norm;
                StringBuilder.append_char(addr(sb_norm), chn);
                jn = jn + 1;
                continue;
            }

            if in_string_norm {
                StringBuilder.append_char(addr(sb_norm), chn);
                jn = jn + 1;
                continue;
            }

            if chn == ' ' or chn == '\t' or chn == '\n' {
                mut prev: char = '\0';
                mut next: char = '\0';

                mut kprev: i32 = jn - 1;
                loop {
                    if kprev < 0 {
                        break;
                    }
                    val cprev: char = get_char(normalized_only, kprev);
                    if cprev != ' ' and cprev != '\t' and cprev != '\n' {
                        prev = cprev;
                        break;
                    }
                    kprev = kprev - 1;
                }

                mut knext: i32 = jn + 1;
                loop {
                    if knext >= norm_len {
                        break;
                    }
                    val cnext: char = get_char(normalized_only, knext);
                    if cnext != ' ' and cnext != '\t' and cnext != '\n' {
                        next = cnext;
                        break;
                    }
                    knext = knext + 1;
                }

                if (prev >= '0' and prev <= '9' and next == '.') or
                   (prev == '.' and next >= '0' and next <= '9') {
                    // Merge numeric fragments around the decimal point.
                } elif is_token_char(prev) and is_token_char(next) {
                    if next == '_' {
                        // ok.
                    } elif (prev == '+' and next == '=') or (prev == '-' and next == '=') {
                        // Merge `+ =` or `- =` into `+=` / `-=` to avoid split operators in generated C.
                    } elif is_ident_start(prev) and !is_ident_start(next) {
                        StringBuilder.append_char(addr(sb_norm), ' ');
                    } elif !is_ident_start(next) {
                        // Merge other token fragments.
                    } else {
                        StringBuilder.append_char(addr(sb_norm), ' ');
                    }
                } else {
                    StringBuilder.append_char(addr(sb_norm), ' ');
                }
            } else {
                StringBuilder.append_char(addr(sb_norm), chn);
            }

            jn = jn + 1;
        }

        val out_norm: string = StringBuilder.to_string(addr(sb_norm));
        StringBuilder.destroy(addr(sb_norm));
        val norm_no_sugar: string = strip(out_norm);
        debug_print_raw "\n[DBG-EXPR] no-sugar final:";
        debug_print_str norm_no_sugar;

        val addr_fixed: string = rewrite_adr(norm_no_sugar);
        val deref_fixed: string = rewrite_dereference(addr_fixed);
        val ptr_fixed: string = rewrite_ref_member_access(deref_fixed);
        val methods_fixed: string = rewrite_method_calls(ptr_fixed);
        val sizeof_fixed: string = rewrite_sizeof_types(methods_fixed);
        val calls_fixed_no_sugar: string = rewrite_function_calls(sizeof_fixed);
        val len_fixed_no_sugar: string = rewrite_len_calls(calls_fixed_no_sugar);
        val enum_fixed_no_sugar: string = rewrite_enum_member_refs(len_fixed_no_sugar);
        val prefixes_fixed_no_sugar: string = rewrite_function_prefixes(enum_fixed_no_sugar);
        val global_vars_fixed: string = rewrite_global_var_refs(prefixes_fixed_no_sugar);
        val mod_fixed_no_sugar: string = replace_keyword_outside_strings(global_vars_fixed, str("mod"), str("%"));
        val and_fixed_no_sugar: string = replace_keyword_outside_strings(mod_fixed_no_sugar, str("and"), str("&&"));
        val or_fixed_no_sugar: string = replace_keyword_outside_strings(and_fixed_no_sugar, str("or"), str("||"));
        
        return strip(or_fixed_no_sugar);
    }

    mut result: string = trimmed;
    debug_print_raw "\n[DBG-EXPR] raw expr before sugar/C:";
    debug_print_str expr;
    debug_print_raw "\n[DBG-EXPR] trimmed:";
    debug_print_str trimmed;

    if has_pointer_sugar {
        mut sb_sugar: StringBuilder = StringBuilder.init(str_len(result) + 32);
        mut in_str2: bool = false;
        mut j: i32 = 0;
        val result_len: i32 = cast[i32](str_len(result));
        loop {
            if j >= result_len {
                break;
            }
            val ch2: char = get_char(result, j);
            if ch2 == '"' and (j == 0 or get_char(result, j - 1) != '\\') {
                in_str2 = !in_str2;
                StringBuilder.append_char(addr(sb_sugar), ch2);
            } elif !in_str2 and ch2 == '*' {
                // Support both `s*.field` and `s * . field` forms. When we see
                // a `*` outside of strings, peek ahead past any whitespace; if
                // the next non-space character is `.`, treat this as pointer
                // member sugar and emit `->` instead.
                mut k: i32 = j + 1;
                loop {
                    if k >= result_len {
                        break;
                    }
                    val ws: char = get_char(result, k);
                    if ws != ' ' and ws != '\t' and ws != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < result_len and get_char(result, k) == '.' {
                    StringBuilder.append_c(addr(sb_sugar), "->");
                    j = k; // skip over the '.'; loop increment will move past it
                } else {
                    StringBuilder.append_char(addr(sb_sugar), ch2);
                }
            } else {
                StringBuilder.append_char(addr(sb_sugar), ch2);
            }
            j = j + 1;
        }
        result = StringBuilder.to_string(addr(sb_sugar));
        StringBuilder.destroy(addr(sb_sugar));
    }

    if has_c_prefix {
        result = substring_se(result, c_prefix_end, str_len(result));
    }

    result = strip_all_c_prefixes(result);

    // After pointer-sugar and C. stripping, run the same normalization pass
    // used above to clean up spurious internal spaces within tokens such as
    // "0 . 0" or "reduce _angle" while preserving spaces between tokens.
    
    val normalized: string = result;
    
    debug_print_raw "\n[DBG-EXPR] after sugar/C before normalize:";
    debug_print_str normalized;

    mut sb_final: StringBuilder = StringBuilder.init(str_len(normalized) + 32);
    mut jf: i32 = 0;
    val normalized_len: i32 = cast[i32](str_len(normalized));
    mut in_string_final: bool = false;

    loop {
        if jf >= normalized_len {
            break;
        }
        val chf: char = get_char(normalized, jf);

        if chf == '"' and (jf == 0 or get_char(normalized, jf - 1) != '\\') {
            in_string_final = !in_string_final;
            StringBuilder.append_char(addr(sb_final), chf);
            jf = jf + 1;
            continue;
        }

        if in_string_final {
            StringBuilder.append_char(addr(sb_final), chf);
            jf = jf + 1;
            continue;
        }

        if chf == ' ' or chf == '\t' or chf == '\n' {
            mut prev2: char = '\0';
            mut next2: char = '\0';

            mut kp: i32 = jf - 1;
            loop {
                if kp < 0 {
                    break;
                }
                val cp: char = get_char(normalized, kp);
                if cp != ' ' and cp != '\t' and cp != '\n' {
                    prev2 = cp;
                    break;
                }
                kp = kp - 1;
            }

            mut kn: i32 = jf + 1;
            loop {
                if kn >= normalized_len {
                    break;
                }
                val cn: char = get_char(normalized, kn);
                if cn != ' ' and cn != '\t' and cn != '\n' {
                    next2 = cn;
                    break;
                }
                kn = kn + 1;
            }

            if (prev2 >= '0' and prev2 <= '9' and next2 == '.') or
               (prev2 == '.' and next2 >= '0' and next2 <= '9') {
                // Merge numeric fragments around the decimal point.
            } elif is_token_char(prev2) and is_token_char(next2) {
                if next2 == '_' {
                    // Merge space before underscore into the identifier.
                } elif (prev2 == '+' and next2 == '=') or (prev2 == '-' and next2 == '=') {
                    // Merge `+ =` or `- =` into `+=` / `-=`.
                } elif !is_ident_start(next2) {
                    // Drop the space between token characters (e.g. `reduce _angle`).
                } else {
                    StringBuilder.append_c(addr(sb_final), " ");
                }
            } else {
                StringBuilder.append_c(addr(sb_final), " ");
            }
        } else {
            StringBuilder.append_char(addr(sb_final), chf);
        }

        jf = jf + 1;
    }

    val out_final: string = StringBuilder.to_string(addr(sb_final));
    StringBuilder.destroy(addr(sb_final));
    val first_pass: string = strip(out_final);
    debug_print_raw "\nFIRST PASS:";
    debug_print_str first_pass;
    val fixed: string = replace_all(first_pass, str("(->"), str("->"));
    debug_print_raw "\nFIXED:";
    debug_print_str fixed;

    val addr_fixed2: string = rewrite_adr(fixed);
    val deref_fixed2: string = rewrite_dereference(addr_fixed2);
    val ptr_fixed2: string = rewrite_ref_member_access(deref_fixed2);
    val methods_fixed2: string = rewrite_method_calls(ptr_fixed2);
    val sizeof_fixed2: string = rewrite_sizeof_types(methods_fixed2);
    val calls_fixed: string = rewrite_function_calls(sizeof_fixed2);
    val len_fixed: string = rewrite_len_calls(calls_fixed);
    val enum_fixed: string = rewrite_enum_member_refs(len_fixed);
    val prefixes_fixed: string = rewrite_function_prefixes(enum_fixed);
    val mod_fixed: string = replace_keyword_outside_strings(prefixes_fixed, str("mod"), str("%"));
    val and_fixed: string = replace_keyword_outside_strings(mod_fixed, str("and"), str("&&"));
    val or_fixed: string = replace_keyword_outside_strings(and_fixed, str("or"), str("||"));

    return strip(or_fixed);
}

/// Generate stack trace headers for segfault handlers (Windows and POSIX versions)
def generate_stack_trace_headers(): string {
    mut code: string = str("");
    
    platform windows {
        code = concat_c(code, "#include <dbghelp.h>\n");
    }
    
    platform posix {
        code = concat_c(code, "#include <execinfo.h>\n");
        code = concat_c(code, "#include <signal.h>\n");
        code = concat_c(code, "#include <unistd.h>\n");
    }
    
    code = concat_c(code, "\n");
    
    platform windows {
        code = concat_c(code, "static void axe_win_print_backtrace(void) {\n");
        code = concat_c(code, "    HANDLE process = GetCurrentProcess();\n");
        code = concat_c(code, "    SymSetOptions(SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES);\n");
        code = concat_c(code, "    SymInitialize(process, NULL, TRUE);\n");
        code = concat_c(code, "\n");
        code = concat_c(code, "    void* stack[64];\n");
        code = concat_c(code, "    USHORT frames = CaptureStackBackTrace(0, 64, stack, NULL);\n");
        code = concat_c(code, "    fprintf(stderr, \"Backtrace (%u frames):\\n\", (unsigned)frames);\n");
        code = concat_c(code, "\n");
        code = concat_c(code, "    SYMBOL_INFO* symbol = (SYMBOL_INFO*)malloc(sizeof(SYMBOL_INFO) + 256);\n");
        code = concat_c(code, "    if (!symbol) return;\n");
        code = concat_c(code, "    memset(symbol, 0, sizeof(SYMBOL_INFO) + 256);\n");
        code = concat_c(code, "    symbol->MaxNameLen = 255;\n");
        code = concat_c(code, "    symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n");
        code = concat_c(code, "\n");
        code = concat_c(code, "    for (USHORT i = 0; i < frames; i++) {\n");
        code = concat_c(code, "        DWORD64 address = (DWORD64)(stack[i]);\n");
        code = concat_c(code, "        if (SymFromAddr(process, address, 0, symbol)) {\n");
        code = concat_c(code, "            fprintf(stderr, \"  #%02u 0x%llx %s\\n\", (unsigned)i, (unsigned long long)address, symbol->Name);\n");
        code = concat_c(code, "        } else {\n");
        code = concat_c(code, "            fprintf(stderr, \"  #%02u 0x%llx <unknown>\\n\", (unsigned)i, (unsigned long long)address);\n");
        code = concat_c(code, "        }\n");
        code = concat_c(code, "    }\n");
        code = concat_c(code, "    free(symbol);\n");
        code = concat_c(code, "}\n");
        code = concat_c(code, "\n");
        code = concat_c(code, "static LONG WINAPI axe_unhandled_exception_filter(EXCEPTION_POINTERS* info) {\n");
        code = concat_c(code, "    (void)info;\n");
        code = concat_c(code, "    fprintf(stderr, \"Fatal: Unhandled exception.\\n\");\n");
        code = concat_c(code, "    axe_win_print_backtrace();\n");
        code = concat_c(code, "    fflush(stderr);\n");
        code = concat_c(code, "    ExitProcess(1);\n");
        code = concat_c(code, "    return EXCEPTION_EXECUTE_HANDLER;\n");
        code = concat_c(code, "}\n");
    }
    
    platform posix {
        code = concat_c(code, "static void axe_segv_handler(int sig) {\n");
        code = concat_c(code, "    const char* name = (sig == SIGSEGV ? \"SIGSEGV\" : (sig == SIGABRT ? \"SIGABRT\" : \"SIGNAL\"));\n");
        code = concat_c(code, "    fprintf(stderr, \"Fatal: %s received.\\n\", name);\n");
        code = concat_c(code, "    void* frames[64];\n");
        code = concat_c(code, "    int n = backtrace(frames, 64);\n");
        code = concat_c(code, "    if (n > 0) {\n");
        code = concat_c(code, "        fprintf(stderr, \"Backtrace (%d frames):\\n\", n);\n");
        code = concat_c(code, "        backtrace_symbols_fd(frames, n, fileno(stderr));\n");
        code = concat_c(code, "    }\n");
        code = concat_c(code, "    fflush(stderr);\n");
        code = concat_c(code, "    _exit(139);\n");
        code = concat_c(code, "}\n");
    }
    
    return code;
}

/// Generate stack trace setup code for main function
def generate_stack_trace_setup(): string {
    mut code: string = str("");
    
    platform windows {
        code = concat_c(code, "    SetUnhandledExceptionFilter(axe_unhandled_exception_filter);\n");
    }
    
    platform posix {
        code = concat_c(code, "    signal(SIGSEGV, axe_segv_handler);\n");
        code = concat_c(code, "    signal(SIGABRT, axe_segv_handler);\n");
    }
    
    return code;
}

/// Generate a C function prototype from a Function AST node
def generate_function_prototype(ast: ref ASTNode): string {
    if ast == nil {
        return str("");
    }

    val func_name_raw: string = ast.data.function.name;

    // Do not emit a prototype for main
    if equals_c(func_name_raw, "main") {
        return str("");
    }

    mut func_name: string = func_name_raw;
    mut sep: i32 = -1;
    mut i: i32 = 0;
    val n: i32 = str_len(func_name);
    loop {
        if i + 1 >= n {
            break;
        }
        val c1: char = get_char(func_name, i);
        val c2: char = get_char(func_name, i + 1);
        if c1 == '_' and c2 == '_' {
            sep = i;
        }
        i++;
    }

    if sep >= 0 and sep + 2 < n {
        val model_part: string = substring_se(func_name, 0, sep);
        val method_part: string = substring_se(func_name, sep + 2, n);
        mut has_inner_sep: bool = false;
        mut j: i32 = 0;
        val mlen: i32 = str_len(model_part);
        loop {
            if j + 1 >= mlen {
                break;
            }
            val mc1: char = get_char(model_part, j);
            val mc2: char = get_char(model_part, j + 1);
            if mc1 == '_' and mc2 == '_' {
                has_inner_sep = true;
                break;
            }
            j = j + 1;
        }

        if !has_inner_sep {
            val canon_model: string = canonical_model_c_name(model_part);
            if str_len(canon_model) > 0 {
                mut sb_name: StringBuilder = StringBuilder.init(1256);
                StringBuilder.append(addr(sb_name), canon_model);
                StringBuilder.append_c(addr(sb_name), "__");
                StringBuilder.append(addr(sb_name), method_part);
                func_name = StringBuilder.to_string(addr(sb_name));
                StringBuilder.destroy(addr(sb_name));
            }
        }
    }

    if sep >= 0 {
        if StringStringMap.contains(addr(g_function_prefixes), func_name) {
            func_name = StringStringMap.get(addr(g_function_prefixes), func_name);
        }
    }
    
    mut return_type: string = ast.data.function.return_type;

    if str_len(return_type) == 0 {
        return_type = str("void");
    }

    val mapped_return_type: string = map_axe_type_to_c(return_type);
    mut sb: StringBuilder = StringBuilder.init(1512);

    StringBuilder.append(addr(sb), mapped_return_type);
    StringBuilder.append_char(addr(sb), ' ');
    StringBuilder.append(addr(sb), func_name);
    StringBuilder.append_char(addr(sb), '(');

    val params: ref list(string) = ast.data.function.params;
    if params != nil {
        mut param_idx: i32 = 0;
        loop {
            if param_idx >= len(deref(params)) {
                break;
            }

            if param_idx > 0 {
                StringBuilder.append_c(addr(sb), ", ");
            }

            val param: string = params.data[param_idx];
            val colon_pos: i32 = find_char_from(param, ':', 0);

            if colon_pos >= 0 {
                val param_name: string = strip(substring_se(param, 0, colon_pos));
                val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                val processed_type: string = process_parameter_type(param_type);

                StringBuilder.append(addr(sb), processed_type);
                StringBuilder.append_char(addr(sb), ' ');
                StringBuilder.append(addr(sb), param_name);
            } else {
                StringBuilder.append(addr(sb), param);
            }

            param_idx = param_idx + 1;
        }
    }

    StringBuilder.append_c(addr(sb), ");\n");
    val result: string = StringBuilder.to_string(addr(sb));
    StringBuilder.destroy(addr(sb));
    return result;
}

/// Generate C code for a global variable declaration with gvar__ prefix.
def generate_global_decl(ast: ref ASTNode): string {
    mut result: string = str("");
    if ast == nil {
        return result;
    }
    
    val var_name: string = ast.data.declaration.name;
    mut type_name: string = ast.data.declaration.type_name;
    val is_mutable: bool = ast.data.declaration.is_mutable;
    val initializer: string = ast.data.declaration.initializer;
    
    validate_type_imported(type_name);
    
    mut mapped_type: string = map_axe_type_to_c(type_name);

    if str_len(type_name) == 0 {
        mut trimmed_init: string = strip(initializer);
        if has_prefix(trimmed_init, str("new ")) {
            trimmed_init = substring_se(trimmed_init, 4, str_len(trimmed_init));
            trimmed_init = strip(trimmed_init);
            mut end_pos: i32 = -1;
            mut i: i32 = 0;
            loop {
                if i >= str_len(trimmed_init) {
                    break;
                }
                val ch: char = get_char(trimmed_init, i);
                if ch == '(' or ch == ' ' or ch == '\t' {
                    end_pos = i;
                    break;
                }
                i++;
            }
            if end_pos < 0 {
                end_pos = str_len(trimmed_init);
            }
            val inferred_name: string = strip(substring_se(trimmed_init, 0, end_pos));
            if str_len(inferred_name) > 0 {
                type_name = inferred_name;
                mapped_type = map_axe_type_to_c(type_name);
            }
        } else {
            val brace_pos: i32 = find_char_from(trimmed_init, '{', 0);
            if brace_pos > 0 {
                val inferred_name2: string = strip(substring_se(trimmed_init, 0, brace_pos));
                if str_len(inferred_name2) > 0 {
                    type_name = inferred_name2;
                    mapped_type = map_axe_type_to_c(type_name);
                }
            }
        }
    }

    if str_len(var_name) > 0 and str_len(type_name) > 0 {
        mut arena: Arena = Arena.create(2560);
        StringStringMap.set(addr(g_var_types), addr(arena), var_name, type_name);

        if has_prefix(type_name, str("list(")) {
            mut paren_pos: i32 = 5;
            mut depth: i32 = 1;
            loop {
                if paren_pos >= str_len(type_name) {
                    break;
                }
                val ch: char = get_char(type_name, paren_pos);
                if ch == '(' {
                    depth = depth + 1;
                } elif ch == ')' {
                    depth = depth - 1;
                    if depth == 0 {
                        break;
                    }
                }
                paren_pos = paren_pos + 1;
            }
            val element_type: string = strip(substr(type_name, 5, paren_pos - 5));
            mut list_arena: Arena = Arena.create(2560);
            StringStringMap.set(addr(g_list_of_types), addr(list_arena), var_name, element_type);
        } elif has_suffix(type_name, str("[999]")) {
            val element_type: string = strip(substring_se(type_name, 0, str_len(type_name) - 5));
            mut list_arena: Arena = Arena.create(2560);
            StringStringMap.set(addr(g_list_of_types), addr(list_arena), var_name, element_type);
        }
    }

    val enum_model_name: string = canonical_model_c_name(type_name);
    if str_len(enum_model_name) > 0 and StringBoolMap.contains(addr(g_enum_names), enum_model_name) {
        mapped_type = enum_model_name;
    }

    mut array_suffix: string = str("");
    val br: i32 = find_char_from(type_name, '[', 0);
    if br >= 0 {
        val suffix: string = substring_se(type_name, br, str_len(type_name));
        if !equals_c(suffix, "[999]") {
            val base_raw: string = strip(substring_se(type_name, 0, br));
            if str_len(base_raw) > 0 {
                mapped_type = map_axe_type_to_c(base_raw);
                array_suffix = suffix;
            }
        }
    }

    val emitted_name: string = var_name;

    if is_mutable {
        result = concat(result, mapped_type);
        result = concat_c(result, " ");
        result = concat(result, emitted_name);
        if str_len(array_suffix) > 0 {
            result = concat(result, array_suffix);
        }
    } else {
        result = concat_c(result, "const ");
        result = concat(result, mapped_type);
        result = concat_c(result, " ");
        result = concat(result, emitted_name);
        if str_len(array_suffix) > 0 {
            result = concat(result, array_suffix);
        }
    }

    if str_len(initializer) > 0 {
        val trimmed: string = strip(initializer);
        val brace_idx: i32 = find_char_from(trimmed, '{', 0);
        if brace_idx >= 0 {
            val type_part: string = strip(substring_se(trimmed, 0, brace_idx));
            val brace_part: string = substring_se(trimmed, brace_idx, str_len(trimmed));
            if str_len(type_part) > 0 {
                result = concat_c(result, " = ");
                result = concat(result, brace_part);
            } else {
                result = concat_c(result, " = ");
                result = concat(result, trimmed);
            }
        } else {
            val processed_init: string = process_expression(trimmed);
            result = concat_c(result, " = ");
            result = concat(result, processed_init);
        }
    } else {
        val first_char: char = get_char(mapped_type, 0);
        if first_char >= 'A' and first_char <= 'Z' {
            result = concat_c(result, " = {0}");
        } elif has_prefix(mapped_type, str("__list_")) {
            result = concat_c(result, " = {0}");
        } elif has_prefix(mapped_type, str("std__")) {
            result = concat_c(result, " = {0}");
        }
    }

    result = concat_c(result, ";\n");
    return result;
}

/// Generate C from AST.
pub def generate_c(ast: ref ASTNode): string {
    if ast == nil {
        return str("");
    }

    g_current_line = ast.line;
    g_current_source_file = ast.source_file;

    val node_type: string = ast.node_type;
    mut result: string = str("");
    mut arena: Arena = Arena.create(1024);

    if equals_c(node_type, "MacroExpansion") {
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            val child_count: i32 = len(deref(children));
            if child_count == 0 {
                return str("");
            }
            mut sb_macro: StringBuilder = StringBuilder.init(1024);
            mut i: i32 = 0;
            loop {
                if i >= child_count {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i]));
                StringBuilder.append(addr(sb_macro), child_code);
                i++;
            }
            val result_macro: string = StringBuilder.to_string(addr(sb_macro));
            StringBuilder.destroy(addr(sb_macro));
            return result_macro;
        }
        return str("");
    }

    if equals_c(node_type, "Overload") {
        val name: string = ast.data.overload_node.name;
        mut param_name: string = ast.data.overload_node.param_name;
        mut call_expr: string = ast.data.overload_node.call_expr;

        if str_len(param_name) == 0 {
            param_name = str("x");
        }
        if str_len(call_expr) == 0 {
            call_expr = param_name;
        }

        val type_names_ref: ref list(string) = ast.data.overload_node.type_names;
        val targets_ref: ref list(string) = ast.data.overload_node.target_functions;

        if type_names_ref == nil or targets_ref == nil {
            return str("");
        }

        val count: i32 = len(deref(type_names_ref));

        if count == 0 or count != len(deref(targets_ref)) {
            return str("");
        }

        mut sb_top_level: StringBuilder = StringBuilder.init(1024);
        StringBuilder.append_c(addr(sb_top_level), "#define ");
        StringBuilder.append(addr(sb_top_level), name);
        StringBuilder.append_c(addr(sb_top_level), "(");
        StringBuilder.append(addr(sb_top_level), param_name);
        StringBuilder.append_c(addr(sb_top_level), ") _Generic((");
        StringBuilder.append(addr(sb_top_level), call_expr);
        StringBuilder.append_c(addr(sb_top_level), "), \\\n");

        mut i_ov: i32 = 0;
        loop {
            if i_ov >= count {
                break;
            }

            val axe_type: string = type_names_ref.data[i_ov];
            mut target_name: string = targets_ref.data[i_ov];
            val mapped_type: string = map_axe_type_to_c(axe_type);

            if StringStringMap.contains(addr(g_function_prefixes), target_name) {
                val prefixed_target: string = StringStringMap.get(addr(g_function_prefixes), target_name);
                target_name = prefixed_target;
            }

            StringBuilder.append_c(addr(sb_top_level), "    ");
            StringBuilder.append(addr(sb_top_level), mapped_type);
            StringBuilder.append_c(addr(sb_top_level), ": ");
            StringBuilder.append(addr(sb_top_level), target_name);

            if i_ov < count - 1 {
                StringBuilder.append_c(addr(sb_top_level), ", \\\n");
            } else {
                StringBuilder.append_c(addr(sb_top_level), " \\\n");
            }

            i_ov = i_ov + 1;
        }

        StringBuilder.append_c(addr(sb_top_level), "    )(");
        StringBuilder.append(addr(sb_top_level), call_expr);
        StringBuilder.append_c(addr(sb_top_level), ")\n");

        return StringBuilder.to_string(addr(sb_top_level));
    }
    
    if equals_c(node_type, "Program") {
        // Note: g_current_source_file should be set before calling generate_c
        g_emit_line_directives = true;
        
        mut ext_arena: Arena = Arena.create(4096);
        StringList.clear(g_global_external_headers);
        StringList.clear(g_windows_external_headers);
        StringList.clear(g_posix_external_headers);
        collect_external_imports(ast, str(""), addr(ext_arena));
        collect_foreign_types(ast);
        build_function_signatures(ast);
        
        mut sb: StringBuilder = StringBuilder.init(1024 * 256);
        
        StringBuilder.append_c(addr(sb), "#define nil ((void*)0)\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#define len_ptr(x) ((x)->len)\n#define len_v(x) ((&(x))->len)\n#define len(x) len_v(x)\n");

        platform windows {
            StringBuilder.append_c(addr(sb), "\n#define NOMINMAX\n#define NOGDI\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n");
        }
        
        mut ghi: i32 = 0;
        loop {
            if ghi >= g_global_external_headers*.len {
                break;
            }
            val gh: string = StringList.get(g_global_external_headers, ghi);
            StringBuilder.append_c(addr(sb), "#include <");
            StringBuilder.append(addr(sb), gh);
            StringBuilder.append_c(addr(sb), ">\n");
            ghi = ghi + 1;
        }
        
        if g_windows_external_headers*.len > 0 {
            StringBuilder.append_c(addr(sb), "#ifdef _WIN32\n");
            mut whi: i32 = 0;
            loop {
                if whi >= g_windows_external_headers*.len {
                    break;
                }
                val wh: string = StringList.get(g_windows_external_headers, whi);
                StringBuilder.append_c(addr(sb), "#include <");
                StringBuilder.append(addr(sb), wh);
                StringBuilder.append_c(addr(sb), ">\n");
                whi = whi + 1;
            }
            StringBuilder.append_c(addr(sb), "#endif\n");
        }
        
        if g_posix_external_headers*.len > 0 {
            StringBuilder.append_c(addr(sb), "#ifndef _WIN32\n");
            mut phi: i32 = 0;
            loop {
                if phi >= g_posix_external_headers*.len {
                    break;
                }
                val ph: string = StringList.get(g_posix_external_headers, phi);
                StringBuilder.append_c(addr(sb), "#include <");
                StringBuilder.append(addr(sb), ph);
                StringBuilder.append_c(addr(sb), ">\n");
                phi = phi + 1;
            }
            StringBuilder.append_c(addr(sb), "#endif\n");
        }

        if !::is_release_build {
            val stack_headers: string = generate_stack_trace_headers();
            StringBuilder.append(addr(sb), stack_headers);
        }

        StringBuilder.append_c(addr(sb), "\nint __axe_argc = 0;\nchar** __axe_argv = NULL;\n\n");
        
        // Convert StringBuilder to result string for the rest of the function
        result = StringBuilder.to_string(addr(sb));
        StringBuilder.destroy(addr(sb));
        
        build_function_prefixes(ast);
        build_function_signatures(ast);

        if ast.children != nil {
            mut use_arena: Arena = Arena.create(4096);
            val use_children: ref list(ASTNode) = ast.children;
            val dot_str: string = str(".");
            val underscore_str: string = str("_");
            val double_underscore_str: string = str("__");
            val dash_str: string = str("-");
            mut ui: i32 = 0;
            loop {
                if ui >= len(deref(use_children)) {
                    break;
                }
                val uchild: ref ASTNode = addr(use_children.data[ui]);
                if equals_c(uchild.node_type, "Use") {
                    val module_name: string = uchild.data.use_node.module_name;
                    mut module_prefix: string = replace_all(module_name, dot_str, double_underscore_str);
                    module_prefix = replace_all(module_prefix, dash_str, underscore_str);
                    
                    val imports: ref list(string) = uchild.data.use_node.imports;
                    if imports != nil {
                        mut ii: i32 = 0;
                        loop {
                            if ii >= imports*.len {
                                break;
                            }
                            val import_name: string = imports.data[ii];
                            if str_len(import_name) > 0 {
                                val first_char: char = get_char(import_name, 0);
                                if first_char >= 'a' and first_char <= 'z' {
                                    if !StringStringMap.contains(addr(g_function_prefixes), import_name) {
                                        mut sb_prefix: StringBuilder = StringBuilder.init(str_len(module_prefix) + str_len(import_name) + 2);
                                        StringBuilder.append(addr(sb_prefix), module_prefix);
                                        StringBuilder.append(addr(sb_prefix), double_underscore_str);
                                        StringBuilder.append(addr(sb_prefix), import_name);
                                        val prefixed_name: string = StringBuilder.to_string(addr(sb_prefix));
                                        StringBuilder.destroy(addr(sb_prefix));
                                        StringStringMap.set(addr(g_function_prefixes), addr(use_arena), import_name, prefixed_name);
                                    }
                                }
                            }
                            ii++;
                        }
                    }
                }
                ui++;
            }
        }

        if ast.children != nil {
            val children_for_models: ref list(ASTNode) = ast.children;
            val children_count: i32 = len(deref(children_for_models));
            mut model_name_arena: Arena = Arena.create(1024 * 64);
            mut mi: i32 = 0;
            loop {
                if mi >= children_count {
                    break;
                }
                val mchild: ref ASTNode = addr(children_for_models.data[mi]);
                if equals_c(mchild.node_type, "Model") or equals_c(mchild.node_type, "Enum") {
                    mut cname: string = str("");
                    if equals_c(mchild.node_type, "Model") {
                        cname = mchild.data.model_node.name;
                    } else {
                        cname = mchild.data.enum_node.name;
                    }

                    mut base: string = cname;
                    mut last_sep: i32 = -1;
                    mut bi: i32 = 0;
                    val nlen: i32 = str_len(cname);
                    loop {
                        if bi + 1 >= nlen {
                            break;
                        }
                        val c1: char = get_char(cname, bi);
                        val c2: char = get_char(cname, bi + 1);
                        if c1 == '_' and c2 == '_' {
                            last_sep = bi;
                        }
                        bi++;
                    }
                    if last_sep >= 0 and last_sep + 2 < nlen {
                        base = substring_se(cname, last_sep + 2, nlen);
                    }

                    if str_len(base) > 0 {
                        StringStringMap.set(addr(g_model_names), addr(model_name_arena), base, cname);
                    }
                    StringStringMap.set(addr(g_model_names), addr(model_name_arena), cname, cname);
                    
                    if equals_c(mchild.node_type, "Enum") {
                        StringBoolMap.set(addr(g_enum_names), addr(model_name_arena), cname, true);
                        if str_len(base) > 0 {
                            StringBoolMap.set(addr(g_enum_names), addr(model_name_arena), base, true);
                        }
                    }
                }
                mi++;
            }

            val children: ref list(ASTNode) = ast.children;
            val children_len: i32 = len(deref(children));

            StringBoolMap.clear(addr(g_list_element_types));

            mut i_scan: i32 = 0;
            loop {
                if i_scan >= children_len {
                    break;
                }
                scan_for_list_types(addr(children.data[i_scan]));
                i_scan++;
            }

            mut i_more: i32 = 0;
            loop {
                if i_more >= children_len {
                    break;
                }
                val cnode: ref ASTNode = addr(children.data[i_more]);
                if equals_c(cnode.node_type, "Function") {
                    val ret_type: string = cnode.data.function.return_type;
                    val br: i32 = find_char_from(ret_type, '[', 0);
                    if br >= 0 and find_char_from(ret_type, ']', br) >= 0 {
                        mut elementType: string = strip(substring_se(ret_type, 0, br));
                        if has_prefix(elementType, str("ref ")) {
                            elementType = strip(substr(elementType, 4, str_len(elementType) - 4));
                        }
                        val mappedC: string = map_axe_type_to_c(elementType);
                        add_list_element(mappedC);
                    }
                } elif equals_c(cnode.node_type, "Model") {
                    val field_names: ref list(string) = cnode.data.model_node.field_names;
                    val field_types: ref list(string) = cnode.data.model_node.field_types;
                    if field_names != nil and field_types != nil {
                        mut fidx: i32 = 0;
                        loop {
                            if fidx >= len(deref(field_types)) or fidx >= len(deref(field_names)) {
                                break;
                            }
                            val ftype: string = field_types.data[fidx];
                            val br2: i32 = find_char_from(ftype, '[', 0);
                            if br2 >= 0 and find_char_from(ftype, ']', br2) >= 0 {
                                mut elemCandidate: string = strip(substring_se(ftype, 0, br2));
                                if has_prefix(elemCandidate, str("ref ")) {
                                    elemCandidate = strip(substr(elemCandidate, 4, str_len(elemCandidate) - 4));
                                }
                                val mappedElem: string = map_axe_type_to_c(elemCandidate);
                                add_list_element(mappedElem);
                            }
                            fidx++;
                        }
                    }
                    val union_member_types: ref list(string) = cnode.data.model_node.union_member_types;
                    if union_member_types != nil {
                        mut uidx: i32 = 0;
                        loop {
                            if uidx >= len(deref(union_member_types)) {
                                break;
                            }
                            val utype: string = union_member_types.data[uidx];
                            val ubr: i32 = find_char_from(utype, '[', 0);
                            if ubr >= 0 and find_char_from(utype, ']', ubr) >= 0 {
                                mut uElemCandidate: string = strip(substring_se(utype, 0, ubr));
                                if has_prefix(uElemCandidate, str("ref ")) {
                                    uElemCandidate = strip(substr(uElemCandidate, 4, str_len(uElemCandidate) - 4));
                                }
                                val mappedUElem: string = map_axe_type_to_c(uElemCandidate);
                                add_list_element(mappedUElem);
                            }
                            uidx++;
                        }
                    }
                }
                i_more++;
            }

            mut sb_fwd: StringBuilder = StringBuilder.init(4096);            
            mut i_models2: i32 = 0;

            loop {
                if i_models2 >= children_len {
                    break;
                }
                val m_child: ref ASTNode = addr(children.data[i_models2]);
                if equals_c(m_child.node_type, "Model") {
                    mut name: string = str("");
                    name = m_child.data.model_node.name;
                    if !StringBoolMap.contains(addr(g_generated_typedefs), name) {
                        StringBuilder.append_c(addr(sb_fwd), "struct ");
                        StringBuilder.append(addr(sb_fwd), name);
                        StringBuilder.append_c(addr(sb_fwd), ";\n");
                    }
                }
                i_models2++;
            }

            mut i_models3: i32 = 0;
            loop {
                if i_models3 >= children_len {
                    break;
                }
                val m_child: ref ASTNode = addr(children.data[i_models3]);
                if equals_c(m_child.node_type, "Model") {
                    mut name2: string = str("");
                    name2 = m_child.data.model_node.name;
                    if !StringBoolMap.contains(addr(g_generated_typedefs), name2) {
                        StringBuilder.append_c(addr(sb_fwd), "typedef struct ");
                        StringBuilder.append(addr(sb_fwd), name2);
                        StringBuilder.append_char(addr(sb_fwd), ' ');
                        StringBuilder.append(addr(sb_fwd), name2);
                        StringBuilder.append_c(addr(sb_fwd), ";\n");
                    }
                }
                i_models3++;
            }
            
            mut sb_prog: StringBuilder = StringBuilder.init(1024 * 512);
            StringBuilder.append(addr(sb_prog), result);
            StringBuilder.append(addr(sb_prog), StringBuilder.to_string(addr(sb_fwd)));
            StringBuilder.destroy(addr(sb_fwd));

            if g_list_elements != nil {
                val lst_ref: ref StringList = g_list_elements;
                mut li: i32 = 0;
                loop {
                    if li >= lst_ref*.len {
                        break;
                    }
                    val elemTypeStr: string = StringList.get(lst_ref, li);
                    val san: string = sanitize_list_element_name(elemTypeStr);
                    StringBuilder.append_c(addr(sb_prog), "typedef struct __list_");
                    StringBuilder.append(addr(sb_prog), san);
                    StringBuilder.append_c(addr(sb_prog), "_t __list_");
                    StringBuilder.append(addr(sb_prog), san);
                    StringBuilder.append_c(addr(sb_prog), "_t;\n");
                    li = li + 1;
                }
            }

            mut i_opaque_plat: i32 = 0;
            loop {
                if i_opaque_plat >= children_len {
                    break;
                }
                val op_plat: ref ASTNode = addr(children.data[i_opaque_plat]);
                if equals_c(op_plat.node_type, "Platform") {
                    val platform_name: string = op_plat.data.platform_node.platform_name;
                    mut has_opaque: bool = false;
                    
                    if op_plat.children != nil {
                        val plat_children: ref list(ASTNode) = op_plat.children;
                        mut oc: i32 = 0;
                        loop {
                            if oc >= len(deref(plat_children)) {
                                break;
                            }
                            val oc_child: ref ASTNode = addr(plat_children.data[oc]);
                            if equals_c(oc_child.node_type, "Opaque") or equals_c(oc_child.node_type, "Foreign") {
                                has_opaque = true;
                                break;
                            }
                            oc++;
                        }
                    }
                    
                    if has_opaque {
                        if equals_c(platform_name, "windows") {
                            StringBuilder.append_c(addr(sb_prog), "#ifdef _WIN32\n");
                        } elif equals_c(platform_name, "posix") {
                            StringBuilder.append_c(addr(sb_prog), "#ifndef _WIN32\n");
                        }
                        val plat_children2: ref list(ASTNode) = op_plat.children;
                        mut oc2: i32 = 0;
                        loop {
                            if oc2 >= len(deref(plat_children2)) {
                                break;
                            }
                            val oc_child2: ref ASTNode = addr(plat_children2.data[oc2]);
                            if equals_c(oc_child2.node_type, "Opaque") {
                                val opaque_code: string = generate_c(oc_child2);
                                StringBuilder.append(addr(sb_prog), opaque_code);
                            } elif equals_c(oc_child2.node_type, "Foreign") {
                                val foreign_code: string = generate_c(oc_child2);
                                StringBuilder.append(addr(sb_prog), foreign_code);
                            }
                            oc2++;
                        }
                        StringBuilder.append_c(addr(sb_prog), "#endif\n");
                    }
                }
                i_opaque_plat++;
            }

            mut i_enums: i32 = 0;
            loop {
                if i_enums >= children_len {
                    break;
                }
                val enum_child: ref ASTNode = addr(children.data[i_enums]);
                if equals_c(enum_child.node_type, "Enum") {
                    val e_code: string = generate_c(enum_child);
                    StringBuilder.append(addr(sb_prog), e_code);
                }
                i_enums = i_enums + 1;
            }

            // Topological sort of models to ensure dependencies come first
            // Step 1: Collect all model names and build model map
            mut model_arena: Arena = Arena.create(1024 * 64);
            mut model_names_list: ref StringList = StringList.create(addr(model_arena), 64);
            mut model_indices: StringIntMap = deref(StringIntMap.create(addr(model_arena), 128));
            
            mut collect_idx: i32 = 0;
            loop {
                if collect_idx >= children_len {
                    break;
                }
                val collect_child: ref ASTNode = addr(children.data[collect_idx]);
                if equals_c(collect_child.node_type, "Model") {
                    val mname: string = collect_child.data.model_node.name;
                    mut cname: string = canonical_model_c_name(mname);

                    if str_len(cname) == 0 {
                        cname = mname;
                    }

                    if !StringIntMap.contains(addr(model_indices), cname) {
                        StringList.push(model_names_list, addr(model_arena), cname);
                        StringIntMap.set(addr(model_indices), addr(model_arena), cname, model_names_list.len - 1);
                    }
                }
                collect_idx = collect_idx + 1;
            }
            
            // Step 2: Build dependency adjacency lists
            // deps[i] contains list of model indices that model i depends on
            val num_models: i32 = model_names_list.len;
            
            mut deps_lists: ref StringList = StringList.create(addr(model_arena), num_models + 1);
            mut dep_init: i32 = 0;
            loop {
                if dep_init >= num_models {
                    break;
                }
                StringList.push(deps_lists, addr(model_arena), str(""));
                dep_init = dep_init + 1;
            }
            
            mut build_deps_idx: i32 = 0;
            loop {
                if build_deps_idx >= children_len {
                    break;
                }
                val bdep_child: ref ASTNode = addr(children.data[build_deps_idx]);
                if equals_c(bdep_child.node_type, "Model") {
                    val raw_model_name: string = bdep_child.data.model_node.name;
                    mut this_model_name: string = canonical_model_c_name(raw_model_name);
                    if str_len(this_model_name) == 0 {
                        this_model_name = raw_model_name;
                    }
                    // Cache model index since it's used multiple times in loop
                    val this_model_idx: i32 = StringIntMap.get(addr(model_indices), this_model_name);
                    val ftypes: ref list(string) = bdep_child.data.model_node.field_types;

                    if ftypes != nil {
                        mut ft_idx: i32 = 0;
                        loop {
                            if ft_idx >= len(deref(ftypes)) {
                                break;
                            }

                            val ftype: string = ftypes.data[ft_idx];
                            val base_type: string = get_base_type_from_field(ftype);
                            mut mapped_type: string = map_axe_type_to_c(base_type);

                            if !StringIntMap.contains(addr(model_indices), mapped_type) {
                                if StringIntMap.contains(addr(model_indices), base_type) {
                                    mapped_type = base_type;
                                }
                            }
                            if StringIntMap.contains(addr(model_indices), mapped_type) {
                                if compare(mapped_type, this_model_name) != 0 {
                                    val current_deps: string = StringList.get(deps_lists, this_model_idx);
                                    if str_len(current_deps) == 0 {
                                        deps_lists.data[this_model_idx] = mapped_type;
                                    } else {
                                        if find_substr(current_deps, mapped_type) < 0 {
                                            mut sb_deps: StringBuilder = StringBuilder.init(str_len(current_deps) + str_len(mapped_type) + 1);
                                            StringBuilder.append(addr(sb_deps), current_deps);
                                            StringBuilder.append_c(addr(sb_deps), ",");
                                            StringBuilder.append(addr(sb_deps), mapped_type);
                                            deps_lists.data[this_model_idx] = StringBuilder.to_string(addr(sb_deps));
                                            StringBuilder.destroy(addr(sb_deps));
                                        }
                                    }
                                }
                            }
                            ft_idx = ft_idx + 1;
                        }
                    }
                    
                    val union_types: ref list(string) = bdep_child.data.model_node.union_member_types;
                    if union_types != nil {
                        mut ut_idx: i32 = 0;
                        loop {
                            if ut_idx >= len(deref(union_types)) {
                                break;
                            }
                            val utype: string = union_types.data[ut_idx];
                            val ubase_type: string = get_base_type_from_field(utype);
                            mut umapped_type: string = map_axe_type_to_c(ubase_type);

                            if !StringIntMap.contains(addr(model_indices), umapped_type) {
                                if StringIntMap.contains(addr(model_indices), ubase_type) {
                                    umapped_type = ubase_type;
                                }
                            }

                            if StringIntMap.contains(addr(model_indices), umapped_type) {
                                if compare(umapped_type, this_model_name) != 0 {
                                    val current_deps: string = StringList.get(deps_lists, this_model_idx);
                                    if str_len(current_deps) == 0 {
                                        deps_lists.data[this_model_idx] = umapped_type;
                                    } else {
                                        if find_substr(current_deps, umapped_type) < 0 {
                                            mut sb_udeps: StringBuilder = StringBuilder.init(str_len(current_deps) + str_len(umapped_type) + 1);
                                            StringBuilder.append(addr(sb_udeps), current_deps);
                                            StringBuilder.append_c(addr(sb_udeps), ",");
                                            StringBuilder.append(addr(sb_udeps), umapped_type);
                                            deps_lists.data[this_model_idx] = StringBuilder.to_string(addr(sb_udeps));
                                            StringBuilder.destroy(addr(sb_udeps));
                                        }
                                    }
                                }
                            }
                            ut_idx = ut_idx + 1;
                        }
                    }
                }
                build_deps_idx = build_deps_idx + 1;
            }
            
            mut visit_state: ref IntList = IntList.create(addr(model_arena), num_models + 1);
            mut vs_init: i32 = 0;
            loop {
                if vs_init >= num_models {
                    break;
                }
                IntList.push(visit_state, addr(model_arena), 0);
                vs_init = vs_init + 1;
            }
            
            mut sorted_order: ref StringList = StringList.create(addr(model_arena), num_models + 1);
            
            mut start_node: i32 = 0;
            loop {
                if start_node >= num_models {
                    break;
                }
                
                if IntList.get(visit_state, start_node) == 2 {
                    start_node = start_node + 1;
                    continue;
                }
                
                // Manual DFS stack: pairs of (node_index, phase)
                // phase 0 = first visit (mark visiting, push deps)
                // phase 1 = done with deps (mark visited, add to sorted)
                mut stack_nodes: ref IntList = IntList.create(addr(model_arena), 256);
                mut stack_phases: ref IntList = IntList.create(addr(model_arena), 256);
                
                IntList.push(stack_nodes, addr(model_arena), start_node);
                IntList.push(stack_phases, addr(model_arena), 0);
                
                loop {
                    if stack_nodes.len == 0 {
                        break;
                    }
                    
                    val curr_node: i32 = IntList.get(stack_nodes, stack_nodes.len - 1);
                    val curr_phase: i32 = IntList.get(stack_phases, stack_phases.len - 1);
                    
                    stack_nodes.len = stack_nodes.len - 1;
                    stack_phases.len = stack_phases.len - 1;
                    
                    val curr_state: i32 = IntList.get(visit_state, curr_node);
                    
                    if curr_state == 2 {
                        continue;
                    }
                    
                    if curr_phase == 0 {
                        if curr_state == 1 {
                            continue;
                        }
                        
                        visit_state.data[curr_node] = 1;
                        
                        IntList.push(stack_nodes, addr(model_arena), curr_node);
                        IntList.push(stack_phases, addr(model_arena), 1);
                        
                        val deps_str: string = StringList.get(deps_lists, curr_node);
                        if str_len(deps_str) > 0 {
                            mut dep_start: i32 = 0;
                            mut dep_pos: i32 = 0;
                            loop {
                                if dep_pos > str_len(deps_str) {
                                    break;
                                }
                                
                                mut is_sep: bool = dep_pos == str_len(deps_str);
                                if !is_sep {
                                    is_sep = get_char(deps_str, dep_pos) == ',';
                                }
                                
                                if is_sep {
                                    if dep_pos > dep_start {
                                        val dep_name: string = substr(deps_str, dep_start, dep_pos - dep_start);
                                        if StringIntMap.contains(addr(model_indices), dep_name) {
                                            val dep_idx: i32 = StringIntMap.get(addr(model_indices), dep_name);
                                            if IntList.get(visit_state, dep_idx) != 2 {
                                                IntList.push(stack_nodes, addr(model_arena), dep_idx);
                                                IntList.push(stack_phases, addr(model_arena), 0);
                                            }
                                        }
                                    }
                                    dep_start = dep_pos + 1;
                                }
                                dep_pos++;
                            }
                        }
                    } else {
                        // Phase 1: mark visited and add to sorted order
                        visit_state.data[curr_node] = 2;
                        val model_name: string = StringList.get(model_names_list, curr_node);
                        StringList.push(sorted_order, addr(model_arena), model_name);
                    }
                }
                
                start_node = start_node + 1;
            }
            
            // Step 4: Generate models in sorted order (dependencies first)
            mut sorted_idx: i32 = 0;
            loop {
                if sorted_idx >= sorted_order.len {
                    break;
                }
                val sorted_name: string = StringList.get(sorted_order, sorted_idx);
                
                mut find_idx: i32 = 0;
                loop {
                    if find_idx >= len(deref(children)) {
                        break;
                    }
                    val find_child: ref ASTNode = addr(children.data[find_idx]);
                    if equals_c(find_child.node_type, "Model") {
                        if compare(find_child.data.model_node.name, sorted_name) == 0 {
                            val m_code: string = generate_c(find_child);
                            StringBuilder.append(addr(sb_prog), m_code);
                            break;
                        }
                    }
                    find_idx++;
                }
                
                sorted_idx++;
            }

            if g_list_elements != nil {
                val lst_ref2: ref StringList = g_list_elements;
                mut ld: i32 = 0;
                loop {
                    if ld >= lst_ref2*.len {
                        break;
                    }
                    val elemType: string = StringList.get(lst_ref2, ld);
                    val elemSanDef: string = sanitize_list_element_name(elemType);

                    StringBuilder.append_c(addr(sb_prog), "typedef struct __list_");
                    StringBuilder.append(addr(sb_prog), elemSanDef);
                    StringBuilder.append_c(addr(sb_prog), "_t {\n    ");
                    StringBuilder.append(addr(sb_prog), elemType);
                    StringBuilder.append_c(addr(sb_prog), "* data;\n    int len;\n    int capacity;\n} __list_");
                    StringBuilder.append(addr(sb_prog), elemSanDef);
                    StringBuilder.append_c(addr(sb_prog), "_t;\n\n");
                    StringBuilder.append_c(addr(sb_prog), "static inline __list_");
                    StringBuilder.append(addr(sb_prog), elemSanDef);
                    StringBuilder.append_c(addr(sb_prog), "_t __list_");
                    StringBuilder.append(addr(sb_prog), elemSanDef);
                    StringBuilder.append_c(addr(sb_prog), "_init(void) {\n    __list_");
                    StringBuilder.append(addr(sb_prog), elemSanDef);
                    StringBuilder.append_c(addr(sb_prog), "_t list;\n    list.data = NULL;\n    list.len = 0;\n    list.capacity = 0;\n    return list;\n}\n\n");
                    StringBuilder.append_c(addr(sb_prog), "static inline void __list_");
                    StringBuilder.append(addr(sb_prog), elemSanDef);
                    StringBuilder.append_c(addr(sb_prog), "_push(__list_");
                    StringBuilder.append(addr(sb_prog), elemSanDef);
                    StringBuilder.append_c(addr(sb_prog), "_t* list, ");
                    StringBuilder.append(addr(sb_prog), elemType);
                    StringBuilder.append_c(addr(sb_prog), " item) {\n    if (list->len >= list->capacity) {\n        int new_capacity = list->capacity == 0 ? 8 : list->capacity * 2;\n        ");
                    StringBuilder.append(addr(sb_prog), elemType);
                    StringBuilder.append_c(addr(sb_prog), "* new_data = (");
                    StringBuilder.append(addr(sb_prog), elemType);
                    StringBuilder.append_c(addr(sb_prog), "*)realloc(list->data, new_capacity * sizeof(");
                    StringBuilder.append(addr(sb_prog), elemType);
                    StringBuilder.append_c(addr(sb_prog), "));\n        if (new_data == NULL) { fprintf(stderr, \"Out of memory\\n\"); exit(1); }\n        list->data = new_data;\n        list->capacity = new_capacity;\n    }\n    list->data[list->len++] = item;\n}\n\n");

                    ld++;
                }
            }

            mut global_arena: Arena = Arena.create(4096);
            mut i_globals_collect: i32 = 0;

            loop {
                if i_globals_collect >= children_len {
                    break;
                }
                val g_child_collect: ref ASTNode = addr(children.data[i_globals_collect]);
                if equals_c(g_child_collect.node_type, "Declaration") {
                    val var_name: string = g_child_collect.data.declaration.name;
                    if !StringBoolMap.contains(addr(g_emitted_globals), var_name) {
                        StringBoolMap.set(addr(g_emitted_globals), addr(global_arena), var_name, true);
                    }
                } elif equals_c(g_child_collect.node_type, "Platform") {
                    if g_child_collect.children != nil {
                        val plat_children_collect: ref list(ASTNode) = g_child_collect.children;
                        mut plat_idx: i32 = 0;
                        loop {
                            if plat_idx >= len(deref(plat_children_collect)) {
                                break;
                            }
                            val plat_decl: ref ASTNode = addr(plat_children_collect.data[plat_idx]);
                            if equals_c(plat_decl.node_type, "Declaration") {
                                val plat_var_name: string = plat_decl.data.declaration.name;
                                if !StringBoolMap.contains(addr(g_emitted_globals), plat_var_name) {
                                    StringBoolMap.set(addr(g_emitted_globals), addr(global_arena), plat_var_name, true);
                                }
                            }
                            plat_idx++;
                        }
                    }
                }
                i_globals_collect++;
            }
            
            mut generated_arena: Arena = Arena.create(4096);
            mut generated_in_this_pass: StringBoolMap = deref(StringBoolMap.create(addr(generated_arena), 128));
            mut i_globals: i32 = 0;

            loop {
                if i_globals >= children_len {
                    break;
                }
                val g_child: ref ASTNode = addr(children.data[i_globals]);
                if equals_c(g_child.node_type, "Declaration") {
                    val var_name: string = g_child.data.declaration.name;
                    if !StringBoolMap.contains(addr(generated_in_this_pass), var_name) {
                        StringBoolMap.set(addr(generated_in_this_pass), addr(generated_arena), var_name, true);
                        val g_code: string = generate_global_decl(g_child);
                        if str_len(g_code) > 0 {
                            StringBuilder.append(addr(sb_prog), g_code);
                        }
                    }
                }
                i_globals++;
            }

            mut i_proto: i32 = 0;
            loop {
                if i_proto >= children_len {
                    break;
                }
                val proto_child: ref ASTNode = addr(children.data[i_proto]);
                if equals_c(proto_child.node_type, "Function") {
                    val proto_code: string = generate_function_prototype(proto_child);
                    if str_len(proto_code) > 0 {
                        StringBuilder.append(addr(sb_prog), proto_code);
                    }
                }
                if equals_c(proto_child.node_type, "Platform") {
                    val platform_name: string = proto_child.data.platform_node.platform_name;
                    if equals_c(platform_name, "windows") {
                        StringBuilder.append_c(addr(sb_prog), "#ifdef _WIN32\n");
                    } elif equals_c(platform_name, "posix") {
                        StringBuilder.append_c(addr(sb_prog), "#ifndef _WIN32\n");
                    }
                    if proto_child.children != nil {
                        val plat_children: ref list(ASTNode) = proto_child.children;
                        mut pi: i32 = 0;
                        loop {
                            if pi >= len(deref(plat_children)) {
                                break;
                            }
                            val plat_child: ref ASTNode = addr(plat_children.data[pi]);
                            if equals_c(plat_child.node_type, "Function") {
                                val plat_proto: string = generate_function_prototype(plat_child);
                                if str_len(plat_proto) > 0 {
                                    StringBuilder.append(addr(sb_prog), plat_proto);
                                }
                            }
                            pi++;
                        }
                    }
                    StringBuilder.append_c(addr(sb_prog), "#endif\n");
                }
                i_proto++;
            }
            StringBuilder.append_char(addr(sb_prog), '\n');

            mut i: i32 = 0;
            loop {
                if i >= children_len {
                    break;
                }
                val child: ref ASTNode = addr(children.data[i]);
                if equals_c(child.node_type, "Overload") {
                    val ov_code: string = generate_c(child);
                    StringBuilder.append(addr(sb_prog), ov_code);
                    StringBuilder.append_char(addr(sb_prog), '\n');
                }
                i++;
            }

            i = 0;
            loop {
                if i >= children_len {
                    break;
                }
                val fn_child: ref ASTNode = addr(children.data[i]);
                if equals_c(fn_child.node_type, "Function") {
                    val fn_name: string = fn_child.data.function.name;
                    if !equals_c(fn_name, "main") {
                        val fn_code: string = generate_c(fn_child);
                        StringBuilder.append(addr(sb_prog), fn_code);
                    }
                }
                if equals_c(fn_child.node_type, "Platform") {
                    val platform_name: string = fn_child.data.platform_node.platform_name;
                    if equals_c(platform_name, "windows") {
                        StringBuilder.append_c(addr(sb_prog), "#ifdef _WIN32\n");
                    } elif equals_c(platform_name, "posix") {
                        StringBuilder.append_c(addr(sb_prog), "#ifndef _WIN32\n");
                    }
                    if fn_child.children != nil {
                        val plat_children: ref list(ASTNode) = fn_child.children;
                        mut pi: i32 = 0;
                        loop {
                            if pi >= len(deref(plat_children)) {
                                break;
                            }
                            val plat_child: ref ASTNode = addr(plat_children.data[pi]);
                            if equals_c(plat_child.node_type, "Function") {
                                val plat_fn_name: string = plat_child.data.function.name;
                                if !equals_c(plat_fn_name, "main") {
                                    val plat_fn_code: string = generate_c(plat_child);
                                    StringBuilder.append(addr(sb_prog), plat_fn_code);
                                }
                            }
                            pi++;
                        }
                    }
                    StringBuilder.append_c(addr(sb_prog), "#endif\n");
                }
                i++;
            }

            mut i_main_idx: i32 = 0;
            loop {
                if i_main_idx >= children_len {
                    break;
                }
                val fnn: ref ASTNode = addr(children.data[i_main_idx]);
                if equals_c(fnn.node_type, "Function") {
                    val namecheck: string = fnn.data.function.name;
                    if equals_c(namecheck, "main") {
                        val main_code: string = generate_c(fnn);
                        StringBuilder.append(addr(sb_prog), main_code);
                        break;
                    }
                }
                i_main_idx++;
            }

            i = 0;
            loop {
                if i >= children_len {
                    break;
                }
                val child2: ref ASTNode = addr(children.data[i]);
                if !equals_c(child2.node_type, "Overload") and !equals_c(child2.node_type, "Function") 
                    and !equals_c(child2.node_type, "Model") and !equals_c(child2.node_type, "Enum") 
                    and !equals_c(child2.node_type, "Declaration") and !equals_c(child2.node_type, "Platform") {
                    val child_code: string = generate_c(child2);
                    StringBuilder.append(addr(sb_prog), child_code);
                }
                i++;
            }
            
            i = 0;
            loop {
                if i >= children_len {
                    break;
                }
                val plat_node: ref ASTNode = addr(children.data[i]);
                if equals_c(plat_node.node_type, "Platform") {
                    val platform_name: string = plat_node.data.platform_node.platform_name;
                    mut has_non_func_content: bool = false;
                    
                    if plat_node.children != nil {
                        val plat_children: ref list(ASTNode) = plat_node.children;
                        mut pc: i32 = 0;
                        loop {
                            if pc >= len(deref(plat_children)) {
                                break;
                            }
                            val pc_child: ref ASTNode = addr(plat_children.data[pc]);
                            if !equals_c(pc_child.node_type, "Function") {
                                has_non_func_content = true;
                                break;
                            }
                            pc++;
                        }
                    }
                    
                    if has_non_func_content {
                        if equals_c(platform_name, "windows") {
                            StringBuilder.append_c(addr(sb_prog), "#ifdef _WIN32\n");
                        } elif equals_c(platform_name, "posix") {
                            StringBuilder.append_c(addr(sb_prog), "#ifndef _WIN32\n");
                        }
                        if plat_node.children != nil {
                            val plat_children2: ref list(ASTNode) = plat_node.children;
                            mut pc2: i32 = 0;
                            loop {
                                if pc2 >= len(deref(plat_children2)) {
                                    break;
                                }
                                val pc_child2: ref ASTNode = addr(plat_children2.data[pc2]);
                                // Skip functions - they were already emitted
                                if !equals_c(pc_child2.node_type, "Function") {
                                    val pc_code: string = generate_c(pc_child2);
                                    StringBuilder.append(addr(sb_prog), pc_code);
                                }
                                pc2 = pc2 + 1;
                            }
                        }
                        StringBuilder.append_c(addr(sb_prog), "#endif\n");
                    }
                }
                i++;
            }
            
            result = StringBuilder.to_string(addr(sb_prog));
            StringBuilder.destroy(addr(sb_prog));
        }
        result = replace_all(result, str("(->"), str("->"));

        mut fixed_result: string = str("");
        mut start_idx: i32 = 0;
        mut idx_line: i32 = 0;
        loop {
            if idx_line >= str_len(result) {
                if start_idx < idx_line {
                    val last_line: string = substring_se(result, start_idx, idx_line);
                    mut line_fixed: string = last_line;

                    val trimmed_last: string = strip(last_line);
                    if has_suffix(trimmed_last, str(");")) {
                        mut eq_pos: i32 = -1;
                        mut in_string_eq: bool = false;
                        mut ei: i32 = 0;
                        loop {
                            if ei >= str_len(last_line) {
                                break;
                            }
                            val ec: char = get_char(last_line, ei);
                            if ec == '"' and (ei == 0 or get_char(last_line, ei - 1) != '\\') {
                                in_string_eq = !in_string_eq;
                            }
                            if ec == '=' and !in_string_eq {
                                eq_pos = ei;
                                break;
                            }
                            ei = ei + 1;
                        }

                        if eq_pos >= 0 {
                            mut open_p: i32 = 0;
                            mut close_p: i32 = 0;
                            mut in_string_p: bool = false;
                            mut pi: i32 = eq_pos + 1;
                            loop {
                                if pi >= str_len(last_line) {
                                    break;
                                }
                                val c: char = get_char(last_line, pi);
                                if c == '"' and (pi == 0 or get_char(last_line, pi - 1) != '\\') {
                                    in_string_p = !in_string_p;
                                } elif !in_string_p {
                                    if c == '(' {
                                        open_p = open_p + 1;
                                    } elif c == ')' {
                                        close_p = close_p + 1;
                                    } elif c == ';' {
                                        break;
                                    }
                                }
                                pi = pi + 1;
                            }

                            if close_p == open_p + 1 {
                                mut semi_idx: i32 = -1;
                                mut sj: i32 = str_len(last_line) - 1;
                                loop {
                                    if sj < 0 {
                                        break;
                                    }
                                    if get_char(last_line, sj) == ';' {
                                        semi_idx = sj;
                                        break;
                                    }
                                    sj = sj - 1;
                                }

                                if semi_idx > 0 {
                                    mut close_idx: i32 = semi_idx - 1;
                                    loop {
                                        if close_idx < 0 {
                                            break;
                                        }
                                        val cc: char = get_char(last_line, close_idx);
                                        if cc == ' ' or cc == '\t' or cc == '\n' {
                                            close_idx = close_idx - 1;
                                            continue;
                                        }
                                        break;
                                    }

                                    if close_idx >= 0 and get_char(last_line, close_idx) == ')' {
                                        mut tmp: string = str("");
                                        tmp = concat(tmp, substring_se(last_line, 0, close_idx));
                                        tmp = concat(tmp, substring_se(last_line, close_idx + 1, str_len(last_line)));
                                        line_fixed = tmp;
                                    }
                                }
                            }
                        }
                    }

                    fixed_result = concat(fixed_result, line_fixed);
                }
                break;
            }

            val ch: char = get_char(result, idx_line);
            if ch == '\n' {
                val line: string = substring_se(result, start_idx, idx_line + 1);
                mut line_fixed2: string = line;

                val trimmed: string = strip(line);

                if has_suffix(trimmed, str(");")) and !has_prefix(trimmed, str("return ")) {
                    mut eq_pos2: i32 = -1;
                    mut in_string_eq2: bool = false;
                    mut ei2: i32 = 0;
                    loop {
                        if ei2 >= str_len(line) {
                            break;
                        }
                        val ec2: char = get_char(line, ei2);
                        if ec2 == '"' and (ei2 == 0 or get_char(line, ei2 - 1) != '\\') {
                            in_string_eq2 = !in_string_eq2;
                        }
                        if ec2 == '=' and !in_string_eq2 {
                            eq_pos2 = ei2;
                            break;
                        }
                        ei2 = ei2 + 1;
                    }

                    if eq_pos2 >= 0 {
                        mut open_p2: i32 = 0;
                        mut close_p2: i32 = 0;
                        mut in_string_p2: bool = false;
                        mut pi2: i32 = eq_pos2 + 1;
                        loop {
                            if pi2 >= str_len(line) {
                                break;
                            }
                            val c2: char = get_char(line, pi2);
                            if c2 == '"' and (pi2 == 0 or get_char(line, pi2 - 1) != '\\') {
                                in_string_p2 = !in_string_p2;
                            } elif !in_string_p2 {
                                if c2 == '(' {
                                    open_p2 = open_p2 + 1;
                                } elif c2 == ')' {
                                    close_p2 = close_p2 + 1;
                                } elif c2 == ';' {
                                    break;
                                }
                            }
                            pi2 = pi2 + 1;
                        }

                        if close_p2 == open_p2 + 1 {
                            mut semi_idx2: i32 = -1;
                            mut sj2: i32 = str_len(line) - 1;
                            loop {
                                if sj2 < 0 {
                                    break;
                                }
                                if get_char(line, sj2) == ';' {
                                    semi_idx2 = sj2;
                                    break;
                                }
                                sj2 = sj2 - 1;
                            }

                            if semi_idx2 > 0 {
                                mut close_idx2: i32 = semi_idx2 - 1;
                                loop {
                                    if close_idx2 < 0 {
                                        break;
                                    }
                                    val cc2: char = get_char(line, close_idx2);
                                    if cc2 == ' ' or cc2 == '\t' or cc2 == '\n' {
                                        close_idx2 = close_idx2 - 1;
                                        continue;
                                    }
                                    break;
                                }

                                if close_idx2 >= 0 and get_char(line, close_idx2) == ')' {
                                    mut tmp2: string = str("");
                                    tmp2 = concat(tmp2, substring_se(line, 0, close_idx2));
                                    tmp2 = concat(tmp2, substring_se(line, close_idx2 + 1, str_len(line)));
                                    line_fixed2 = tmp2;
                                }
                            }
                        }
                    }
                }

                fixed_result = concat(fixed_result, line_fixed2);
                start_idx = idx_line + 1;
            }

            idx_line = idx_line + 1;
        }

        if str_len(fixed_result) > 0 {
            result = fixed_result;
        }
    }

    if equals_c(node_type, "Program") {
        result = strip_all_c_prefixes(result);
        result = replace_all(result, str("C . "), str(""));
        result = replace_all(result, str("C."), str(""));
        result = replace_all(result, str("C__"), str(""));
        result = collapse_duplicate_segments(result);
        result = rewrite_method_calls(result);
        result = rewrite_function_prefixes(result);
        result = rewrite_sizeof_types(result);
        result = normalize_numeric_dots(result);
    }

    if equals_c(node_type, "Test") {
        mut sb_test: StringBuilder = StringBuilder.init(4096);
        StringBuilder.append_c(addr(sb_test), "int main(int argc, char** argv) {\n__axe_argc = argc;\n__axe_argv = argv;\n");
        if !::is_release_build {
            StringBuilder.append(addr(sb_test), generate_stack_trace_setup());
        }
        StringBuilder.append_c(addr(sb_test), "    int passed = 0;\n    int failed = 0;\n\n");

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_test: i32 = 0;
            loop {
                if i_test >= len(deref(children)) {
                    break;
                }

                val child: ref ASTNode = addr(children.data[i_test]);

                if equals_c(child.node_type, "Assert") {
                    val cond_raw: string = strip(child.data.assert_node.condition);
                    val cond_norm: string = process_expression(cond_raw);
                    val msg: string = child.data.assert_node.message;

                    StringBuilder.append_c(addr(sb_test), "    if (");
                    StringBuilder.append(addr(sb_test), cond_norm);
                    StringBuilder.append_c(addr(sb_test), ") {\n        printf(\"PASSED: ");
                    StringBuilder.append(addr(sb_test), msg);
                    StringBuilder.append_c(addr(sb_test), "\\n\");\n        passed++;\n    } else {\n        printf(\"FAILED: ");
                    StringBuilder.append(addr(sb_test), msg);
                    StringBuilder.append_c(addr(sb_test), "\\n\");\n        failed++;\n    }\n\n");
                } elif equals_c(child.node_type, "Declaration") {
                    val var_name: string = child.data.declaration.name;
                    val type_name: string = child.data.declaration.type_name;
                    val is_mutable: bool = child.data.declaration.is_mutable;
                    val initializer: string = child.data.declaration.initializer;

                    if str_len(var_name) > 0 and str_len(type_name) > 0 {
                        mut arena_decl: Arena = Arena.create(2560);
                        StringStringMap.set(addr(g_var_types), addr(arena_decl), var_name, type_name);
                    }

                    mut mapped_type: string = map_axe_type_to_c(type_name);
                    mut array_suffix: string = str("");
                    val br: i32 = find_char_from(type_name, '[', 0);

                    if br >= 0 {
                        val suffix: string = substring_se(type_name, br, str_len(type_name));
                        if !equals_c(suffix, "[999]") {
                            val base_raw: string = strip(substring_se(type_name, 0, br));
                            if str_len(base_raw) > 0 {
                                mapped_type = map_axe_type_to_c(base_raw);
                                array_suffix = suffix;
                            }
                        }
                    }

                    StringBuilder.append_c(addr(sb_test), "    ");
                    if !is_mutable {
                        StringBuilder.append_c(addr(sb_test), "const ");
                    }
                    StringBuilder.append(addr(sb_test), mapped_type);
                    StringBuilder.append_char(addr(sb_test), ' ');
                    StringBuilder.append(addr(sb_test), var_name);
                    if str_len(array_suffix) > 0 {
                        StringBuilder.append(addr(sb_test), array_suffix);
                    }

                    mut trimmed_init: string = strip(initializer);
                    if str_len(trimmed_init) > 0 {
                        val init_norm: string = process_expression(trimmed_init);
                        StringBuilder.append_c(addr(sb_test), " = ");
                        StringBuilder.append(addr(sb_test), init_norm);
                    }

                    StringBuilder.append_c(addr(sb_test), ";\n");
                } else {
                    val stmt_code: string = generate_c(child);
                    if str_len(stmt_code) > 0 {
                        val buf: string = stmt_code;
                        mut idx: i32 = 0;
                        val buf_len: i32 = cast[i32](str_len(buf));

                        loop {
                            if idx >= buf_len {
                                break;
                            }
                            val ch: char = get_char(buf, idx);
                            if ch == '\n' {
                                StringBuilder.append_c(addr(sb_test), "\n    ");
                            } else {
                                StringBuilder.append_char(addr(sb_test), ch);
                            }
                            idx++;
                        }
                        StringBuilder.append_char(addr(sb_test), '\n');
                    }
                }

                i_test++;
            }
        }

        StringBuilder.append_c(addr(sb_test), "    printf(\"\\n\");\n    if (failed == 0) {\n        printf(\"All tests passed. (%d/%d)\\n\", passed, passed + failed);\n    } else {\n        printf(\"%d test(s) failed, %d passed\\n\", failed, passed);\n    }\n    return failed > 0 ? 1 : 0;\n}\n");

        result = StringBuilder.to_string(addr(sb_test));
        StringBuilder.destroy(addr(sb_test));
        return result;
    }
    
    if equals_c(node_type, "Function") {
        mut func_name: string = ast.data.function.name;
        mut return_type: string = ast.data.function.return_type;
        val is_public: bool = ast.data.function.is_public;
        
        val generic_type_params: ref list(string) = ast.data.function.generic_type_params;
        if generic_type_params != nil and len(deref(generic_type_params)) > 0 {
            mut sb_all: StringBuilder = StringBuilder.init(4096);
            
            if ast.children != nil {
                val children: ref list(ASTNode) = ast.children;
                mut wi: i32 = 0;
                loop {
                    if wi >= len(deref(children)) {
                        break;
                    }
                    val child: ref ASTNode = addr(children.data[wi]);
                    if equals_c(child.node_type, "WhenBranch") {
                        val type_param: string = child.data.when_branch.type_param;
                        val concrete_type: string = child.data.when_branch.concrete_type;
                        
                        mut sb_fname: StringBuilder = StringBuilder.init(str_len(func_name) + str_len(type_param) + str_len(concrete_type) + 8);
                        StringBuilder.append(addr(sb_fname), func_name);
                        StringBuilder.append_c(addr(sb_fname), "__");
                        StringBuilder.append(addr(sb_fname), type_param);
                        StringBuilder.append_c(addr(sb_fname), "_");
                        StringBuilder.append(addr(sb_fname), concrete_type);
                        val mangled_name: string = StringBuilder.to_string(addr(sb_fname));
                        StringBuilder.destroy(addr(sb_fname));
                        
                        if StringBoolMap.contains(addr(g_generated_functions), mangled_name) {
                            wi++;
                            continue;
                        }
                        
                        mut spec_arena: Arena = Arena.create(1024);
                        StringBoolMap.set(addr(g_generated_functions), addr(spec_arena), mangled_name, true);
                        
                        mut spec_return: string = return_type;
                        if equals_c(spec_return, type_param.data) {
                            spec_return = concrete_type;
                        }
                        val mapped_return: string = map_axe_type_to_c(spec_return);
                        
                        StringBuilder.append(addr(sb_all), emit_line_directive(ast.line));
                        StringBuilder.append(addr(sb_all), mapped_return);
                        StringBuilder.append_char(addr(sb_all), ' ');
                        StringBuilder.append(addr(sb_all), mangled_name);
                        StringBuilder.append_char(addr(sb_all), '(');
                        
                        val params: ref list(string) = ast.data.function.params;
                        if params != nil {
                            mut pi: i32 = 0;
                            loop {
                                if pi >= len(deref(params)) {
                                    break;
                                }
                                
                                if pi > 0 {
                                    StringBuilder.append_c(addr(sb_all), ", ");
                                }
                                
                                val param: string = params.data[pi];
                                val colon_pos: i32 = find_char_from(param, ':', 0);
                                
                                if colon_pos >= 0 {
                                    val param_name: string = strip(substring_se(param, 0, colon_pos));
                                    mut param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                                    
                                    if equals_c(param_type, type_param.data) {
                                        param_type = concrete_type;
                                    }
                                    
                                    val mapped_type: string = map_axe_type_to_c(param_type);
                                    
                                    StringBuilder.append(addr(sb_all), mapped_type);
                                    StringBuilder.append_char(addr(sb_all), ' ');
                                    StringBuilder.append(addr(sb_all), param_name);
                            
                                    StringStringMap.set(addr(g_var_types), addr(spec_arena), param_name, param_type);
                                } else {
                                    StringBuilder.append(addr(sb_all), param);
                                }
                                
                                pi++;
                            }
                        }
                        
                        StringBuilder.append_c(addr(sb_all), ") {\n");
                        
                        if child.children != nil {
                            val body: ref list(ASTNode) = child.children;
                            mut bi: i32 = 0;
                            loop {
                                if bi >= len(deref(body)) {
                                    break;
                                }
                                val body_code: string = generate_c(addr(body.data[bi]));
                                StringBuilder.append(addr(sb_all), body_code);
                                bi++;
                            }
                        }
                        
                        StringBuilder.append_c(addr(sb_all), "}\n\n");
                        
                        mut sb_short: StringBuilder = StringBuilder.init(str_len(func_name) + str_len(concrete_type) + 4);
                        StringBuilder.append(addr(sb_short), func_name);
                        StringBuilder.append_c(addr(sb_short), "[");
                        StringBuilder.append(addr(sb_short), concrete_type);
                        StringBuilder.append_c(addr(sb_short), "]");
                        val short_call: string = StringBuilder.to_string(addr(sb_short));
                        StringBuilder.destroy(addr(sb_short));
                        StringStringMap.set(addr(g_function_prefixes), addr(spec_arena), short_call, mangled_name);
                    }
                    wi++;
                }
            }
            
            return StringBuilder.to_string(addr(sb_all));
        }
        
        if !equals_c(func_name, "main") {
            mut sep2: i32 = -1;
            mut i2: i32 = 0;
            val n2: i32 = str_len(func_name);
            loop {
                if i2 + 1 >= n2 {
                    break;
                }
                val c1b: char = get_char(func_name, i2);
                val c2b: char = get_char(func_name, i2 + 1);
                if c1b == '_' and c2b == '_' {
                    sep2 = i2;
                }
                i2 = i2 + 1;
            }

            if sep2 >= 0 and sep2 + 2 < n2 {
                val model_part2: string = substring_se(func_name, 0, sep2);
                val method_part2: string = substring_se(func_name, sep2 + 2, n2);

                mut has_inner_sep2: bool = false;
                mut j2: i32 = 0;
                val mlen2: i32 = str_len(model_part2);
                loop {
                    if j2 + 1 >= mlen2 {
                        break;
                    }
                    val mc1b: char = get_char(model_part2, j2);
                    val mc2b: char = get_char(model_part2, j2 + 1);
                    if mc1b == '_' and mc2b == '_' {
                        has_inner_sep2 = true;
                        break;
                    }
                    j2 = j2 + 1;
                }

                if !has_inner_sep2 {
                    val canon_model2: string = canonical_model_c_name(model_part2);
                    if str_len(canon_model2) > 0 {
                        mut sb_fname: StringBuilder = StringBuilder.init(str_len(canon_model2) + str_len(method_part2) + 2);
                        StringBuilder.append(addr(sb_fname), canon_model2);
                        StringBuilder.append_c(addr(sb_fname), "__");
                        StringBuilder.append(addr(sb_fname), method_part2);
                        func_name = StringBuilder.to_string(addr(sb_fname));
                        StringBuilder.destroy(addr(sb_fname));
                    }
                }
            }

            if StringStringMap.contains(addr(g_function_prefixes), func_name) {
                func_name = StringStringMap.get(addr(g_function_prefixes), func_name);
            }
        }
        
        if StringBoolMap.contains(addr(g_generated_functions), func_name) {
            return str("");
        }
        
        mut func_arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr(g_generated_functions), addr(func_arena), func_name, true);
        StringStringMap.clear(addr(g_var_types));
        
        validate_type_imported(return_type);
        
        val fn_params: ref list(string) = ast.data.function.params;
        if fn_params != nil {
            mut pi: i32 = 0;
            loop {
                if pi >= len(deref(fn_params)) {
                    break;
                }
                val p: string = fn_params.data[pi];
                val cp: i32 = find_char_from(p, ':', 0);
                if cp >= 0 {
                    val pname: string = strip(substring_se(p, 0, cp));
                    val ptype: string = strip(substr(p, cp + 1, str_len(p) - cp - 1));
                    if str_len(pname) > 0 and str_len(ptype) > 0 {
                        validate_type_imported(ptype);
                        StringStringMap.set(addr(g_var_types), addr(arena), pname, ptype);
                    }
                }
                pi = pi + 1;
            }
        }
        
        if equals_c(func_name, "main") {
            mut sb_main: StringBuilder = StringBuilder.init(4096);
            StringBuilder.append_c(addr(sb_main), "int main(int argc, char** argv) {\n__axe_argc = argc;\n__axe_argv = argv;\n");

            platform windows {
                StringBuilder.append_c(addr(sb_main), "SetConsoleOutputCP(65001);\n");
            }

            if !::is_release_build {
                StringBuilder.append(addr(sb_main), generate_stack_trace_setup());
            }
            
            if ast.children != nil {
                val children: ref list(ASTNode) = ast.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_code: string = generate_c(addr(children.data[i]));
                    StringBuilder.append(addr(sb_main), child_code);
                    i++;
                }
            }
            
            StringBuilder.append_c(addr(sb_main), "return 0;\n}\n\n");
            return StringBuilder.to_string(addr(sb_main));
        }
        
        if str_len(return_type) == 0 {
            return_type = str("void");
        }
        
        val mapped_return_type: string = map_axe_type_to_c(return_type);
        mut sb_func: StringBuilder = StringBuilder.init(4096);
        
        StringBuilder.append(addr(sb_func), emit_line_directive(ast.line));
        
        val func_tags: ref list(string) = ast.data.function.tags;
        if func_tags != nil {
            mut tag_idx: i32 = 0;
            loop {
                if tag_idx >= len(deref(func_tags)) {
                    break;
                }
                val tag: string = func_tags.data[tag_idx];
                if equals_c(tag, "inline") {
                    StringBuilder.append_c(addr(sb_func), "inline ");
                } elif equals_c(tag, "noinline") {
                    StringBuilder.append_c(addr(sb_func), "__attribute__((noinline)) ");
                } elif equals_c(tag, "cold") {
                    StringBuilder.append_c(addr(sb_func), "__attribute__((cold)) ");
                } elif equals_c(tag, "hot") {
                    StringBuilder.append_c(addr(sb_func), "__attribute__((hot)) ");
                }
                tag_idx = tag_idx + 1;
            }
        }
        
        StringBuilder.append(addr(sb_func), mapped_return_type);
        StringBuilder.append_char(addr(sb_func), ' ');
        StringBuilder.append(addr(sb_func), func_name);
        StringBuilder.append_char(addr(sb_func), '(');
        
        val params: ref list(string) = ast.data.function.params;
        if params != nil {
            mut param_idx: i32 = 0;
            loop {
                if param_idx >= len(deref(params)) {
                    break;
                }
                
                if param_idx > 0 {
                    StringBuilder.append_c(addr(sb_func), ", ");
                }
                
                val param: string = params.data[param_idx];
                val colon_pos: i32 = find_char_from(param, ':', 0);

                if colon_pos >= 0 {
                    val param_name: string = strip(substring_se(param, 0, colon_pos));
                    val param_type: string = strip(substr(param, colon_pos + 1, str_len(param) - colon_pos - 1));
                    val processed_type: string = process_parameter_type(param_type);
                    
                    StringBuilder.append(addr(sb_func), processed_type);
                    StringBuilder.append_char(addr(sb_func), ' ');
                    StringBuilder.append(addr(sb_func), param_name);
                } else {
                    StringBuilder.append(addr(sb_func), param);
                }
                
                param_idx++;
            }
        }
        
        StringBuilder.append_c(addr(sb_func), ") {\n");
        result = StringBuilder.to_string(addr(sb_func));
        StringBuilder.destroy(addr(sb_func));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i]));
                result = concat(result, child_code);
                i++;
            }
        }
        
        result = concat_c(result, "}\n\n");
        return result;
    }
    
    if equals_c(node_type, "Return") {
        mut sb_ret: StringBuilder = StringBuilder.init(512);
        StringBuilder.append_c(addr(sb_ret), "return ");
        mut expr: string = ast.data.return_node.expression;
        debug_print_raw "\n[DEBUG] RENDERER raw return expr:";
        debug_print_str expr;

        mut trimmed_ret: string = strip(expr);

        val paren_pos_ret: i32 = find_char_from(trimmed_ret, '(', 0);
        if paren_pos_ret > 0 {
            val call_name_ret: string = strip(substring_se(trimmed_ret, 0, paren_pos_ret));
            if StringStringMap.contains(addr(g_function_prefixes), call_name_ret) {
                val full_name_ret: string = StringStringMap.get(addr(g_function_prefixes), call_name_ret);
                val rest_ret: string = substring_se(trimmed_ret, paren_pos_ret, str_len(trimmed_ret));
                mut sb_tmp: StringBuilder = StringBuilder.init(str_len(full_name_ret) + str_len(rest_ret));
                StringBuilder.append(addr(sb_tmp), full_name_ret);
                StringBuilder.append(addr(sb_tmp), rest_ret);
                trimmed_ret = StringBuilder.to_string(addr(sb_tmp));
                StringBuilder.destroy(addr(sb_tmp));
                expr = trimmed_ret;
            }
        }

        mut processed: string = str("");

        val brace_pos_ret: i32 = find_char_from(trimmed_ret, '{', 0);
        if brace_pos_ret > 0 and get_char(trimmed_ret, str_len(trimmed_ret) - 1) == '}' {
            val prefix_ret: string = strip(substring_se(trimmed_ret, 0, brace_pos_ret));
            val inner_ret: string = substring_se(trimmed_ret, brace_pos_ret + 1, str_len(trimmed_ret) - 1);

            if str_len(prefix_ret) > 0 {
                val canon_ret: string = canonical_model_c_name(prefix_ret);
                mut c_type_ret: string = canon_ret;
                if str_len(c_type_ret) == 0 {
                    c_type_ret = map_axe_type_to_c(prefix_ret);
                }

                if str_len(c_type_ret) > 0 {
                    mut sb_init_ret: StringBuilder = StringBuilder.init(512);
                    StringBuilder.append_c(addr(sb_init_ret), "(");
                    StringBuilder.append(addr(sb_init_ret), c_type_ret);
                    StringBuilder.append_c(addr(sb_init_ret), "){");

                    mut sb_current_ret: StringBuilder = StringBuilder.init(str_len(inner_ret) + 16);
                    mut depth_ret: i32 = 0;
                    mut first_field_ret: bool = true;
                    mut i_ret: i32 = 0;
                    val inner_ret_len: i32 = cast[i32](str_len(inner_ret));

                    loop {
                        if i_ret >= inner_ret_len {
                            break;
                        }
                        val ch_ret: char = get_char(inner_ret, i_ret);
                        if ch_ret == '(' {
                            depth_ret = depth_ret + 1;
                            StringBuilder.append_char(addr(sb_current_ret), ch_ret);
                        } elif ch_ret == ')' {
                            if depth_ret > 0 {
                                depth_ret = depth_ret - 1;
                            }
                            StringBuilder.append_char(addr(sb_current_ret), ch_ret);
                        } elif ch_ret == ',' and depth_ret == 0 {
                            mut part_ret: string = strip(StringBuilder.to_string(addr(sb_current_ret)));
                            if str_len(part_ret) > 0 {
                                val colon_pos_ret2: i32 = find_char_from(part_ret, ':', 0);
                                if colon_pos_ret2 >= 0 {
                                    val field_name_ret: string = strip(substring_se(part_ret, 0, colon_pos_ret2));
                                    val value_expr_ret: string = strip(substr(part_ret, colon_pos_ret2 + 1, str_len(part_ret) - colon_pos_ret2 - 1));
                                    if str_len(field_name_ret) > 0 and str_len(value_expr_ret) > 0 {
                                        if !first_field_ret {
                                            StringBuilder.append_c(addr(sb_init_ret), ", ");
                                        }
                                        StringBuilder.append_c(addr(sb_init_ret), ".");
                                        StringBuilder.append(addr(sb_init_ret), field_name_ret);
                                        StringBuilder.append_c(addr(sb_init_ret), " = ");
                                        val processed_val_ret: string = process_expression(value_expr_ret);
                                        StringBuilder.append(addr(sb_init_ret), processed_val_ret);
                                        first_field_ret = false;
                                    }
                                }
                            }
                            StringBuilder.clear(addr(sb_current_ret));
                        } else {
                            StringBuilder.append_char(addr(sb_current_ret), ch_ret);
                        }
                        i_ret = i_ret + 1;
                    }

                    mut part_last_ret: string = strip(StringBuilder.to_string(addr(sb_current_ret)));
                    StringBuilder.destroy(addr(sb_current_ret));
                    if str_len(part_last_ret) > 0 {
                        val colon_pos_last_ret: i32 = find_char_from(part_last_ret, ':', 0);
                        if colon_pos_last_ret >= 0 {
                            val field_name_last_ret: string = strip(substring_se(part_last_ret, 0, colon_pos_last_ret));
                            val value_expr_last_ret: string = strip(substr(part_last_ret, colon_pos_last_ret + 1, str_len(part_last_ret) - colon_pos_last_ret - 1));
                            if str_len(field_name_last_ret) > 0 and str_len(value_expr_last_ret) > 0 {
                                if !first_field_ret {
                                    StringBuilder.append_c(addr(sb_init_ret), ", ");
                                }
                                StringBuilder.append_c(addr(sb_init_ret), ".");
                                StringBuilder.append(addr(sb_init_ret), field_name_last_ret);
                                StringBuilder.append_c(addr(sb_init_ret), " = ");
                                val processed_last_ret: string = process_expression(value_expr_last_ret);
                                StringBuilder.append(addr(sb_init_ret), processed_last_ret);
                                first_field_ret = false;
                            }
                        }
                    }

                    StringBuilder.append_c(addr(sb_init_ret), "}");
                    processed = StringBuilder.to_string(addr(sb_init_ret));
                    StringBuilder.destroy(addr(sb_init_ret));
                }
            }
        }

        if str_len(processed) == 0 {
            debug_print_raw "\n[DBG-CALL] process_expression from Return:";
            debug_print_str expr;
            processed = process_expression(expr);
        }
        StringBuilder.append(addr(sb_ret), processed);
        StringBuilder.append_c(addr(sb_ret), ";\n");
        result = StringBuilder.to_string(addr(sb_ret));
        StringBuilder.destroy(addr(sb_ret));
        return result;
    }

    if equals_c(node_type, "Break") {
        return str("break;\n");
    }

    if equals_c(node_type, "Continue") {
        return str("continue;\n");
    }
    
    if equals_c(node_type, "Declaration") {
        val var_name: string = ast.data.declaration.name;
        mut type_name: string = ast.data.declaration.type_name;
        val is_mutable: bool = ast.data.declaration.is_mutable;
        val initializer: string = ast.data.declaration.initializer;
        
        validate_type_imported(type_name);
        
        mut mapped_type: string = map_axe_type_to_c(type_name);

        if str_len(type_name) == 0 {
            mut trimmed_init: string = strip(initializer);
            if has_prefix(trimmed_init, str("new ")) {
                trimmed_init = substring_se(trimmed_init, 4, str_len(trimmed_init));
                trimmed_init = strip(trimmed_init);

                mut end_pos: i32 = -1;
                mut i: i32 = 0;
                loop {
                    if i >= str_len(trimmed_init) {
                        break;
                    }
                    val ch: char = get_char(trimmed_init, i);
                    if ch == '(' or ch == ' ' or ch == '\t' {
                        end_pos = i;
                        break;
                    }
                    i++;
                }
                if end_pos < 0 {
                    end_pos = str_len(trimmed_init);
                }
                val inferred_name: string = strip(substring_se(trimmed_init, 0, end_pos));
                if str_len(inferred_name) > 0 {
                    type_name = inferred_name;
                    mapped_type = map_axe_type_to_c(type_name);
                }
            } else {
                val brace_pos: i32 = find_char_from(trimmed_init, '{', 0);
                if brace_pos > 0 {
                    val inferred_name2: string = strip(substring_se(trimmed_init, 0, brace_pos));
                    if str_len(inferred_name2) > 0 {
                        type_name = inferred_name2;
                        mapped_type = map_axe_type_to_c(type_name);
                    }
                }
            }
        }

        // Record the declared Axe type for this variable so that later
        // MemberAccess nodes can determine whether the base object should
        // use '.' or '->' in generated C.
        if str_len(var_name) > 0 and str_len(type_name) > 0 {
            mut decl_arena: Arena = Arena.create(2560);
            StringStringMap.set(addr(g_var_types), addr(decl_arena), var_name, type_name);

            if has_prefix(type_name, str("list(")) {
                mut paren_pos: i32 = 5;
                mut depth: i32 = 1;
                loop {
                    if paren_pos >= str_len(type_name) {
                        break;
                    }
                    val ch: char = get_char(type_name, paren_pos);
                    if ch == '(' {
                        depth = depth + 1;
                    } elif ch == ')' {
                        depth = depth - 1;
                        if depth == 0 {
                            break;
                        }
                    }
                    paren_pos = paren_pos + 1;
                }
                val element_type: string = strip(substr(type_name, 5, paren_pos - 5));
                mut list_arena: Arena = Arena.create(2560);
                StringStringMap.set(addr(g_list_of_types), addr(list_arena), var_name, element_type);
            } elif has_suffix(type_name, str("[999]")) {
                val element_type: string = strip(substring_se(type_name, 0, str_len(type_name) - 5));
                mut list_arena: Arena = Arena.create(2560);
                StringStringMap.set(addr(g_list_of_types), addr(list_arena), var_name, element_type);
            }
        }

        val enum_model_name: string = canonical_model_c_name(type_name);
        if str_len(enum_model_name) > 0 and StringBoolMap.contains(addr(g_enum_names), enum_model_name) {
            mapped_type = enum_model_name;
        }

        mut array_suffix: string = str("");
        val br: i32 = find_char_from(type_name, '[', 0);
        if br >= 0 {
            val suffix: string = substring_se(type_name, br, str_len(type_name));
            if !equals_c(suffix, "[999]") {
                val base_raw: string = strip(substring_se(type_name, 0, br));
                if str_len(base_raw) > 0 {
                    mapped_type = map_axe_type_to_c(base_raw);
                    array_suffix = suffix;
                }
            }
        }

        mut sb_decl: StringBuilder = StringBuilder.init(256);
        val line_dir: string = emit_line_directive(ast.line);
        StringBuilder.append(addr(sb_decl), line_dir);
        
        if !is_mutable {
            StringBuilder.append_c(addr(sb_decl), "const ");
        }
        StringBuilder.append(addr(sb_decl), mapped_type);
        StringBuilder.append_char(addr(sb_decl), ' ');
        StringBuilder.append(addr(sb_decl), var_name);
        if str_len(array_suffix) > 0 {
            StringBuilder.append(addr(sb_decl), array_suffix);
        }
        
        if str_len(initializer) > 0 {
            mut trimmed: string = strip(initializer);

            if has_prefix(trimmed, str("[")) and has_suffix(trimmed, str("]")) {
                val elements_str: string = substring_se(trimmed, 1, str_len(trimmed) - 1);
                val elements_trimmed: string = strip(elements_str);
                mut element_count: i32 = 0;
                if str_len(elements_trimmed) > 0 {
                    element_count = 1;
                    mut depth: i32 = 0;
                    mut idx_elem: i32 = 0;
                    loop {
                        if idx_elem >= str_len(elements_trimmed) {
                            break;
                        }
                        val ch_elem: char = get_char(elements_trimmed, idx_elem);
                        if ch_elem == '(' or ch_elem == '[' or ch_elem == '{' {
                            depth++;
                        } elif ch_elem == ')' or ch_elem == ']' or ch_elem == '}' {
                            depth--;
                        } elif ch_elem == ',' and depth == 0 {
                            element_count++;
                        }
                        idx_elem++;
                    }
                }
                
                mut elem_type_c: string = str("int32_t");
                if has_prefix(type_name, str("list(")) {
                    mut paren_end: i32 = 5;
                    mut depth_type: i32 = 1;
                    loop {
                        if paren_end >= str_len(type_name) {
                            break;
                        }
                        val ch_t: char = get_char(type_name, paren_end);
                        if ch_t == '(' {
                            depth_type++;
                        } elif ch_t == ')' {
                            depth_type--;
                            if depth_type == 0 {
                                break;
                            }
                        }
                        paren_end = paren_end + 1;
                    }
                    val elem_type_axe: string = strip(substr(type_name, 5, paren_end - 5));
                    elem_type_c = map_axe_type_to_c(elem_type_axe);
                }
                
                val processed_elements: string = process_expression(elements_trimmed);

                StringBuilder.append_c(addr(sb_decl), " = {.data = (");
                StringBuilder.append(addr(sb_decl), elem_type_c);
                StringBuilder.append_c(addr(sb_decl), "[]){");
                StringBuilder.append(addr(sb_decl), processed_elements);
                StringBuilder.append_c(addr(sb_decl), "}, .len = ");
                StringBuilder.append(addr(sb_decl), i32_to_string(element_count));
                StringBuilder.append_c(addr(sb_decl), ", .capacity = ");
                StringBuilder.append(addr(sb_decl), i32_to_string(element_count));
                StringBuilder.append_c(addr(sb_decl), "}");
            } elif has_prefix(trimmed, str("new ")) {
                trimmed = substring_se(trimmed, 4, str_len(trimmed));
                trimmed = strip(trimmed);

                val first_paren: i32 = find_char_from(trimmed, '(', 0);
                if first_paren < 0 {
                    StringBuilder.append_c(addr(sb_decl), " = {0}");
                } else {
                    mut last_paren: i32 = -1;
                    mut idx: i32 = str_len(trimmed) - 1;
                    loop {
                        if idx < 0 {
                            break;
                        }
                        val ch_end: char = get_char(trimmed, idx);
                        if ch_end == ')' {
                            last_paren = idx;
                            break;
                        }
                        idx = idx - 1;
                    }

                    if last_paren <= first_paren + 1 {
                        // No arguments
                        StringBuilder.append_c(addr(sb_decl), " = {0}");
                    } else {
                        val args_str: string = substring_se(trimmed, first_paren + 1, last_paren);
                        StringBuilder.append_c(addr(sb_decl), " = {");

                        mut sb_current: StringBuilder = StringBuilder.init(str_len(args_str) + 16);
                        mut depth: i32 = 0;
                        mut first_field: bool = true;
                        mut i2: i32 = 0;
                        val args_str_len: i32 = cast[i32](str_len(args_str));

                        loop {
                            if i2 >= args_str_len {
                                break;
                            }
                            val ch: char = get_char(args_str, i2);
                            if ch == '(' {
                                depth = depth + 1;
                                StringBuilder.append_char(addr(sb_current), ch);
                            } elif ch == ')' {
                                if depth > 0 {
                                    depth = depth - 1;
                                }
                                StringBuilder.append_char(addr(sb_current), ch);
                            } elif ch == ',' and depth == 0 {
                                mut part: string = strip(StringBuilder.to_string(addr(sb_current)));
                                if str_len(part) > 0 {
                                    val colon_pos: i32 = find_char_from(part, ':', 0);
                                    if colon_pos >= 0 {
                                        val field_name: string = strip(substring_se(part, 0, colon_pos));
                                        val value_expr: string = strip(substr(part, colon_pos + 1, str_len(part) - colon_pos - 1));
                                        if str_len(field_name) > 0 and str_len(value_expr) > 0 {
                                            if !first_field {
                                                StringBuilder.append_c(addr(sb_decl), ", ");
                                            }
                                            StringBuilder.append_c(addr(sb_decl), ".");
                                            StringBuilder.append(addr(sb_decl), field_name);
                                            StringBuilder.append_c(addr(sb_decl), " = ");
                                            StringBuilder.append(addr(sb_decl), value_expr);
                                            first_field = false;
                                        }
                                    }
                                }
                                StringBuilder.clear(addr(sb_current));
                            } else {
                                StringBuilder.append_char(addr(sb_current), ch);
                            }
                            i2++;
                        }

                        mut part_last: string = strip(StringBuilder.to_string(addr(sb_current)));
                        StringBuilder.destroy(addr(sb_current));
                        if str_len(part_last) > 0 {
                            val colon_pos_last: i32 = find_char_from(part_last, ':', 0);
                            if colon_pos_last >= 0 {
                                val field_name_last: string = strip(substring_se(part_last, 0, colon_pos_last));
                                val value_expr_last: string = strip(substr(part_last, colon_pos_last + 1, str_len(part_last) - colon_pos_last - 1));
                                if str_len(field_name_last) > 0 and str_len(value_expr_last) > 0 {
                                    if !first_field {
                                        StringBuilder.append_c(addr(sb_decl), ", ");
                                    }
                                    StringBuilder.append_c(addr(sb_decl), ".");
                                    StringBuilder.append(addr(sb_decl), field_name_last);
                                    StringBuilder.append_c(addr(sb_decl), " = ");
                                    StringBuilder.append(addr(sb_decl), value_expr_last);
                                    first_field = false;
                                }
                            }
                        }

                        if first_field {
                            StringBuilder.append_c(addr(sb_decl), " = {0}");
                        } else {
                            StringBuilder.append_c(addr(sb_decl), "}");
                        }
                    }
                }
            } else {
                val brace_pos: i32 = find_char_from(trimmed, '{', 0);
                if brace_pos > 0 and get_char(trimmed, str_len(trimmed) - 1) == '}' {
                    val prefix: string = strip(substring_se(trimmed, 0, brace_pos));
                    val inner: string = substring_se(trimmed, brace_pos + 1, str_len(trimmed) - 1);

                    if (str_len(type_name) == 0 or equals_c(prefix, type_name.data)) {
                        StringBuilder.append_c(addr(sb_decl), " = {");

                        mut sb_current2: StringBuilder = StringBuilder.init(str_len(inner) + 16);
                        mut depth2: i32 = 0;
                        mut first_field2: bool = true;
                        mut i3: i32 = 0;
                        val inner_len: i32 = cast[i32](str_len(inner));

                        loop {
                            if i3 >= inner_len {
                                break;
                            }
                            val ch2: char = get_char(inner, i3);
                            if ch2 == '(' {
                                depth2 = depth2 + 1;
                                StringBuilder.append_char(addr(sb_current2), ch2);
                            } elif ch2 == ')' {
                                if depth2 > 0 {
                                    depth2 = depth2 - 1;
                                }
                                StringBuilder.append_char(addr(sb_current2), ch2);
                            } elif ch2 == ',' and depth2 == 0 {
                                mut part2: string = strip(StringBuilder.to_string(addr(sb_current2)));
                                if str_len(part2) > 0 {
                                    val colon_pos2: i32 = find_char_from(part2, ':', 0);
                                    if colon_pos2 >= 0 {
                                        val field_name2: string = strip(substring_se(part2, 0, colon_pos2));
                                        val value_expr2: string = strip(substr(part2, colon_pos2 + 1, str_len(part2) - colon_pos2 - 1));
                                        if str_len(field_name2) > 0 and str_len(value_expr2) > 0 {
                                            if !first_field2 {
                                                StringBuilder.append_c(addr(sb_decl), ", ");
                                            }
                                            StringBuilder.append_c(addr(sb_decl), ".");
                                            StringBuilder.append(addr(sb_decl), field_name2);
                                            StringBuilder.append_c(addr(sb_decl), " = ");
                                            StringBuilder.append(addr(sb_decl), value_expr2);
                                            first_field2 = false;
                                        }
                                    }
                                }
                                StringBuilder.clear(addr(sb_current2));
                            } else {
                                StringBuilder.append_char(addr(sb_current2), ch2);
                            }
                            i3 = i3 + 1;
                        }

                        mut part_last2: string = strip(StringBuilder.to_string(addr(sb_current2)));
                        StringBuilder.destroy(addr(sb_current2));
                        if str_len(part_last2) > 0 {
                            val colon_pos_last2: i32 = find_char_from(part_last2, ':', 0);
                            if colon_pos_last2 >= 0 {
                                val field_name_last2: string = strip(substring_se(part_last2, 0, colon_pos_last2));
                                val value_expr_last2: string = strip(substr(part_last2, colon_pos_last2 + 1, str_len(part_last2) - colon_pos_last2 - 1));
                                if str_len(field_name_last2) > 0 and str_len(value_expr_last2) > 0 {
                                    if !first_field2 {
                                        StringBuilder.append_c(addr(sb_decl), ", ");
                                    }
                                    StringBuilder.append_c(addr(sb_decl), ".");
                                    StringBuilder.append(addr(sb_decl), field_name_last2);
                                    StringBuilder.append_c(addr(sb_decl), " = ");
                                    StringBuilder.append(addr(sb_decl), value_expr_last2);
                                    first_field2 = false;
                                }
                            }
                        }

                        if first_field2 {
                            StringBuilder.append_c(addr(sb_decl), " = {0}");
                        } else {
                            StringBuilder.append_c(addr(sb_decl), "}");
                        }
                    } else {
                        val processed_init2: string = process_expression(trimmed);
                        StringBuilder.append_c(addr(sb_decl), " = ");
                        StringBuilder.append(addr(sb_decl), processed_init2);
                    }
                } else {
                    val paren_pos: i32 = find_char_from(trimmed, '(', 0);
                    if paren_pos > 0 {
                        val call_name_raw: string = strip(substring_se(trimmed, 0, paren_pos));
                        if StringStringMap.contains(addr(g_function_prefixes), call_name_raw) {
                            val full_name: string = StringStringMap.get(addr(g_function_prefixes), call_name_raw);
                            val rest: string = substring_se(trimmed, paren_pos, str_len(trimmed));
                            trimmed = concat(full_name, rest);
                        }
                    }

                    val processed_init: string = process_expression(trimmed);
                    StringBuilder.append_c(addr(sb_decl), " = ");
                    StringBuilder.append(addr(sb_decl), processed_init);
                }
            }
        } else {
            StringBuilder.append_c(addr(sb_decl), " = {0}");
        }
        
        StringBuilder.append_c(addr(sb_decl), ";\n");
        result = StringBuilder.to_string(addr(sb_decl));
        StringBuilder.destroy(addr(sb_decl));
        return result;
    }
    
    if equals_c(node_type, "Assignment") {
        val variable: string = ast.data.assignment.variable;
        val expression: string = ast.data.assignment.expression;
        
        debug_print_raw "\n[DBG-ASSIGN] Assignment node";
        debug_print_raw "\n[DBG-ASSIGN]   raw variable:";
        debug_print_str variable;
        debug_print_raw "\n[DBG-ASSIGN]   raw expression:";
        debug_print_str expression;

        debug_print_raw "\n[DBG-CALL] process_expression from Assignment.variable:";
        debug_print_str variable;
        val processed_var: string = process_expression(variable);
        debug_print_raw "\n[DBG-CALL] process_expression from Assignment.expression:";
        debug_print_str expression;
        val processed_expr: string = process_expression(expression);

        debug_print_raw "\n[DBG-ASSIGN]   processed variable:";
        debug_print_str processed_var;
        debug_print_raw "\n[DBG-ASSIGN]   processed expression:";
        debug_print_str processed_expr;
        
        val pv: string = processed_var;
        debug_print_raw "\n[DBG-ASSIGN]   pv before fix:";
        debug_print_str pv;

        mut sb_fixed_var: StringBuilder = StringBuilder.init(str_len(pv) + 16);
        mut idx_av: i32 = 0;
        val pv_len: i32 = cast[i32](str_len(pv));
        loop {
            if idx_av >= pv_len {
                break;
            }
            val chx: char = get_char(pv, idx_av);

            if chx == '(' and idx_av > 0 {
                val prev_ch: char = get_char(pv, idx_av - 1);
                if (prev_ch >= 'a' and prev_ch <= 'z') or
                   (prev_ch >= 'A' and prev_ch <= 'Z') or
                   (prev_ch >= '0' and prev_ch <= '9') or
                   prev_ch == '_' {

                    mut k2: i32 = idx_av + 1;
                    loop {
                        if k2 >= pv_len {
                            break;
                        }
                        val ws2: char = get_char(pv, k2);
                        if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                            break;
                        }
                        k2 = k2 + 1;
                    }

                    if k2 + 1 < pv_len and
                       get_char(pv, k2) == '-' and
                       get_char(pv, k2 + 1) == '>' {
                        idx_av = k2;
                        continue;
                    }
                }
            }

            StringBuilder.append_char(addr(sb_fixed_var), chx);
            idx_av = idx_av + 1;
        }

        mut fixed_var: string = StringBuilder.to_string(addr(sb_fixed_var));
        StringBuilder.destroy(addr(sb_fixed_var));

        mut out_lhs: string = fixed_var;
        mut out_rhs: string = processed_expr;
        mut ri: i32 = 0;

        loop {
            if ri >= str_len(processed_expr) {
                break;
            }
            val ws0: char = get_char(processed_expr, ri);
            if ws0 != ' ' and ws0 != '\t' and ws0 != '\n' {
                break;
            }
            ri = ri + 1;
        }

        if ri < str_len(processed_expr) and is_ident_start(get_char(processed_expr, ri)) {
            val istart: i32 = ri;
            mut j: i32 = ri + 1;
            loop {
                if j >= str_len(processed_expr) {
                    break;
                }
                val cj: char = get_char(processed_expr, j);
                if !((cj >= 'a' and cj <= 'z') or (cj >= 'A' and cj <= 'Z') or (cj >= '0' and cj <= '9') or cj == '_') {
                    break;
                }
                j = j + 1;
            }

            val enum_ident: string = substring_se(processed_expr, istart, j);

            mut k: i32 = j;
            loop {
                if k >= str_len(processed_expr) {
                    break;
                }
                val ws1: char = get_char(processed_expr, k);
                if ws1 != ' ' and ws1 != '\t' and ws1 != '\n' {
                    break;
                }
                k = k + 1;
            }

            if k < str_len(processed_expr) and get_char(processed_expr, k) == '.' {
                k = k + 1;
                loop {
                    if k >= str_len(processed_expr) {
                        break;
                    }
                    val ws2: char = get_char(processed_expr, k);
                    if ws2 != ' ' and ws2 != '\t' and ws2 != '\n' {
                        break;
                    }
                    k = k + 1;
                }

                if k < str_len(processed_expr) and is_ident_start(get_char(processed_expr, k)) {
                    val mstart: i32 = k;
                    mut m: i32 = k + 1;
                    loop {
                        if m >= str_len(processed_expr) {
                            break;
                        }
                        val cm: char = get_char(processed_expr, m);
                        if !((cm >= 'a' and cm <= 'z') or (cm >= 'A' and cm <= 'Z') or (cm >= '0' and cm <= '9') or cm == '_') {
                            break;
                        }
                        m = m + 1;
                    }

                    val member: string = substring_se(processed_expr, mstart, m);
                    val enum_c_name2: string = canonical_model_c_name(enum_ident);

                    if str_len(enum_c_name2) > 0 {
                        mut rebuilt: string = str("");
                        if ri > 0 {
                            rebuilt = substring_se(processed_expr, 0, ri);
                        }
                        rebuilt = concat(rebuilt, enum_c_name2);
                        rebuilt = concat(rebuilt, str("_"));
                        rebuilt = concat(rebuilt, member);
                        if m < str_len(processed_expr) {
                            val suffix: string = substring_se(processed_expr, m, str_len(processed_expr));
                            rebuilt = concat(rebuilt, suffix);
                        }
                        out_rhs = rebuilt;
                    }
                }
            }
        }

        if has_prefix(processed_expr, str("->")) {
            val eq_pos: i32 = find_char_from(processed_expr, '=', 0);
            if eq_pos > 0 {
                val lhs_suffix: string = substring_se(processed_expr, 0, eq_pos);
                val rhs_suffix: string = substring_se(processed_expr, eq_pos + 1, str_len(processed_expr));

                out_lhs = concat(fixed_var, lhs_suffix);
                out_rhs = strip(rhs_suffix);

                debug_print_raw "\n[DBG-ASSIGN]   reconstructed LHS (arrow sugar):";
                debug_print_str out_lhs;
                debug_print_raw "\n[DBG-ASSIGN]   reconstructed RHS (arrow sugar):";
                debug_print_str out_rhs;
            }
        }

        mut sb_assign: StringBuilder = StringBuilder.init(512);
        StringBuilder.append(addr(sb_assign), out_lhs);
        
        val op: string = ast.data.assignment.operator;
        if str_len(op) > 0 {
            StringBuilder.append_char(addr(sb_assign), ' ');
            StringBuilder.append(addr(sb_assign), op);
            StringBuilder.append_char(addr(sb_assign), ' ');
        } else {
            StringBuilder.append_c(addr(sb_assign), " = ");
        }
        
        StringBuilder.append(addr(sb_assign), out_rhs);
        StringBuilder.append_c(addr(sb_assign), ";\n");
        
        result = StringBuilder.to_string(addr(sb_assign));
        StringBuilder.destroy(addr(sb_assign));
        return result;
    }
    
    if equals_c(node_type, "MemberAccess") {
        val object_name: string = ast.data.member_access.object_name;
        val member_name: string = ast.data.member_access.member_name;
        val value: string = ast.data.member_access.value;
        
        debug_print_raw "\n[DBG-MEM] MemberAccess node";
        debug_print_raw "\n[DBG-MEM]   object_name:";
        debug_print_str object_name;
        debug_print_raw "\n[DBG-MEM]   member_name:";
        debug_print_str member_name;
        debug_print_raw "\n[DBG-MEM]   raw value:";
        debug_print_str value;

        mut access_op: string = str(".");
        mut is_pointer: bool = false;
        val trimmed_obj: string = strip(object_name);
        val arrow_pos: i32 = find_char_from(trimmed_obj, '-', 0);
        if arrow_pos >= 0 and find_char_from(trimmed_obj, '>', arrow_pos) >= 0 {
            is_pointer = true;
        } else {
            if StringStringMap.contains(addr(g_var_types), trimmed_obj) {
                val raw_type: string = StringStringMap.get(addr(g_var_types), trimmed_obj);
                mut t: string = strip(raw_type);

                if has_prefix(t, str("mut ")) {
                    t = strip(substr(t, 4, str_len(t) - 4));
                }

                if !equals_c(t, "string") {
                    if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                        is_pointer = true;
                    }
                }
            }
        }

        if is_pointer {
            access_op = str("->");
        }

        mut sb_mem: StringBuilder = StringBuilder.init(256);
        StringBuilder.append(addr(sb_mem), trimmed_obj);
        StringBuilder.append(addr(sb_mem), access_op);
        StringBuilder.append(addr(sb_mem), member_name);
        
        val member_chain: string = StringBuilder.to_string(addr(sb_mem));
        StringBuilder.destroy(addr(sb_mem));
        val processed_chain: string = rewrite_ref_member_access(member_chain);

        val trimmed_value: string = strip(value);
        if str_len(trimmed_value) > 0 {
            val processed_value: string = process_expression(trimmed_value);
            debug_print_raw "\n[DEBUG]   processed value:";
            debug_print_str processed_value;
            mut sb_result_mem: StringBuilder = StringBuilder.init(256);
            StringBuilder.append(addr(sb_result_mem), processed_chain);
            StringBuilder.append_c(addr(sb_result_mem), " = ");
            StringBuilder.append(addr(sb_result_mem), processed_value);
            StringBuilder.append_c(addr(sb_result_mem), ";\n");
            mut result_mem: string = StringBuilder.to_string(addr(sb_result_mem));
            StringBuilder.destroy(addr(sb_result_mem));
            return result_mem;
        }

        return concat(processed_chain, str(";\n"));
    }
    
    if equals_c(node_type, "ArrayAssign") {
        val array_name: string = ast.data.array_assign.array_name;
        val index_expr: string = ast.data.array_assign.index;
        val index2_expr: string = ast.data.array_assign.index2;
        val value_expr: string = ast.data.array_assign.value;
        
        debug_print_raw "\n[DBG-ARRAYASSIGN] ArrayAssign node";
        debug_print_raw "\n[DBG-ARRAYASSIGN]   array_name:";
        debug_print_str array_name;
        debug_print_raw "\n[DBG-ARRAYASSIGN]   index:";
        debug_print_str index_expr;
        debug_print_raw "\n[DBG-ARRAYASSIGN]   value:";
        debug_print_str value_expr;
        
        val processed_array: string = process_expression(array_name);
        val processed_index: string = process_expression(index_expr);
        val processed_value: string = process_expression(value_expr);
        
        mut sb_arr: StringBuilder = StringBuilder.init(1256);
        StringBuilder.append(addr(sb_arr), processed_array);
        StringBuilder.append_char(addr(sb_arr), '[');
        StringBuilder.append(addr(sb_arr), processed_index);
        StringBuilder.append_char(addr(sb_arr), ']');
        
        if str_len(index2_expr) > 0 {
            val processed_index2: string = process_expression(index2_expr);
            StringBuilder.append_char(addr(sb_arr), '[');
            StringBuilder.append(addr(sb_arr), processed_index2);
            StringBuilder.append_char(addr(sb_arr), ']');
        }
        
        StringBuilder.append_c(addr(sb_arr), " = ");
        StringBuilder.append(addr(sb_arr), processed_value);
        StringBuilder.append_c(addr(sb_arr), ";\n");
        return StringBuilder.to_string(addr(sb_arr));
    }
    
    if equals_c(node_type, "FunctionCall") {
        val func_name: string = ast.data.func_call.function_name;
        
        val has_module_sep: bool = str_contains_c(func_name, "__");
        val is_method_call: bool = find_char_from(func_name, '.', 0) >= 0;
        val is_c_call: bool = has_prefix(func_name, str("C."));
        
        if !has_module_sep and !is_method_call and !is_c_call and !is_builtin_function(func_name) {
            if !StringStringMap.contains(addr(g_function_prefixes), func_name) {
                if !StringStringMap.contains(addr(g_function_param_types), func_name) {
                    val base_func: string = func_name;
                    if !is_symbol_imported(base_func) {
                        print(get_short_filename(g_current_source_file));
                        print ":";
                        print(i32_to_string(g_current_line));
                        print ": error: undefined symbol: ";
                        print base_func;
                        println ", perhaps missing 'use' statement?";
                        unsafe {
                            C.exit(1);
                        }
                    }
                }
            }
        }
        
        // Type check function call arguments (including nested calls)
        val call_args: ref list(string) = ast.data.func_call.args;
        if call_args != nil and len(deref(call_args)) > 0 {
            val args_str: string = strip(call_args.data[0]);
            validate_function_call(func_name, args_str, 0);
        }

        if equals_c(func_name, "append") {
            val args: ref list(string) = ast.data.func_call.args;
            mut var_name: string = str("");
            mut value: string = str("");
            mut args_extracted: bool = false;
            
            if args != nil and len(deref(args)) >= 1 {
                val args_str: string = strip(args.data[0]);
                mut comma_pos: i32 = -1;
                mut paren_depth: i32 = 0;
                mut bracket_depth: i32 = 0;
                mut brace_depth: i32 = 0;
                mut i: i32 = 0;
                loop {
                    if i >= str_len(args_str) {
                        break;
                    }
                    val ch: char = get_char(args_str, i);
                    if ch == '(' {
                        paren_depth = paren_depth + 1;
                    } elif ch == ')' {
                        paren_depth = paren_depth - 1;
                    } elif ch == '[' {
                        bracket_depth = bracket_depth + 1;
                    } elif ch == ']' {
                        bracket_depth = bracket_depth - 1;
                    } elif ch == '{' {
                        brace_depth = brace_depth + 1;
                    } elif ch == '}' {
                        brace_depth = brace_depth - 1;
                    } elif ch == ',' and paren_depth == 0 and bracket_depth == 0 and brace_depth == 0 {
                        comma_pos = i;
                        break;
                    }
                    i++;
                }
                
                if comma_pos > 0 {
                    var_name = strip(substring_se(args_str, 0, comma_pos));
                    value = strip(substring_se(args_str, comma_pos + 1, str_len(args_str)));
                    args_extracted = true;
                }
            }
            
            if args_extracted and str_len(var_name) > 0 and str_len(value) > 0 {
                val contains_in_list_of_types: bool = StringStringMap.contains(addr(g_list_of_types), var_name);
                
                if contains_in_list_of_types {
                    val element_type: string = StringStringMap.get(addr(g_list_of_types), var_name);
                    
                    debug_print_raw "\n[APPEND] Found in g_list_of_types: ";
                    debug_print_str element_type;

                    val c_element_type: string = map_axe_type_to_c(element_type);
                    val sanitized_element: string = sanitize_list_element_name(c_element_type);
                    val processed_value: string = process_expression(value);

                    mut sb_append: StringBuilder = StringBuilder.init(1256);
                    StringBuilder.append_c(addr(sb_append), "__list_");
                    StringBuilder.append(addr(sb_append), sanitized_element);
                    StringBuilder.append_c(addr(sb_append), "_push(&");
                    StringBuilder.append(addr(sb_append), var_name);
                    StringBuilder.append_c(addr(sb_append), ", ");
                    StringBuilder.append(addr(sb_append), processed_value);
                    StringBuilder.append_c(addr(sb_append), ");\n");

                    debug_print_raw "\n[DEBUG] Generated append code for '";
                    debug_print_str var_name;
                    debug_print_raw "'";
                    return StringBuilder.to_string(addr(sb_append));
                }

                elif StringStringMap.contains(addr(g_var_types), var_name) {
                    val var_type: string = StringStringMap.get(addr(g_var_types), var_name);
                    if has_prefix(var_type, str("list(")) or has_suffix(var_type, str("[999]")) {
                        mut element_type: string = var_type;
                        if has_prefix(element_type, str("list(")) {
                            mut paren_pos: i32 = 5;
                            mut depth: i32 = 1;
                            loop {
                                if paren_pos >= str_len(element_type) {
                                    break;
                                }
                                val ch: char = get_char(element_type, paren_pos);
                                if ch == '(' {
                                    depth++;
                                } elif ch == ')' {
                                    depth--;
                                    if depth == 0 {
                                        break;
                                    }
                                }
                                paren_pos = paren_pos + 1;
                            }
                            element_type = strip(substr(var_type, 5, paren_pos - 5));
                        } elif has_suffix(element_type, str("[999]")) {
                            element_type = strip(substring_se(var_type, 0, str_len(var_type) - 5));
                        }

                        val c_element_type: string = map_axe_type_to_c(element_type);
                        val sanitized_element: string = sanitize_list_element_name(c_element_type);
                        val processed_value: string = process_expression(value);

                        mut sb_append2: StringBuilder = StringBuilder.init(256);
                        StringBuilder.append_c(addr(sb_append2), "__list_");
                        StringBuilder.append(addr(sb_append2), sanitized_element);
                        StringBuilder.append_c(addr(sb_append2), "_push(&");
                        StringBuilder.append(addr(sb_append2), var_name);
                        StringBuilder.append_c(addr(sb_append2), ", ");
                        StringBuilder.append(addr(sb_append2), processed_value);
                        StringBuilder.append_c(addr(sb_append2), ");\n");

                        debug_print_raw "\n[DEBUG] Generated append code for '";
                        debug_print_str var_name;
                        debug_print_raw "'";
                        return StringBuilder.to_string(addr(sb_append2));
                    }
                }
            }
        }

        mut emitted_name: string = func_name;
        if StringStringMap.contains(addr(g_function_prefixes), func_name) {
            emitted_name = StringStringMap.get(addr(g_function_prefixes), func_name);
            debug_print_raw "\n[DBG-FUNCCALL]   Found prefix, emitting:";
            debug_print_str emitted_name;
        } else {
            debug_print_raw "\n[DBG-FUNCCALL]   No prefix found, emitting as-is";
        }

        mut sb_call: StringBuilder = StringBuilder.init(512);
        StringBuilder.append(addr(sb_call), emitted_name);
        StringBuilder.append_char(addr(sb_call), '(');

        val args: ref list(string) = ast.data.func_call.args;
        if args != nil {
            mut arg_idx: i32 = 0;
            loop {
                if arg_idx >= len(deref(args)) {
                    break;
                }

                if arg_idx > 0 {
                    StringBuilder.append_c(addr(sb_call), ", ");
                }

                val raw_arg: string = args.data[arg_idx];
                val processed_arg: string = process_expression(raw_arg);
                StringBuilder.append(addr(sb_call), processed_arg);
                arg_idx++;
            }
        }

        StringBuilder.append_c(addr(sb_call), ");\n");
        return StringBuilder.to_string(addr(sb_call));
    }
    
    if equals_c(node_type, "Print") {
        val messages_ref: ref list(string) = ast.data.print.messages;
        val flags_ref: ref list(bool) = ast.data.print.is_expressions;

        if messages_ref == nil or flags_ref == nil {
            return result;
        }

        val messages: list(string) = deref(messages_ref);
        val flags: list(bool) = deref(flags_ref);

        if len(messages) == 0 {
            return result;
        }

        if len(messages) == 1 and len(flags) == 1 and !flags.data[0] {
            mut sb_print: StringBuilder = StringBuilder.init(256);
            StringBuilder.append_c(addr(sb_print), "printf(\"");
            StringBuilder.append(addr(sb_print), messages.data[0]);
            StringBuilder.append_c(addr(sb_print), "\");\n");
            return StringBuilder.to_string(addr(sb_print));
        }

        result = strip_all_c_prefixes(result);
        return result;
    }
    
    if equals_c(node_type, "Loop") {
        mut sb_loop: StringBuilder = StringBuilder.init(1024);
        StringBuilder.append_c(addr(sb_loop), "while (1) {\n");
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i]));
                StringBuilder.append(addr(sb_loop), child_code);
                i++;
            }
        }
        StringBuilder.append_c(addr(sb_loop), "}\n");
        return StringBuilder.to_string(addr(sb_loop));
    }

    if equals_c(node_type, "Platform") {
        val platform_name: string = ast.data.platform_node.platform_name;

        mut sb_plat: StringBuilder = StringBuilder.init(1024);
        if equals_c(platform_name, "windows") {
            StringBuilder.append_c(addr(sb_plat), "#ifdef _WIN32\n");
        } elif equals_c(platform_name, "posix") {
            StringBuilder.append_c(addr(sb_plat), "#ifndef _WIN32\n");
        }

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i: i32 = 0;
            loop {
                if i >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i]));
                StringBuilder.append(addr(sb_plat), child_code);
                i++;
            }
        }

        StringBuilder.append_c(addr(sb_plat), "#endif\n");
        return StringBuilder.to_string(addr(sb_plat));
    }
    
    if equals_c(node_type, "For") {
        val init_raw: string = ast.data.for_loop.initialization;
        val cond_raw: string = ast.data.for_loop.condition;
        val incr_raw: string = ast.data.for_loop.increment;

        mut init: string = strip(init_raw);
        val cond: string = strip(cond_raw);
        val incr: string = strip(incr_raw);

        mut loop_var_name: string = str("");
        mut loop_var_added: bool = false;

        if has_prefix(init, str("mut ")) {
            init = strip(substr(init, 4, str_len(init) - 4));
            
            mut k_var: i32 = 0;
            val init_len: i32 = cast[i32](str_len(init));
            loop {
                if k_var >= init_len { break; }
                if !is_token_char(get_char(init, k_var)) { break; }
                k_var = k_var + 1;
            }
            if k_var > 0 {
                loop_var_name = substring_se(init, 0, k_var);
                if !StringStringMap.contains(addr(g_var_types), loop_var_name) {
                    mut temp_arena: Arena = Arena.create(256);
                    StringStringMap.set(addr(g_var_types), addr(temp_arena), loop_var_name, str("i32"));
                    loop_var_added = true;
                }
            }
        }

        mut sb_header: StringBuilder = StringBuilder.init(256);
        StringBuilder.append_c(addr(sb_header), "int32_t ");
        StringBuilder.append(addr(sb_header), init);
        StringBuilder.append_c(addr(sb_header), "; ");
        StringBuilder.append(addr(sb_header), cond);
        StringBuilder.append_c(addr(sb_header), "; ");
        StringBuilder.append(addr(sb_header), incr);

        mut header: string = StringBuilder.to_string(addr(sb_header));
        StringBuilder.destroy(addr(sb_header));

        header = replace_all(header, str("+ ="), str("+="));
        header = replace_all(header, str("- ="), str("-="));
        header = replace_all(header, str("+  ="), str("+="));
        header = replace_all(header, str("-  ="), str("-="));

        val header_norm: string = process_expression(header);

        mut sb_for: StringBuilder = StringBuilder.init(1024);
        StringBuilder.append_c(addr(sb_for), "for (");
        StringBuilder.append(addr(sb_for), header_norm);
        StringBuilder.append_c(addr(sb_for), ") {\n");

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_for: i32 = 0;
            loop {
                if i_for >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_for]));
                StringBuilder.append(addr(sb_for), child_code);
                i_for = i_for + 1;
            }
        }

        StringBuilder.append_c(addr(sb_for), "}\n");
        
        if loop_var_added {
            StringStringMap.pop(addr(g_var_types), loop_var_name);
        }

        return StringBuilder.to_string(addr(sb_for));
    }
    
    if equals_c(node_type, "ParallelFor") {
        val init_raw: string = ast.data.parallel_for.initialization;
        val cond_raw: string = ast.data.parallel_for.condition;
        val incr_raw: string = ast.data.parallel_for.increment;

        mut init: string = strip(init_raw);
        val cond: string = strip(cond_raw);
        val incr: string = strip(incr_raw);

        if has_prefix(init, str("mut ")) {
            init = strip(substr(init, 4, str_len(init) - 4));
        }

        mut sb_pheader: StringBuilder = StringBuilder.init(256);
        StringBuilder.append(addr(sb_pheader), init);
        StringBuilder.append_c(addr(sb_pheader), "; ");
        StringBuilder.append(addr(sb_pheader), cond);
        StringBuilder.append_c(addr(sb_pheader), "; ");
        StringBuilder.append(addr(sb_pheader), incr);

        mut header: string = StringBuilder.to_string(addr(sb_pheader));
        StringBuilder.destroy(addr(sb_pheader));

        header = replace_all(header, str("+ ="), str("+="));
        header = replace_all(header, str("- ="), str("-="));
        header = replace_all(header, str("+  ="), str("+="));
        header = replace_all(header, str("-  ="), str("-="));

        val header_norm: string = process_expression(header);

        mut sb_pfor: StringBuilder = StringBuilder.init(1024);
        
        StringBuilder.append_c(addr(sb_pfor), "#pragma omp parallel for");
        
        val reduction_clauses: ref list(string) = ast.data.parallel_for.reduction_clauses;

        if reduction_clauses != nil and len(deref(reduction_clauses)) > 0 {
            StringBuilder.append_c(addr(sb_pfor), " reduction(");
            mut ri: i32 = 0;
            loop {
                if ri >= len(deref(reduction_clauses)) {
                    break;
                }
                if ri > 0 {
                    StringBuilder.append_c(addr(sb_pfor), ", ");
                }
                StringBuilder.append(addr(sb_pfor), reduction_clauses.data[ri]);
                ri = ri + 1;
            }
            StringBuilder.append_c(addr(sb_pfor), ")");
        }
        
        StringBuilder.append_c(addr(sb_pfor), "\n");
        StringBuilder.append_c(addr(sb_pfor), "for (");
        StringBuilder.append(addr(sb_pfor), header_norm);
        StringBuilder.append_c(addr(sb_pfor), ") {\n");

        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_pfor: i32 = 0;
            loop {
                if i_pfor >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_pfor]));
                StringBuilder.append(addr(sb_pfor), child_code);
                i_pfor = i_pfor + 1;
            }
        }

        StringBuilder.append_c(addr(sb_pfor), "}\n");
        return StringBuilder.to_string(addr(sb_pfor));
    }
    
    if equals_c(node_type, "Parallel") {
        mut sb_par: StringBuilder = StringBuilder.init(512);
        StringBuilder.append_c(addr(sb_par), "#pragma omp parallel\n{\n");
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_par: i32 = 0;
            loop {
                if i_par >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_par]));
                StringBuilder.append(addr(sb_par), child_code);
                i_par++;
            }
        }
        
        StringBuilder.append_c(addr(sb_par), "}\n");
        return StringBuilder.to_string(addr(sb_par));
    }
    
    if equals_c(node_type, "Single") {
        mut sb_single: StringBuilder = StringBuilder.init(512);
        StringBuilder.append_c(addr(sb_single), "#pragma omp single\n{\n");
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_single: i32 = 0;
            loop {
                if i_single >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_single]));
                StringBuilder.append(addr(sb_single), child_code);
                i_single = i_single + 1;
            }
        }
        
        StringBuilder.append_c(addr(sb_single), "}\n");
        return StringBuilder.to_string(addr(sb_single));
    }
    
    if equals_c(node_type, "ParallelLocal") {
        mut sb_ploc: StringBuilder = StringBuilder.init(512);
        
        val private_vars: ref list(string) = ast.data.parallel_local.private_vars;
        val private_types: ref list(string) = ast.data.parallel_local.private_types;
        
        mut vi: i32 = 0;
        loop {
            if vi >= len(deref(private_vars)) {
                break;
            }
            val var_name: string = private_vars.data[vi];
            val type_name: string = private_types.data[vi];
            val c_type: string = map_axe_type_to_c(type_name);
            
            StringBuilder.append(addr(sb_ploc), c_type);
            StringBuilder.append_c(addr(sb_ploc), " ");
            StringBuilder.append(addr(sb_ploc), var_name);
            StringBuilder.append_c(addr(sb_ploc), ";\n");
            vi = vi + 1;
        }
        
        StringBuilder.append_c(addr(sb_ploc), "#pragma omp parallel private(");
        mut pi: i32 = 0;
        loop {
            if pi >= len(deref(private_vars)) {
                break;
            }
            if pi > 0 {
                StringBuilder.append_c(addr(sb_ploc), ", ");
            }
            StringBuilder.append(addr(sb_ploc), private_vars.data[pi]);
            pi = pi + 1;
        }
        StringBuilder.append_c(addr(sb_ploc), ")\n{\n");
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_ploc: i32 = 0;
            loop {
                if i_ploc >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_ploc]));
                StringBuilder.append(addr(sb_ploc), child_code);
                i_ploc = i_ploc + 1;
            }
        }
        
        StringBuilder.append_c(addr(sb_ploc), "}\n");
        return StringBuilder.to_string(addr(sb_ploc));
    }
    
    if equals_c(node_type, "ForIn") {
        // for item in collection { ... }
        // Generate: for (int32_t _i_item = 0; _i_item < collection->len; _i_item++) {
        //              typeof(collection->data[0]) item = collection->data[_i_item];
        //              ... body ...
        //          }
        val var_name: string = ast.data.for_in.var_name;
        val array_name_raw: string = ast.data.for_in.array_name;
        
        mut array_name: string = process_expression(array_name_raw);
        array_name = rewrite_method_calls(array_name);
        array_name = rewrite_function_prefixes(array_name);
        
        mut index_var: string = str("_i_");
        index_var = concat(index_var, var_name);
        
        mut accessor: string = str(".");
        val trimmed_coll: string = strip(array_name_raw);

        if StringStringMap.contains(addr(g_var_types), trimmed_coll) {
            val coll_type: string = StringStringMap.get(addr(g_var_types), trimmed_coll);
            mut t: string = strip(coll_type);
            if has_prefix(t, str("mut ")) {
                t = strip(substr(t, 4, str_len(t) - 4));
            }
            if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                accessor = str("->");
            }
        } else {
            accessor = str("->");
        }
        
        mut sb_forin: StringBuilder = StringBuilder.init(1024);

        StringBuilder.append_c(addr(sb_forin), "for (int32_t ");
        StringBuilder.append(addr(sb_forin), index_var);
        StringBuilder.append_c(addr(sb_forin), " = 0; ");
        StringBuilder.append(addr(sb_forin), index_var);
        StringBuilder.append_c(addr(sb_forin), " < ");
        StringBuilder.append(addr(sb_forin), array_name);
        StringBuilder.append(addr(sb_forin), accessor);
        StringBuilder.append_c(addr(sb_forin), "len; ");
        StringBuilder.append(addr(sb_forin), index_var);
        StringBuilder.append_c(addr(sb_forin), "++) {\n");
        StringBuilder.append_c(addr(sb_forin), "typeof(");
        StringBuilder.append(addr(sb_forin), array_name);
        StringBuilder.append(addr(sb_forin), accessor);
        StringBuilder.append_c(addr(sb_forin), "data[0]) ");
        StringBuilder.append(addr(sb_forin), var_name);
        StringBuilder.append_c(addr(sb_forin), " = ");
        StringBuilder.append(addr(sb_forin), array_name);
        StringBuilder.append(addr(sb_forin), accessor);
        StringBuilder.append_c(addr(sb_forin), "data[");
        StringBuilder.append(addr(sb_forin), index_var);
        StringBuilder.append_c(addr(sb_forin), "];\n");
        
        StringStringMap.set(addr(g_var_types), addr(arena), var_name, str("auto"));
        
        if ast.children != nil {
            val children: ref list(ASTNode) = ast.children;
            mut i_for_in: i32 = 0;
            loop {
                if i_for_in >= len(deref(children)) {
                    break;
                }
                val child_code: string = generate_c(addr(children.data[i_for_in]));
                StringBuilder.append(addr(sb_forin), child_code);
                i_for_in = i_for_in + 1;
            }
        }
        
        StringBuilder.append_c(addr(sb_forin), "}\n");
        return StringBuilder.to_string(addr(sb_forin));
    }
    
    if equals_c(node_type, "If") {
        mut current_if: ref ASTNode = ast;
        mut is_first: bool = true;
        mut sb_if: StringBuilder = StringBuilder.init(2048);
        
        loop {
            if current_if == nil {
                break;
            }
            
            val condition: string = current_if.data.if_node.condition;
            mut trimmed_cond: string = strip(condition);
            trimmed_cond = process_expression(trimmed_cond);

            if is_first {
                StringBuilder.append_c(addr(sb_if), "if (");
            } else {
                StringBuilder.append_c(addr(sb_if), "else if (");
            }
            StringBuilder.append(addr(sb_if), trimmed_cond);
            StringBuilder.append_c(addr(sb_if), ") {\n");
            is_first = false;

            mut else_marker_idx: i32 = -1;
            if current_if.children != nil {
                val children: ref list(ASTNode) = current_if.children;
                mut i: i32 = 0;
                loop {
                    if i >= len(deref(children)) {
                        break;
                    }
                    val child_ref: ref ASTNode = addr(children.data[i]);
                    if equals_c(child_ref.node_type, "ElseMarker") {
                        else_marker_idx = i;
                        break;
                    }
                    val child_code: string = generate_c(child_ref);
                    StringBuilder.append(addr(sb_if), child_code);
                    i++;
                }
            }

            StringBuilder.append_c(addr(sb_if), "}\n");

            if current_if.children != nil and else_marker_idx >= 0 {
                val children: ref list(ASTNode) = current_if.children;
                val child_count: i32 = len(deref(children));
                
                if else_marker_idx + 1 < child_count {
                    val first_else_child: ref ASTNode = addr(children.data[else_marker_idx + 1]);
                    
                    if equals_c(first_else_child.node_type, "If") and else_marker_idx + 2 == child_count {
                        current_if = first_else_child;
                        continue;
                    } else {
                        StringBuilder.append_c(addr(sb_if), "else {\n");
                        mut j: i32 = else_marker_idx + 1;
                        loop {
                            if j >= child_count {
                                break;
                            }
                            val else_child: ref ASTNode = addr(children.data[j]);
                            val else_code: string = generate_c(else_child);
                            StringBuilder.append(addr(sb_if), else_code);
                            j = j + 1;
                        }
                        StringBuilder.append_c(addr(sb_if), "}\n");
                        break;
                    }
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        return StringBuilder.to_string(addr(sb_if));
    }
    
    if equals_c(node_type, "Unsafe") {
        val body: ref list(ASTNode) = ast.data.unsafe_node.body;
        mut sb_unsafe: StringBuilder = StringBuilder.init(1024);
        if body != nil {
            mut i_unsafe: i32 = 0;
            loop {
                if i_unsafe >= len(deref(body)) {
                    break;
                }
                val child_code: string = generate_c(addr(body.data[i_unsafe]));
                debug_print_raw "\n[DBG-UNSAFE] Processing unsafe block child (index ";
                debug_print_str(int_to_ascii(i_unsafe));
                debug_print_raw ")\n";
                debug_print_str child_code;
                StringBuilder.append(addr(sb_unsafe), child_code);
                i_unsafe++;
            }
        }
        mut unsafe_result: string = StringBuilder.to_string(addr(sb_unsafe));
        StringBuilder.destroy(addr(sb_unsafe));
        debug_print_raw "\n[DBG-UNSAFE] Before method call transformation:";
        debug_print_str unsafe_result;
        unsafe_result = rewrite_method_calls(unsafe_result);
        debug_print_raw "\n[DBG-UNSAFE] After method call transformation:";
        debug_print_str unsafe_result;
        unsafe_result = rewrite_function_prefixes(unsafe_result);
        debug_print_raw "\n[DBG-UNSAFE] After function prefix transformation:";
        debug_print_str unsafe_result;
        return unsafe_result;
    }

    if equals_c(node_type, "RawC") {
        val raw_code: string = ast.data.raw_c.code;
        debug_print_raw "\n[DBG-RAWC] RawC node emitting:";
        debug_print_str raw_code;
        mut sb_rawc: StringBuilder = StringBuilder.init(256);
        StringBuilder.append(addr(sb_rawc), raw_code);
        StringBuilder.append_char(addr(sb_rawc), '\n');
        return StringBuilder.to_string(addr(sb_rawc));
    }
    
    if equals_c(node_type, "Model") {
        val model_name: string = ast.data.model_node.name;
        val is_public: bool = ast.data.model_node.is_public;
        val field_names: ref list(string) = ast.data.model_node.field_names;
        val field_types: ref list(string) = ast.data.model_node.field_types;
        val union_parents: ref list(string) = ast.data.model_node.union_member_parents;
        val union_names: ref list(string) = ast.data.model_node.union_member_names;
        val union_types: ref list(string) = ast.data.model_node.union_member_types;

        if StringBoolMap.contains(addr(g_generated_typedefs), model_name) {
            return str("");
        }

        mut typedef_arena: Arena = Arena.create(1024);

        StringBoolMap.set(addr(g_generated_typedefs), addr(typedef_arena), model_name, true);

        mut sb: StringBuilder = StringBuilder.init(4096);

        StringBuilder.append_c(addr(sb), "typedef struct ");
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append_c(addr(sb), " {\n");

        if field_names != nil and field_types != nil {
            mut field_idx: i32 = 0;
            loop {
                if field_idx >= len(deref(field_names)) {
                    break;
                }

                val field_name: string = field_names.data[field_idx];
                val field_type: string = field_types.data[field_idx];
                
                if !equals_c(field_type, "union") and !equals_c(field_type, "model") {
                    validate_type_imported(field_type);
                }
                
                mut field_key: string = model_name;

                field_key = concat(field_key, str("."));
                field_key = concat(field_key, field_name);

                StringStringMap.set(addr(g_field_types), addr(arena), field_key, field_type);
                
                // Mark pointer fields in g_pointer_fields (similar to D compiler)
                if has_prefix(field_type, str("ref ")) {
                    StringBoolMap.set(addr(g_pointer_fields), addr(arena), field_key, true);
                } elif has_suffix(field_type, str("*")) {
                    StringBoolMap.set(addr(g_pointer_fields), addr(arena), field_key, true);
                } elif has_suffix(field_type, str("[999]")) {
                    StringBoolMap.set(addr(g_pointer_fields), addr(arena), field_key, true);
                } elif compare(field_type, model_name) == 0 {
                    // Self-referential field is a pointer
                    StringBoolMap.set(addr(g_pointer_fields), addr(arena), field_key, true);
                }

                if str_len(field_type) == 5 and equals_c(field_type, "union") and union_parents != nil and union_names != nil and union_types != nil {
                    StringBuilder.append_c(addr(sb), "    union {\n");

                    val up: list(string) = deref(union_parents);
                    val un: list(string) = deref(union_names);
                    val ut: list(string) = deref(union_types);

                    mut uidx: i32 = 0;
                    loop {
                        if uidx >= len(up) or uidx >= len(un) or uidx >= len(ut) {
                            break;
                        }

                        val parent_name: string = up.data[uidx];
                        if compare(parent_name, field_name) == 0 {
                            val member_name: string = un.data[uidx];
                            val member_type_raw: string = ut.data[uidx];

                            if str_len(member_type_raw) == 5 and equals_c(member_type_raw, "model") {
                                StringBuilder.append_c(addr(sb), "        struct {\n");

                                mut nidx: i32 = 0;
                                loop {
                                    if nidx >= len(up) or nidx >= len(un) or nidx >= len(ut) {
                                        break;
                                    }

                                    val nested_parent: string = up.data[nidx];
                                    if compare(nested_parent, member_name) == 0 {
                                        val nested_name: string = un.data[nidx];
                                        val nested_type_raw: string = ut.data[nidx];

                                        mut mapped_nested_type: string = map_axe_type_to_c(nested_type_raw);
                                        mut nested_array_part: string = str("");

                                        if has_suffix(nested_type_raw, str("[999]")) {
                                            if !has_suffix(mapped_nested_type, str("*")) {
                                                mapped_nested_type = concat(mapped_nested_type, str("*"));
                                            }
                                        }

                                        val n_bracket_pos: i32 = find_char_from(mapped_nested_type, '[', 0);
                                        if n_bracket_pos >= 0 {
                                            nested_array_part = substring_se(mapped_nested_type, n_bracket_pos, str_len(mapped_nested_type));
                                            mapped_nested_type = substring_se(mapped_nested_type, 0, n_bracket_pos);
                                        }

                                        if has_prefix(mapped_nested_type, str("ref ")) {
                                            mapped_nested_type = concat(strip(substring_se(mapped_nested_type, 4, str_len(mapped_nested_type))), str("*"));
                                        }

                                        val c_nested_model_name: string = canonical_model_c_name(mapped_nested_type);
                                        if str_len(c_nested_model_name) > 0 {
                                            if StringBoolMap.contains(addr(g_enum_names), c_nested_model_name) {
                                                mapped_nested_type = c_nested_model_name;
                                            } else {
                                                mapped_nested_type = concat(str("struct "), c_nested_model_name);
                                            }
                                        }

                                        StringBuilder.append_c(addr(sb), "            ");
                                        StringBuilder.append(addr(sb), mapped_nested_type);
                                        StringBuilder.append_char(addr(sb), ' ');
                                        StringBuilder.append(addr(sb), nested_name);
                                        StringBuilder.append(addr(sb), nested_array_part);
                                        StringBuilder.append_c(addr(sb), ";\n");
                                    }

                                    nidx = nidx + 1;
                                }

                                StringBuilder.append_c(addr(sb), "        } ");
                                StringBuilder.append(addr(sb), member_name);
                                StringBuilder.append_c(addr(sb), ";\n");
                            } else {
                                mut mapped_member_type: string = map_axe_type_to_c(member_type_raw);
                                mut member_array_part: string = str("");

                                if has_suffix(member_type_raw, str("[999]")) {
                                    if !has_suffix(mapped_member_type, str("*")) {
                                        mapped_member_type = concat(mapped_member_type, str("*"));
                                    }
                                }

                                val m_bracket_pos: i32 = find_char_from(mapped_member_type, '[', 0);
                                if m_bracket_pos >= 0 {
                                    member_array_part = substring_se(mapped_member_type, m_bracket_pos, str_len(mapped_member_type));
                                    mapped_member_type = substring_se(mapped_member_type, 0, m_bracket_pos);
                                }

                                if has_prefix(mapped_member_type, str("ref ")) {
                                    mapped_member_type = concat(strip(substring_se(mapped_member_type, 4, str_len(mapped_member_type))), str("*"));
                                }

                                val c_member_model_name: string = canonical_model_c_name(mapped_member_type);
                                if str_len(c_member_model_name) > 0 {
                                    if StringBoolMap.contains(addr(g_enum_names), c_member_model_name) {
                                        mapped_member_type = c_member_model_name;
                                    } else {
                                        mapped_member_type = concat(str("struct "), c_member_model_name);
                                    }
                                }

                                StringBuilder.append_c(addr(sb), "        ");
                                StringBuilder.append(addr(sb), mapped_member_type);
                                StringBuilder.append_char(addr(sb), ' ');
                                StringBuilder.append(addr(sb), member_name);
                                StringBuilder.append(addr(sb), member_array_part);
                                StringBuilder.append_c(addr(sb), ";\n");
                            }
                        }

                        uidx = uidx + 1;
                    }

                    StringBuilder.append_c(addr(sb), "    } ");
                    StringBuilder.append(addr(sb), field_name);
                    StringBuilder.append_c(addr(sb), ";\n");
                } else {
                    mut mapped_type: string = map_axe_type_to_c(field_type);
                    mut array_part: string = str("");

                    if has_suffix(field_type, str("[999]")) {
                        if !has_suffix(mapped_type, str("*")) {
                            mapped_type = concat(mapped_type, str("*"));
                        }
                    }

                    val bracket_pos: i32 = find_char_from(mapped_type, '[', 0);
                    if bracket_pos >= 0 {
                        array_part = substring_se(mapped_type, bracket_pos, str_len(mapped_type));
                        mapped_type = substring_se(mapped_type, 0, bracket_pos);
                    }

                    if has_prefix(mapped_type, str("ref ")) {
                        mapped_type = concat(strip(substring_se(mapped_type, 4, str_len(mapped_type))), str("*"));
                    }

                    val c_model_name: string = canonical_model_c_name(mapped_type);
                    if str_len(c_model_name) > 0 {
                        if StringBoolMap.contains(addr(g_enum_names), c_model_name) {
                            mapped_type = c_model_name;
                        } else {
                            mapped_type = concat(str("struct "), c_model_name);
                        }
                    }

                    StringBuilder.append_c(addr(sb), "    ");
                    StringBuilder.append(addr(sb), mapped_type);
                    StringBuilder.append_char(addr(sb), ' ');
                    StringBuilder.append(addr(sb), field_name);
                    StringBuilder.append(addr(sb), array_part);
                    StringBuilder.append_c(addr(sb), ";\n");
                }

                field_idx++;
            }
        }

        StringBuilder.append_c(addr(sb), "} ");
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append_c(addr(sb), ";\n\n");
        result = StringBuilder.to_string(addr(sb));
        StringBuilder.destroy(addr(sb));
        return result;
    }

    if equals_c(node_type, "Enum") {
        val enum_name: string = ast.data.enum_node.name;
        val enum_values: ref list(string) = ast.data.enum_node.values;
        
        if StringBoolMap.contains(addr(g_generated_typedefs), enum_name) {
            return str("");
        }
        
        mut enum_arena: Arena = Arena.create(1024);
        StringBoolMap.set(addr(g_generated_typedefs), addr(enum_arena), enum_name, true);
        StringBoolMap.set(addr(g_enum_names), addr(enum_arena), enum_name, true);
        
        mut base_enum_name: string = enum_name;
        mut last_sep_enum: i32 = -1;
        mut ei: i32 = 0;
        val elen: i32 = str_len(enum_name);
        loop {
            if ei + 1 >= elen {
                break;
            }
            val ec1: char = get_char(enum_name, ei);
            val ec2: char = get_char(enum_name, ei + 1);
            if ec1 == '_' and ec2 == '_' {
                last_sep_enum = ei;
            }
            ei = ei + 1;
        }

        if last_sep_enum >= 0 and last_sep_enum + 2 < elen {
            base_enum_name = substring_se(enum_name, last_sep_enum + 2, elen);
        }

        if str_len(base_enum_name) > 0 {
            StringStringMap.set(addr(g_model_names), addr(enum_arena), base_enum_name, enum_name);
            StringBoolMap.set(addr(g_enum_names), addr(enum_arena), base_enum_name, true);
        }
        
        mut sb_enum: StringBuilder = StringBuilder.init(1024);
        StringBuilder.append_c(addr(sb_enum), "typedef enum {\n");
        
        if enum_values != nil {
            mut value_idx: i32 = 0;
            val num_values: i32 = len(deref(enum_values));
            
            loop {
                if value_idx >= num_values {
                    break;
                }
                
                val enum_value: string = enum_values.data[value_idx];
                
                StringBuilder.append_c(addr(sb_enum), "    ");
                StringBuilder.append(addr(sb_enum), enum_name);
                StringBuilder.append_char(addr(sb_enum), '_');
                StringBuilder.append(addr(sb_enum), enum_value);
                
                if value_idx < num_values - 1 {
                    StringBuilder.append_char(addr(sb_enum), ',');
                }
                StringBuilder.append_char(addr(sb_enum), '\n');
                
                value_idx++;
            }
        }
        
        StringBuilder.append_c(addr(sb_enum), "} ");
        StringBuilder.append(addr(sb_enum), enum_name);
        StringBuilder.append_c(addr(sb_enum), ";\n\n");
        
        result = StringBuilder.to_string(addr(sb_enum));
        StringBuilder.destroy(addr(sb_enum));
        return result;
    }

    if equals_c(node_type, "Extern") {
        val func_name: string = ast.data.extern_node.function_name;
        mut extern_arena: Arena = Arena.create(2560);
        StringBoolMap.set(addr(g_generated_functions), addr(extern_arena), func_name, true);
        return str("");
    }
    
    if equals_c(node_type, "Opaque") {
        val onames: ref list(string) = ast.data.opaque_node.type_names;
        if onames != nil {
            mut arena_opaque: Arena = Arena.create(2560);
            mut sb_opaque: StringBuilder = StringBuilder.init(512);
            mut oi: i32 = 0;
            loop {
                if oi >= len(deref(onames)) {
                    break;
                }
                val type_name: string = onames.data[oi];
                StringBoolMap.set(addr(g_opaque_types), addr(arena_opaque), type_name, true);
                StringBuilder.append_c(addr(sb_opaque), "typedef struct ");
                StringBuilder.append(addr(sb_opaque), type_name);
                StringBuilder.append_char(addr(sb_opaque), ' ');
                StringBuilder.append(addr(sb_opaque), type_name);
                StringBuilder.append_c(addr(sb_opaque), ";\n");
                oi++;
            }
            return StringBuilder.to_string(addr(sb_opaque));
        }
        return result;
    }
    
    if equals_c(node_type, "Foreign") {
        val fnames: ref list(string) = ast.data.foreign_node.type_names;
        if fnames != nil {
            mut arena_foreign: Arena = Arena.create(2560);
            mut fi: i32 = 0;
            loop {
                if fi >= len(deref(fnames)) {
                    break;
                }
                val type_name: string = fnames.data[fi];
                StringBoolMap.set(addr(g_foreign_types), addr(arena_foreign), type_name, true);
                fi++;
            }
        }
        return str("");
    }
    
    if equals_c(node_type, "IncDec") {
        val variable: string = ast.data.inc_dec.variable;
        val is_increment: bool = ast.data.inc_dec.is_increment;
        
        mut sb_incdec: StringBuilder = StringBuilder.init(64);
        StringBuilder.append(addr(sb_incdec), variable);
        if is_increment {
            StringBuilder.append_c(addr(sb_incdec), "++");
        } else {
            StringBuilder.append_c(addr(sb_incdec), "--");
        }
        StringBuilder.append_c(addr(sb_incdec), ";\n");
        return StringBuilder.to_string(addr(sb_incdec));
    }
    
    if equals_c(node_type, "MemberIncDec") {
        val object_name: string = ast.data.member_inc_dec.object_name;
        val member_name: string = ast.data.member_inc_dec.member_name;
        val is_increment: bool = ast.data.member_inc_dec.is_increment;
        mut access_op: string = str(".");
        val trimmed_obj: string = strip(object_name);

        if StringStringMap.contains(addr(g_var_types), trimmed_obj) {
            val raw_type: string = StringStringMap.get(addr(g_var_types), trimmed_obj);
            mut t: string = strip(raw_type);
            if has_prefix(t, str("mut ")) {
                t = strip(substr(t, 4, str_len(t) - 4));
            }
            if has_prefix(t, str("ref ")) or has_suffix(t, str("*")) {
                access_op = str("->");
            }
        }
        
        mut sb_minc: StringBuilder = StringBuilder.init(128);
        StringBuilder.append(addr(sb_minc), trimmed_obj);
        StringBuilder.append(addr(sb_minc), access_op);
        StringBuilder.append(addr(sb_minc), member_name);
        if is_increment {
            StringBuilder.append_c(addr(sb_minc), "++");
        } else {
            StringBuilder.append_c(addr(sb_minc), "--");
        }
        StringBuilder.append_c(addr(sb_minc), ";\n");
        return StringBuilder.to_string(addr(sb_minc));
    }
    
    if equals_c(node_type, "PtrMemberIncDec") {
        val ptr_object: string = ast.data.member_inc_dec.object_name;
        val ptr_member: string = ast.data.member_inc_dec.member_name;
        val ptr_is_inc: bool = ast.data.member_inc_dec.is_increment;
        
        mut sb_pinc: StringBuilder = StringBuilder.init(128);
        StringBuilder.append(addr(sb_pinc), strip(ptr_object));
        StringBuilder.append_c(addr(sb_pinc), "->");
        StringBuilder.append(addr(sb_pinc), ptr_member);
        if ptr_is_inc {
            StringBuilder.append_c(addr(sb_pinc), "++");
        } else {
            StringBuilder.append_c(addr(sb_pinc), "--");
        }
        StringBuilder.append_c(addr(sb_pinc), ";\n");
        return StringBuilder.to_string(addr(sb_pinc));
    }
    
    if equals_c(node_type, "PtrMemberAccess") {
        val ptr_obj: string = ast.data.member_access.object_name;
        val ptr_memb: string = ast.data.member_access.member_name;
        val ptr_val: string = ast.data.member_access.value;
        
        mut sb_ptr: StringBuilder = StringBuilder.init(512);
        StringBuilder.append(addr(sb_ptr), strip(ptr_obj));
        StringBuilder.append_c(addr(sb_ptr), "->");
        StringBuilder.append(addr(sb_ptr), ptr_memb);
        
        if str_len(strip(ptr_val)) > 0 {
            StringBuilder.append_c(addr(sb_ptr), " = ");
            val processed_ptr_val: string = process_expression(ptr_val);
            StringBuilder.append(addr(sb_ptr), processed_ptr_val);
        }

        StringBuilder.append_c(addr(sb_ptr), ";\n");
        return StringBuilder.to_string(addr(sb_ptr));
    }
    
    return result;
}

test {
    initialize_renderer();
    
    println "\nTest 1: Initialize renderer";
    assert StringStringMap.contains(addr(g_type_mappings), str("i32")), "Expected i32 type mapping";
    assert equals_c(map_type(str("i32")), "int32_t"), "Expected i32 to map to int32_t";
    
    println "\nTest 2: Map types";
    assert equals_c(map_type(str("i64")), "int64_t"), "Expected i64 to map to int64_t";
    assert equals_c(map_type(str("f32")), "float"), "Expected f32 to map to float";
    assert equals_c(map_type(str("bool")), "bool"), "Expected bool to map to bool";
    
    println "\nTest 3: Generate empty program";
    mut empty_ast: ASTNode;
    empty_ast.node_type = str("Program");
    empty_ast.children = nil;
    val code: string = generate_c(addr(empty_ast));
    assert str_contains_c(code, "#include <stdio.h>"), "Expected stdio.h include";
    assert str_contains_c(code, "#include <stdint.h>"), "Expected stdint.h include";
    
    println "\nTest 4: Generate main function";
    mut func_ast: ASTNode;
    func_ast.node_type = str("Function");
    func_ast.data.function.name = str("main");
    func_ast.data.function.return_type = str("i32");
    func_ast.data.function.is_public = false;
    func_ast.data.function.params = nil;
    func_ast.children = nil;
    val func_code: string = generate_c(addr(func_ast));
    assert str_contains_c(func_code, "int main"), "Expected int main function";
    assert str_contains_c(func_code, "return 0;"), "Expected return 0 in main";

    mut model_arena: Arena = Arena.create(4096);

    println "\nTest 5: Generate simple function";
    mut simple_func: ASTNode;
    simple_func.node_type = str("Function");
    simple_func.data.function.name = str("add");
    simple_func.data.function.return_type = str("i32");
    simple_func.data.function.is_public = false;
    simple_func.data.function.params = nil;
    simple_func.children = nil;
    val simple_code: string = generate_c(addr(simple_func));
    assert str_contains_c(simple_code, "int32_t add"), "Expected int32_t add function";
    
    println "\nTest 6: Process parameter types";
    assert equals_c(process_parameter_type(str("i32")), "int32_t"), "Expected i32 -> int32_t";
    assert equals_c(process_parameter_type(str("ref i32")), "int32_t*"), "Expected ref i32 -> int32_t*";
    assert equals_c(process_parameter_type(str("mut i32")), "int32_t"), "Expected mut i32 -> int32_t";
    assert equals_c(process_parameter_type(str("i32*")), "int32_t*"), "Expected i32* -> int32_t*";
    
    println "\nTest 7: Generate simple model";
    mut model_ast: ASTNode;
    model_ast.node_type = str("Model");
    model_ast.data.model_node.name = str("Point");
    model_ast.data.model_node.is_public = false;
    
    val field_names_list: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names_list, addr(model_arena), str("x"));
    StringList.push(field_names_list, addr(model_arena), str("y"));
    model_ast.data.model_node.field_names = field_names_list;
    
    val field_types_list: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types_list, addr(model_arena), str("i32"));
    StringList.push(field_types_list, addr(model_arena), str("i32"));
    model_ast.data.model_node.field_types = field_types_list;
    
    model_ast.children = nil;
    val model_code: string = generate_c(addr(model_ast));
    assert str_contains_c(model_code, "struct Point"), "Expected struct Point";
    assert str_contains_c(model_code, "int32_t x"), "Expected int32_t x field";
    assert str_contains_c(model_code, "int32_t y"), "Expected int32_t y field";
    
    println "\nTest 8: Generate model with different types";
    mut model2_ast: ASTNode;
    model2_ast.node_type = str("Model");
    model2_ast.data.model_node.name = str("Person");
    model2_ast.data.model_node.is_public = true;
    
    val field_names2: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names2, addr(model_arena), str("age"));
    StringList.push(field_names2, addr(model_arena), str("height"));
    StringList.push(field_names2, addr(model_arena), str("active"));
    model2_ast.data.model_node.field_names = field_names2;
    
    val field_types2: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types2, addr(model_arena), str("i32"));
    StringList.push(field_types2, addr(model_arena), str("f32"));
    StringList.push(field_types2, addr(model_arena), str("bool"));
    model2_ast.data.model_node.field_types = field_types2;
    
    model2_ast.children = nil;
    val model2_code: string = generate_c(addr(model2_ast));
    assert str_contains_c(model2_code, "struct Person"), "Expected struct Person";
    assert str_contains_c(model2_code, "int32_t age"), "Expected int32_t age field";
    assert str_contains_c(model2_code, "float height"), "Expected float height field";
    assert str_contains_c(model2_code, "bool active"), "Expected bool active field";
    
    println "\nTest 9: Model with array field";
    mut model3_ast: ASTNode;
    model3_ast.node_type = str("Model");
    model3_ast.data.model_node.name = str("Buffer");
    model3_ast.data.model_node.is_public = false;
    
    val field_names3: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names3, addr(model_arena), str("data"));
    model3_ast.data.model_node.field_names = field_names3;
    
    val field_types3: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types3, addr(model_arena), str("i32[100]"));
    model3_ast.data.model_node.field_types = field_types3;
    
    model3_ast.children = nil;
    val model3_code: string = generate_c(addr(model3_ast));
    assert str_contains_c(model3_code, "struct Buffer"), "Expected struct Buffer";
    assert str_contains_c(model3_code, "int32_t data[100]"), "Expected array field";
    
    println "\nTest 10: Model with pointer field";
    mut model4_ast: ASTNode;
    model4_ast.node_type = str("Model");
    model4_ast.data.model_node.name = str("Node");
    model4_ast.data.model_node.is_public = false;
    
    val field_names4: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_names4, addr(model_arena), str("value"));
    StringList.push(field_names4, addr(model_arena), str("next"));
    model4_ast.data.model_node.field_names = field_names4;
    
    val field_types4: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(field_types4, addr(model_arena), str("i32"));
    StringList.push(field_types4, addr(model_arena), str("ref Node"));
    model4_ast.data.model_node.field_types = field_types4;
    
    model4_ast.children = nil;
    val model4_code: string = generate_c(addr(model4_ast));
    assert str_contains_c(model4_code, "struct Node"), "Expected struct Node";
    assert str_contains_c(model4_code, "int32_t value"), "Expected value field";
    assert str_contains_c(model4_code, "Node* next"), "Expected pointer field";
    
    println "\nTest 11: Test helper functions";
    assert equals_c(map_axe_type_to_c(str("i32")), "int32_t"), "Expected i32 mapping";
    assert equals_c(map_axe_type_to_c(str("ref i64")), "int64_t*"), "Expected ref i64 mapping";
    assert equals_c(map_axe_type_to_c(str("mut f32")), "float"), "Expected mut f32 mapping";
    
    println "\nTest 12: Generate enum";
    mut enum_ast: ASTNode;
    enum_ast.node_type = str("Enum");
    enum_ast.data.enum_node.name = str("Color");
    
    val enum_values: ref StringList = StringList.create(addr(model_arena), 10);
    StringList.push(enum_values, addr(model_arena), str("Red"));
    StringList.push(enum_values, addr(model_arena), str("Green"));
    StringList.push(enum_values, addr(model_arena), str("Blue"));
    enum_ast.data.enum_node.values = enum_values;
    
    enum_ast.children = nil;
    val enum_code: string = generate_c(addr(enum_ast));
    assert str_contains_c(enum_code, "typedef enum"), "Expected typedef enum";
    assert str_contains_c(enum_code, "Color_Red"), "Expected Color_Red value";
    assert str_contains_c(enum_code, "Color_Green"), "Expected Color_Green value";
    assert str_contains_c(enum_code, "Color_Blue"), "Expected Color_Blue value";
    assert str_contains_c(enum_code, "} Color;"), "Expected } Color;";

    println "\nTest 15: List types tracking and mapping";

    val list_map_val: string = map_axe_type_to_c(str("i32[999]"));
    assert str_contains_c(list_map_val, "__list_int32_t"), "Expected list(i32) mapping to a __list name";

    val list_map_ref: string = map_axe_type_to_c(str("ref i32[999]"));
    assert str_contains_c(list_map_ref, "__list_int32_t"), "Expected ref list(i32) mapping to a __list name";

    mut found_int32: bool = false;
    if g_list_elements != nil {
        val lstref: ref StringList = g_list_elements;
        mut k: i32 = 0;
        loop {
            if k >= lstref*.len {
                break;
            }
            val s: string = StringList.get(lstref, k);
            if equals_c(s, "int32_t") {
                found_int32 = true;
                break;
            }
            k = k + 1;
        }
    }

    assert found_int32, "Expected int32_t to be tracked as a list element type";

    println "\nTest 13: MemberAccess assignment";
    mut member_assign_ast: ASTNode;
    member_assign_ast.node_type = str("MemberAccess");
    member_assign_ast.data.member_access.object_name = str("obj");
    member_assign_ast.data.member_access.member_name = str("field");
    member_assign_ast.data.member_access.value = str("42");
    val member_assign_code: string = generate_c(addr(member_assign_ast));
    assert str_contains_c(member_assign_code, "obj.field = 42;"), "Expected obj.field = 42;";

    println "\nTest 14: MemberAccess read";
    mut member_read_ast: ASTNode;
    member_read_ast.node_type = str("MemberAccess");
    member_read_ast.data.member_access.object_name = str("obj");
    member_read_ast.data.member_access.member_name = str("field");
    member_read_ast.data.member_access.value = str("");
    val member_read_code: string = generate_c(addr(member_read_ast));
    assert str_contains_c(member_read_code, "obj.field;"), "Expected obj.field; for read";
}
