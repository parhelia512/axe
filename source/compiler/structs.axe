/// Author: Navid Momtahen (C) 2025
/// License: GPL-3.0
/// 
/// Structures used in the Axe compiler

use std.string;
use std.io;
use std.maps;

use lexer (Token);

/// Macro definition modelure
pub model MacroDef {
    params: ref list(string);
    param_types: ref list(string);
    body: ref list(Token);
}

/// Parser context - holds state during parsing
pub model ParserContext {
    tokens: ref list(Token);
    pos: i32;
    is_axec: bool;
    check_entry_point: bool;
    current_module: string;
    current_scope: Scope;
    filename: string;
    in_test_block: bool;
    expecting_public: bool;
    extern_symbol: string;
    current_model: string;
}

/// Scope tracking for variable declarations
pub model Scope {
    variables: StringStringMap;
    parent: ref Scope;
}

/// AST Node - all node types combined with a union
pub model ASTNode {
    node_type: string;
    children: ref list(ASTNode);

    // Source line number for error reporting
    line: i32;
    
    // Source file name for error reporting
    source_file: string;
    
    // Union of all possible node-specific data
    // This allows each node to store only the data relevant to its type
    data: union {
        overload_node: model {
            is_public: bool;
            name: string;
            param_name: string;
            call_expr: string;
            type_names: ref list(string);
            target_functions: ref list(string);
        };
        
        declaration: model {
            name: string;
            is_mutable: bool;
            initializer: string;
            type_name: string;
            ref_depth: i32;
        };
        
        array_decl: model {
            name: string;
            is_mutable: bool;
            element_type: string;
            size: string;
            size2: string;
            initializer: ref list(string);
        };
        
        array_access: model {
            array_name: string;
            index: string;
            index2: string;
        };
        
        array_assign: model {
            array_name: string;
            index: string;
            index2: string;
            value: string;
        };
        
        array_literal: model {
            element_type: string;
            elements: ref list(string);
        };
        
        function: model {
            name: string;
            params: ref list(string);
            return_type: string;
            is_public: bool;
            tags: ref list(string);
            type_params: ref list(string);
            is_generic: bool;
            when_branch_types: ref list(string);
            when_branch_counts: ref list(i32);
            when_branch_starts: ref list(i32);
        };
        
        macro_node: model {
            name: string;
            params: ref list(string);
            param_types: ref list(string);
            body_tokens: ref list(Token);
            is_public: bool;
        };
        
        assert_node: model {
            condition: string;
            message: string;
        };
        
        if_node: model {
            condition: string;
            elif_branches: ref list(ASTNode);
            else_body: ref list(ASTNode);
        };
        
        println: model {
            messages: ref list(string);
            is_expressions: ref list(bool);
        };
        
        print: model {
            messages: ref list(string);
            is_expressions: ref list(bool);
        };
        
        assignment: model {
            variable: string;
            expression: string;
            operator: string;  // "=", "+=", "-="
        };
        
        func_call: model {
            function_name: string;
            args: ref list(string);
        };
        
        interpolated_str: model {
            parts: ref list(string);
            expressions: ref list(string);
        };
        
        for_loop: model {
            initialization: string;
            condition: string;
            increment: string;
            is_mutable: bool;
            var_name: string;
            var_type: string;
            init_value: string;
            is_parallel: bool;
            reduction_clauses: ref list(string);
        };
        
        for_in: model {
            var_name: string;
            array_name: string;
            array_size: string;
        };
        
        return_node: model {
            expression: string;
        };
        
        raw_c: model {
            code: string;
        };
        
        use_node: model {
            module_name: string;
            imports: ref list(string);
            import_all: bool;
        };
        
        model_node: model {
            name: string;
            is_public: bool;
            field_names: ref list(string);
            field_types: ref list(string);

            // Union field metadata (for fields declared as `field: union { ... }`).
            // For each union member, we store:
            //   - union_member_parent: the parent union field name
            //   - union_member_names/types: the member name and type
            union_member_parents: ref list(string);
            union_member_names: ref list(string);
            union_member_types: ref list(string);
        };
        
        enum_node: model {
            is_public: bool;
            name: string;
            values: ref list(string);
        };
        
        model_instantiation: model {
            model_name: string;
            variable_name: string;
            is_mutable: bool;
            field_names: ref list(string);
            field_values: ref list(string);
        };
        
        member_access: model {
            object_name: string;
            member_name: string;
            value: string;
        };
        
        external_import: model {
            header_file: string;
        };
        
        opaque_node: model {
            type_names: ref list(string);
        };
        
        foreign_node: model {
            type_names: ref list(string);
        };
        
        extern_node: model {
            function_name: string;
            params: ref list(string);
            return_type: string;
            symbol: string;
            is_public: bool;
        };
        
        unsafe_node: model {
            body: ref list(ASTNode);
        };

        defer_node: model {
            body: ref list(ASTNode);
        };

        switch_node: model {
            expression: string;
        };
        
        case_node: model {
            value: string;
            is_default: bool;
        };
        
        inc_dec: model {
            variable: string;
            is_increment: bool;
        };
        
        member_inc_dec: model {
            object_name: string;
            member_name: string;
            is_increment: bool;
        };
        
        platform_node: model {
            platform_name: string;
        };
        
        parallel_for: model {
            initialization: string;
            condition: string;
            increment: string;
            reduction_clauses: ref list(string);
        };
        
        parallel_local: model {
            private_vars: ref list(string);
            private_types: ref list(string);
            is_mutable: ref list(bool);
        };
        
        when_branch: model {
            type_params: ref list(string);      // e.g., ["T2", "T"]
            concrete_types: ref list(string);   // e.g., ["i32", "IntList"]
        };
        
        /// Simple nodes with no additional data (Loop, Break, Continue, Test, Program, Parallel, Single)
        /// These just use node_type and children
        empty: i32;
    };
}

test {

}
