/// Author: Navid Momtahen (C) 2026
/// License: GPL-3.0
/// 
/// LLVM IR backend renderer for Axe compiler.

use ../../gstate;
use ../../structs (ASTNode);
use std.lists     (StringList);
use std.string;
use std.io;
use std.maps;
use std.arena;

/// Global LLVM IR string builder
mut g_llvm_sb: StringBuilder;

/// Track LLVM basic block counter
mut g_block_counter: i32;

/// Track LLVM register counter  
mut g_register_counter: i32;

/// Track variable to register mappings
mut g_var_registers: StringStringMap;

/// Track variable types
mut g_var_types: StringStringMap;

/// Track function declarations
mut g_function_decls: StringBoolMap;

/// Track function name prefixes (original -> prefixed)
mut g_function_prefixes: StringStringMap;

/// Track overload mappings (function_name -> type -> target_function)
mut g_overload_mappings: StringStringMap;

/// Track model definitions (model_name -> field_info)
mut g_model_definitions: StringStringMap;

/// Track model field types (model_name.field_name -> type)
mut g_model_field_types: StringStringMap;

/// Track if LLVM renderer is initialized
mut g_llvm_initialized: bool = false;

/// Temporary storage for prefixes before initialization
mut g_temp_prefixes: list(string);

/// Track string constants counter
mut g_string_counter: i32;

/// Track string constants
mut g_string_constants: list(string);

/// Arena for LLVM renderer memory management
mut g_llvm_arena: Arena;

/// Initialize the LLVM renderer
pub def initialize_llvm_renderer() {
    g_llvm_arena = Arena.create(1024 * 1024);
    g_var_registers = deref(StringStringMap.create(addr(g_llvm_arena), 128));
    g_var_types = deref(StringStringMap.create(addr(g_llvm_arena), 128));
    g_function_decls = deref(StringBoolMap.create(addr(g_llvm_arena), 128));
    g_function_prefixes = deref(StringStringMap.create(addr(g_llvm_arena), 128));
    g_overload_mappings = deref(StringStringMap.create(addr(g_llvm_arena), 256));
    g_model_definitions = deref(StringStringMap.create(addr(g_llvm_arena), 128));
    g_model_field_types = deref(StringStringMap.create(addr(g_llvm_arena), 256));
    g_string_counter = 0;
    
    mut i: i32 = 0;
    loop {
        if i >= len(g_temp_prefixes) {
            break;
        }
        val pair: string = g_temp_prefixes.data[i];
        val colon_pos: i32 = find_char_from(pair, ':', cast[usize](0));
        if colon_pos > 0 {
            val original: string = substring_se(pair, 0, colon_pos);
            val prefixed: string = substring_se(pair, colon_pos + 1, cast[i32](str_len(pair)));
            StringStringMap.set(
                addr(g_function_prefixes),
                addr(g_llvm_arena),
                original,
                prefixed
            );
        }
        i++;
    }
    
    g_llvm_initialized = true;
}

/// Get next register name
def next_register(): string {
    val reg: string = concat(str("%"), i32_to_string(g_register_counter));
    g_register_counter++;
    return reg;
}

/// Get next block label
def next_block(): string {
    val block: string = concat(str("block"), i32_to_string(g_block_counter));
    g_block_counter++;
    return block;
}

/// Add a string constant to the global list
def add_string_constant(str_value: string) {
    append(g_string_constants, str_value);
    g_string_counter++;
}

/// Convert Axe type to LLVM type
def axe_type_to_llvm(axe_type: string): string {
    if equals_c(axe_type, "i32") {
        return str("i32");
    } elif equals_c(axe_type, "i64") {
        return str("i64");
    } elif equals_c(axe_type, "f32") {
        return str("float");
    } elif equals_c(axe_type, "f64") {
        return str("double");
    } elif equals_c(axe_type, "bool") {
        return str("i1");
    } elif equals_c(axe_type, "string") {
        return str("i8*");
    } elif StringStringMap.contains(addr(g_model_definitions), axe_type) {
        return concat(concat(str("%struct."), axe_type), str("*"));
    }
    return str("i32"); 
}

/// Register a function prefix mapping (original -> prefixed) for LLVM backend
pub def llvm_renderer_add_prefix(original: string, prefixed: string) {
    if g_llvm_initialized {
        StringStringMap.set(addr(g_function_prefixes), addr(g_llvm_arena), original, prefixed);
    } else {
        val pair: string = concat(concat(original, str(":")), prefixed);
        append(g_temp_prefixes, pair);
    }
}

/// Analyze AST to find imported functions and create prefix mappings
def analyze_imports_for_prefixes(ast: ref ASTNode) {
    if ast == nil {
        return;
    }
    
    val node_type: string = ast.node_type;
    
    if equals_c(node_type, "Function") {
        val func_name: string = ast.data.function.name;
        val double_underscore_pos: i32 = find_substr(func_name, str("__"));
        if double_underscore_pos > 0 {
            val original_name: string = substring_se(
                func_name,
                double_underscore_pos + 2,
                cast[i32](str_len(func_name))
            );
            StringStringMap.set(
                addr(g_function_prefixes),
                addr(g_llvm_arena),
                original_name,
                func_name
            );
        }
    }
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        val child_count: i32 = len(deref(children));
        mut i: i32 = 0;
        loop {
            if i >= child_count {
                break;
            }
            analyze_imports_for_prefixes(addr(children.data[i]));
            i++;
        }
    }
}

/// Generate LLVM IR for an AST node
pub def generate_llvm(ast: ref ASTNode): string {
    if ast == nil {
        return str("; Empty AST\n");
    }
    
    g_llvm_sb = StringBuilder.init(4096);
    g_block_counter = 0;
    g_register_counter = 1;
    
    val code: string = render_ast_node(ast);
    return code;
}

/// Render any AST node based on its type
def render_ast_node(ast: ref ASTNode): string {
    if ast == nil {
        return str("");
    }
    
    val node_type: string = ast.node_type;
    if str_len(node_type) == 0 {
        return str("");
    }
    
    if equals_c(node_type, "Program") {
        return render_program(ast);
    } elif equals_c(node_type, "Function") {
        return render_function(ast);
    } elif equals_c(node_type, "Return") {
        return render_return(ast);
    } elif equals_c(node_type, "Declaration") {
        return render_declaration(ast);
    } elif equals_c(node_type, "Assignment") {
        return render_assignment(ast);
    } elif equals_c(node_type, "FunctionCall") {
        return render_function_call(ast);
    } elif equals_c(node_type, "If") {
        return render_if(ast);
    } elif equals_c(node_type, "Loop") {
        return render_loop(ast);
    } elif equals_c(node_type, "Print") {
        return render_print(ast);
    } elif equals_c(node_type, "Overload") {
        return render_overload(ast);
    } elif equals_c(node_type, "Model") {
        return render_model(ast);
    } elif equals_c(node_type, "ModelInstantiation") {
        return render_model_instantiation(ast);
    } elif equals_c(node_type, "MemberAccess") {
        return render_member_access(ast);
    }
    
    return str("");
}

/// Render declaration node
def render_declaration(ast: ref ASTNode): string {
    val name: string = ast.data.declaration.name;
    val type_name: string = ast.data.declaration.type_name;
    val initializer: string = ast.data.declaration.initializer;
    val reg: string = next_register();

    StringStringMap.set(addr(g_var_registers), addr(g_llvm_arena), name, reg);
    StringStringMap.set(addr(g_var_types), addr(g_llvm_arena), name, type_name);
    
    mut sb: StringBuilder = StringBuilder.init(128);

    if StringStringMap.contains(addr(g_model_definitions), type_name) {
        StringBuilder.append(addr(sb), str("  "));
        StringBuilder.append(addr(sb), reg);
        StringBuilder.append(addr(sb), str(" = alloca %struct."));
        StringBuilder.append(addr(sb), type_name);
        StringBuilder.append(addr(sb), str("\n"));
        
        if str_len(initializer) > 0 and str_contains(initializer, str("{ }")) {
            val zero_reg: string = next_register();
            StringBuilder.append(addr(sb), str("  "));
            StringBuilder.append(addr(sb), zero_reg);
            StringBuilder.append(addr(sb), str(" = bitcast %struct."));
            StringBuilder.append(addr(sb), type_name);
            StringBuilder.append(addr(sb), str("* "));
            StringBuilder.append(addr(sb), reg);
            StringBuilder.append(addr(sb), str(" to i8*\n"));
            StringBuilder.append(addr(sb), str("  call void @llvm.memset.p0i8.i32(i8* "));
            StringBuilder.append(addr(sb), zero_reg);
            StringBuilder.append(addr(sb), str(", i8 0, i32 ptrtoint (%struct."));
            StringBuilder.append(addr(sb), type_name);
            StringBuilder.append(addr(sb), str("* getelementptr (%struct."));
            StringBuilder.append(addr(sb), type_name);
            StringBuilder.append(addr(sb), str(", %struct."));
            StringBuilder.append(addr(sb), type_name);
            StringBuilder.append(addr(sb), str("* null, i32 1) to i32), i1 false)\n"));
        }
    } else {
        StringBuilder.append(addr(sb), str("  "));
        StringBuilder.append(addr(sb), reg);
        StringBuilder.append(addr(sb), str(" = alloca i32\n"));
        
        if str_len(initializer) > 0 {
            StringBuilder.append(addr(sb), str("  store i32 "));
            StringBuilder.append(addr(sb), initializer);
            StringBuilder.append(addr(sb), str(", i32* "));
            StringBuilder.append(addr(sb), reg);
            StringBuilder.append(addr(sb), str("\n"));
        }
    }
    
    return StringBuilder.to_string(addr(sb));
}

/// Render assignment node
def render_assignment(ast: ref ASTNode): string {
    val variable: string = ast.data.assignment.variable;
    val expression: string = ast.data.assignment.expression;
    
    if !StringStringMap.contains(addr(g_var_registers), variable) {
        return str(""); 
    }
    
    val reg: string = StringStringMap.get(addr(g_var_registers), variable);
    mut sb: StringBuilder = StringBuilder.init(128);
    
    StringBuilder.append(addr(sb), str("  store i32 "));
    StringBuilder.append(addr(sb), expression);
    StringBuilder.append(addr(sb), str(", i32* "));
    StringBuilder.append(addr(sb), reg);
    StringBuilder.append(addr(sb), str("\n"));
    
    return StringBuilder.to_string(addr(sb));
}

/// Process interpolated string content
def process_interpolated_string_llvm(interp_content: string): string {
    mut parts: list(string);
    mut expressions: list(string);

    mut pos: i32 = 0;
    mut sb_part: StringBuilder = StringBuilder.init(str_len(interp_content) + 16);
    val content_len: i32 = cast[i32](str_len(interp_content));

    loop {
        if pos >= content_len {
            break;
        }

        val ch: char = get_char(interp_content, pos);

        if ch == '{' {
            if pos > 0 and get_char(interp_content, pos - 1) == '$' and sb_part.len > 0 {
                sb_part.len = sb_part.len - 1;
            }

            append(parts, StringBuilder.to_string(addr(sb_part)));
            StringBuilder.clear(addr(sb_part));

            val brace_start: i32 = pos + 1;
            mut brace_depth: i32 = 1;
            mut brace_end: i32 = brace_start;

            loop {
                if brace_end >= content_len or brace_depth == 0 {
                    break;
                }
                val cc: char = get_char(interp_content, brace_end);
                if cc == '{' {
                    brace_depth = brace_depth + 1;
                } elif cc == '}' {
                    brace_depth = brace_depth - 1;
                }
                brace_end = brace_end + 1;
            }

            val expr: string = strip(substring_se(interp_content, brace_start, brace_end - 1));
            append(expressions, expr);
            pos = brace_end;
            continue;
        }

        StringBuilder.append_char(addr(sb_part), ch);
        pos = pos + 1;
    }

    append(parts, StringBuilder.to_string(addr(sb_part)));
    StringBuilder.destroy(addr(sb_part));

    if len(expressions) == 0 {
        return interp_content;
    }

    // TODO: Render expression properly in string interpolations here.
    if len(expressions) > 0 {
        val expr: string = expressions.data[0];
        if StringStringMap.contains(addr(g_var_registers), expr) {
            val load_reg: string = next_register();
            mut sb: StringBuilder = StringBuilder.init(128);
            StringBuilder.append(addr(sb), load_reg);
            return StringBuilder.to_string(addr(sb));
        }
        return expr;
    }

    return str("0");
}

/// Check if a string contains interpolation markers
def has_interpolation_markers(s: string): bool {
    return has_prefix(s, str("__INTERPOLATED__")) and has_suffix(s, str("__INTERPOLATED__"));
}

/// Extract interpolation content from markers
def extract_interpolation_content(s: string): string {
    if !has_interpolation_markers(s) {
        return s;
    }
    val inner_len: i32 = str_len(s) - 32;
    if inner_len > 0 {
        return substring_se(s, 16, 16 + inner_len);
    }
    return str("");
}

/// Render function call node
def render_function_call(ast: ref ASTNode): string {
    val func_name_ast: string = ast.data.func_call.function_name;
    mut func_name: string = func_name_ast;
    val args: ref list(string) = ast.data.func_call.args;
    mut sb: StringBuilder = StringBuilder.init(256);
    
    if args != nil and len(deref(args)) > 0 {
        val first_arg: string = strip(args.data[0]);
        
        if StringStringMap.contains(addr(g_var_types), first_arg) {
            val arg_type: string = StringStringMap.get(addr(g_var_types), first_arg);
            val mapping_key: string = concat(concat(func_name_ast, str(":")), arg_type);
            
            if StringStringMap.contains(addr(g_overload_mappings), mapping_key) {
                val target_func: string = StringStringMap.get(
                    addr(g_overload_mappings),
                    mapping_key
                );
                func_name = target_func;
            }
        }
        
        val arg_list: list(string) = deref(args);
        mut i: i32 = 0;
        loop {
            if i >= len(arg_list) {
                break;
            }
            val arg: string = strip(arg_list.data[i]);
            
            if has_interpolation_markers(arg) {
                val interp_content: string = extract_interpolation_content(arg);
                val processed: string = process_interpolated_string_llvm(interp_content);
                arg_list.data[i] = processed;
            } elif find_char_from(arg, '.', cast[usize](0)) > 0 {
                val dot_pos: i32 = find_char_from(arg, '.', cast[usize](0));
                val object_name: string = substring_se(arg, 0, dot_pos);
                val member_name: string = substring_se(arg, dot_pos + 1, cast[i32](str_len(arg)));
                
                if StringStringMap.contains(addr(g_var_registers), object_name) {
                    val object_reg: string = StringStringMap.get(addr(g_var_registers), object_name);
                    val object_type: string = StringStringMap.get(addr(g_var_types), object_name);
                    val field_key: string = concat(concat(object_type, str(".")), member_name);
                    
                    if StringStringMap.contains(addr(g_model_field_types), field_key) {
                        val field_ptr_reg: string = next_register();
                        val load_reg: string = next_register();
                        
                        StringBuilder.append(addr(sb), str("  "));
                        StringBuilder.append(addr(sb), field_ptr_reg);
                        StringBuilder.append(addr(sb), str(" = getelementptr inbounds %struct."));
                        StringBuilder.append(addr(sb), object_type);
                        StringBuilder.append(addr(sb), str(", %struct."));
                        StringBuilder.append(addr(sb), object_type);
                        StringBuilder.append(addr(sb), str("* "));
                        StringBuilder.append(addr(sb), object_reg);
                        StringBuilder.append(addr(sb), str(", i32 0, i32 0\n"));
                        
                        StringBuilder.append(addr(sb), str("  "));
                        StringBuilder.append(addr(sb), load_reg);
                        StringBuilder.append(addr(sb), str(" = load i32, i32* "));
                        StringBuilder.append(addr(sb), field_ptr_reg);
                        StringBuilder.append(addr(sb), str("\n"));
                        
                        arg_list.data[i] = load_reg;
                    }
                }
            }
            
            if StringStringMap.contains(addr(g_var_registers), arg) {
                val reg: string = StringStringMap.get(addr(g_var_registers), arg);
                val load_reg: string = next_register();
                StringBuilder.append(addr(sb), str("  "));
                StringBuilder.append(addr(sb), load_reg);
                StringBuilder.append(addr(sb), str(" = load i32, i32* "));
                StringBuilder.append(addr(sb), reg);
                StringBuilder.append(addr(sb), str("\n"));
            }
            i++;
        }
    }
    
    if StringStringMap.contains(addr(g_function_prefixes), func_name) {
        func_name = StringStringMap.get(addr(g_function_prefixes), func_name);
    }
    
    StringBuilder.append(addr(sb), str("  call void @"));
    StringBuilder.append(addr(sb), func_name);
    StringBuilder.append(addr(sb), str("("));
    
    if args != nil and len(deref(args)) > 0 {
        val arg_list: list(string) = deref(args);
        mut i: i32 = 0;
        val load_reg_counter: i32 = g_register_counter - len(arg_list);
        loop {
            if i >= len(arg_list) {
                break;
            }
            if i > 0 {
                StringBuilder.append(addr(sb), str(", "));
            }
            val arg: string = strip(arg_list.data[i]);
            
            if StringStringMap.contains(addr(g_var_registers), arg) {
                val load_reg: string = concat(str("%"), i32_to_string(load_reg_counter + i));
                StringBuilder.append(addr(sb), str("i32 "));
                StringBuilder.append(addr(sb), load_reg);
            } else {
                StringBuilder.append(addr(sb), str("i32 "));
                StringBuilder.append(addr(sb), arg);
            }
            i++;
        }
    }
    
    StringBuilder.append(addr(sb), str(")\n"));
    
    return StringBuilder.to_string(addr(sb));
}

/// Render if statement
def render_if(ast: ref ASTNode): string {
    val condition: string = ast.data.if_node.condition;
    val then_label: string = next_block();
    val else_label: string = next_block();
    val end_label: string = next_block();
    mut sb: StringBuilder = StringBuilder.init(256);

    StringBuilder.append(addr(sb), str("  br i1 "));
    StringBuilder.append(addr(sb), condition);
    StringBuilder.append(addr(sb), str(", label %"));
    StringBuilder.append(addr(sb), then_label);
    StringBuilder.append(addr(sb), str(", label %"));
    StringBuilder.append(addr(sb), else_label);
    StringBuilder.append(addr(sb), str("\n\n"));
    StringBuilder.append(addr(sb), then_label);
    StringBuilder.append(addr(sb), str(":\n"));
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        val child_count: i32 = len(deref(children));
        mut i: i32 = 0;
        
        loop {
            if i >= child_count {
                break;
            }
            val child_code: string = render_ast_node(addr(children.data[i]));
            StringBuilder.append(addr(sb), child_code);
            i++;
        }
    }
    
    StringBuilder.append(addr(sb), str("  br label %"));
    StringBuilder.append(addr(sb), end_label);
    StringBuilder.append(addr(sb), str("\n\n"));
    StringBuilder.append(addr(sb), else_label);
    StringBuilder.append(addr(sb), str(":\n"));
    StringBuilder.append(addr(sb), str("  br label %"));
    StringBuilder.append(addr(sb), end_label);
    StringBuilder.append(addr(sb), str("\n\n"));
    StringBuilder.append(addr(sb), end_label);
    StringBuilder.append(addr(sb), str(":\n"));
    
    return StringBuilder.to_string(addr(sb));
}

/// Render loop node
def render_loop(ast: ref ASTNode): string {
    val loop_label: string = next_block();
    val body_label: string = next_block();
    val end_label: string = next_block();
    
    mut sb: StringBuilder = StringBuilder.init(256);
    StringBuilder.append(addr(sb), str("  br label %"));
    StringBuilder.append(addr(sb), loop_label);
    StringBuilder.append(addr(sb), str("\n\n"));
    StringBuilder.append(addr(sb), loop_label);
    StringBuilder.append(addr(sb), str(":\n"));
    StringBuilder.append(addr(sb), str("  br label %"));
    StringBuilder.append(addr(sb), body_label);
    StringBuilder.append(addr(sb), str("\n\n"));
    StringBuilder.append(addr(sb), body_label);
    StringBuilder.append(addr(sb), str(":\n"));
    
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        val child_count: i32 = len(deref(children));
        mut i: i32 = 0;
        
        loop {
            if i >= child_count {
                break;
            }
            val child_code: string = render_ast_node(addr(children.data[i]));
            StringBuilder.append(addr(sb), child_code);
            i++;
        }
    }
    
    StringBuilder.append(addr(sb), str("  br label %"));
    StringBuilder.append(addr(sb), loop_label);
    StringBuilder.append(addr(sb), str("\n\n"));
    StringBuilder.append(addr(sb), end_label);
    StringBuilder.append(addr(sb), str(":\n"));
    
    return StringBuilder.to_string(addr(sb));
}

/// Render program node
def render_program(ast: ref ASTNode): string {
    if ast.children == nil {
        return str("");
    }
    
    val children: ref list(ASTNode) = ast.children;
    val child_count: i32 = len(deref(children));
    mut i: i32 = 0;

    loop {
        if i >= child_count {
            break;
        }
        val child: ref ASTNode = addr(children.data[i]);
        analyze_imports_for_prefixes(child);
        i++;
    }
    
    i = 0;
    loop {
        if i >= child_count {
            break;
        }
        val child_code: string = render_ast_node(addr(children.data[i]));
        StringBuilder.append(addr(g_llvm_sb), child_code);
        i++;
    }
    
    mut final_sb: StringBuilder = StringBuilder.init(4096);
    
    if len(g_string_constants) > 0 {
        mut str_i: i32 = 0;
        loop {
            if str_i >= len(g_string_constants) {
                break;
            }
            StringBuilder.append(addr(final_sb), str("@.str"));
            StringBuilder.append(addr(final_sb), i32_to_string(str_i));
            StringBuilder.append(addr(final_sb), str(" = private unnamed_addr constant ["));
            StringBuilder.append(
                addr(final_sb),
                i32_to_string(str_len(g_string_constants.data[str_i]) + 1)
            );
            StringBuilder.append(addr(final_sb), str(" x i8] c\""));
            StringBuilder.append(addr(final_sb), g_string_constants.data[str_i]);
            StringBuilder.append(addr(final_sb), str("\\00\"\n"));
            str_i++;
        }
        StringBuilder.append(addr(final_sb), str("\n"));
    }
    
    StringBuilder.append(addr(final_sb), str("declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly, i8, i32, i1 immarg)\n"));
    
    if len(g_string_constants) > 0 {
        StringBuilder.append(addr(final_sb), str("declare i32 @puts(i8*)\n\n"));
    } else {
        StringBuilder.append(addr(final_sb), str("\n"));
    }
    
    StringBuilder.append(addr(final_sb), StringBuilder.to_string(addr(g_llvm_sb)));
    
    return StringBuilder.to_string(addr(final_sb));
}

/// Render function definition
def render_function(ast: ref ASTNode): string {
    val func_name: string = ast.data.function.name;
    val return_type: string = ast.data.function.return_type;
    val params: ref list(string) = ast.data.function.params;
    mut sb: StringBuilder = StringBuilder.init(512);
    
    StringBuilder.append(addr(sb), str("define "));
    if str_len(return_type) > 0 and equals_c(return_type, "void") {
        StringBuilder.append(addr(sb), str("void"));
    } else {
        StringBuilder.append(addr(sb), str("i32"));
    }
    StringBuilder.append(addr(sb), str(" @"));
    StringBuilder.append(addr(sb), func_name);
    StringBuilder.append(addr(sb), str("("));
    
    if params != nil and len(deref(params)) > 0 {
        val param_list: list(string) = deref(params);
        mut i: i32 = 0;
        loop {
            if i >= len(param_list) {
                break;
            }
            if i > 0 {
                StringBuilder.append(addr(sb), str(", "));
            }
            StringBuilder.append(addr(sb), str("i32"));
            i++;
        }
    }
    
    StringBuilder.append(addr(sb), str(") {\n"));
    StringBuilder.append(addr(sb), str("entry:\n"));
    
    mut has_return: bool = false;
    if ast.children != nil {
        val children: ref list(ASTNode) = ast.children;
        val child_count: i32 = len(deref(children));
        mut i: i32 = 0;
        
        loop {
            if i >= child_count {
                break;
            }
            val child: ref ASTNode = addr(children.data[i]);
            if equals_c(child.node_type, "Return") {
                has_return = true;
            }
            val child_code: string = render_ast_node(child);
            StringBuilder.append(addr(sb), child_code);
            i++;
        }
    }
    
    if !has_return {
        if str_len(return_type) > 0 and equals_c(return_type, "void") {
            StringBuilder.append(addr(sb), str("  ret void\n"));
        } else {
            StringBuilder.append(addr(sb), str("  ret i32 0\n"));
        }
    }
    
    StringBuilder.append(addr(sb), str("}\n\n"));
    return StringBuilder.to_string(addr(sb));
}

/// Render return statement
def render_return(ast: ref ASTNode): string {
    val expression: string = strip(ast.data.return_node.expression);
    
    mut sb: StringBuilder = StringBuilder.init(128);
    if str_len(expression) > 0 {
        if StringStringMap.contains(addr(g_var_registers), expression) {
            val reg: string = StringStringMap.get(addr(g_var_registers), expression);
            val load_reg: string = next_register();
            StringBuilder.append(addr(sb), str("  "));
            StringBuilder.append(addr(sb), load_reg);
            StringBuilder.append(addr(sb), str(" = load i32, i32* "));
            StringBuilder.append(addr(sb), reg);
            StringBuilder.append(addr(sb), str("\n"));
            StringBuilder.append(addr(sb), str("  ret i32 "));
            StringBuilder.append(addr(sb), load_reg);
            StringBuilder.append(addr(sb), str("\n"));
        } else {
            StringBuilder.append(addr(sb), str("  ret i32 "));
            StringBuilder.append(addr(sb), expression);
            StringBuilder.append(addr(sb), str("\n"));
        }
    } else {
        StringBuilder.append(addr(sb), str("  ret void\n"));
    }
    return StringBuilder.to_string(addr(sb));
}

/// Render print node (put statement)
def render_print(ast: ref ASTNode): string {
    val messages_ref: ref list(string) = ast.data.print.messages;
    val flags_ref: ref list(bool) = ast.data.print.is_expressions;

    if messages_ref == nil or flags_ref == nil {
        return str("");
    }

    val messages: list(string) = deref(messages_ref);
    val flags: list(bool) = deref(flags_ref);

    if len(messages) == 0 {
        return str("");
    }

    mut sb: StringBuilder = StringBuilder.init(256);
    
    if len(messages) == 1 and len(flags) == 1 and !flags.data[0] {
        val str_id: string = i32_to_string(g_string_counter);
        val call_reg: string = next_register();
        
        StringBuilder.append(addr(sb), str("  "));
        StringBuilder.append(addr(sb), call_reg);
        StringBuilder.append(addr(sb), str(" = call i32 @puts(i8* getelementptr inbounds (["));
        StringBuilder.append(addr(sb), i32_to_string(str_len(messages.data[0]) + 1));
        StringBuilder.append(addr(sb), str(" x i8], ["));
        StringBuilder.append(addr(sb), i32_to_string(str_len(messages.data[0]) + 1));
        StringBuilder.append(addr(sb), str(" x i8]* @.str"));
        StringBuilder.append(addr(sb), str_id);
        StringBuilder.append(addr(sb), str(", i32 0, i32 0))\n"));
        
        add_string_constant(messages.data[0]);
        
        return StringBuilder.to_string(addr(sb));
    }
    
    return StringBuilder.to_string(addr(sb));
}

/// Render overload node
def render_overload(ast: ref ASTNode): string {
    val name: string = ast.data.overload_node.name;
    val type_names_ref: ref list(string) = ast.data.overload_node.type_names;
    val targets_ref: ref list(string) = ast.data.overload_node.target_functions;

    if type_names_ref == nil or targets_ref == nil {
        return str("");
    }

    val type_names: list(string) = deref(type_names_ref);
    val targets: list(string) = deref(targets_ref);
    val count: i32 = len(type_names);
    
    if count == 0 or count != len(targets) {
        return str("");
    }

    mut i: i32 = 0;
    loop {
        if i >= count {
            break;
        }
        
        val type_name: string = type_names.data[i];
        val target_func: string = targets.data[i];
        val mapping_key: string = concat(concat(name, str(":")), type_name);

        StringStringMap.set(
            addr(g_overload_mappings),
            addr(g_llvm_arena),
            mapping_key,
            target_func
        );

        i++;
    }

    return str("");
}

/// Render model definition
def render_model(ast: ref ASTNode): string {
    val model_name: string = ast.data.model_node.name;
    val field_names_ref: ref list(string) = ast.data.model_node.field_names;
    val field_types_ref: ref list(string) = ast.data.model_node.field_types;

    if field_names_ref == nil or field_types_ref == nil {
        return str("");
    }

    val field_names: list(string) = deref(field_names_ref);
    val field_types: list(string) = deref(field_types_ref);
    val field_count: i32 = len(field_names);

    if field_count != len(field_types) {
        return str("");
    }

    StringStringMap.set(
        addr(g_model_definitions),
        addr(g_llvm_arena),
        model_name,
        str("defined")
    );

    mut i: i32 = 0;
    loop {
        if i >= field_count {
            break;
        }
        val field_key: string = concat(concat(model_name, str(".")), field_names.data[i]);
        StringStringMap.set(
            addr(g_model_field_types),
            addr(g_llvm_arena),
            field_key,
            field_types.data[i]
        );
        i++;
    }

    mut sb: StringBuilder = StringBuilder.init(256);
    StringBuilder.append(addr(sb), str("%struct."));
    StringBuilder.append(addr(sb), model_name);
    StringBuilder.append(addr(sb), str(" = type { "));

    i = 0;
    loop {
        if i >= field_count {
            break;
        }
        if i > 0 {
            StringBuilder.append(addr(sb), str(", "));
        }
        val llvm_type: string = axe_type_to_llvm(field_types.data[i]);
        StringBuilder.append(addr(sb), llvm_type);
        i++;
    }

    StringBuilder.append(addr(sb), str(" }\n"));
    return StringBuilder.to_string(addr(sb));
}

/// Render model instantiation
def render_model_instantiation(ast: ref ASTNode): string {
    val model_name: string = ast.data.model_instantiation.model_name;
    val var_name: string = ast.data.model_instantiation.variable_name;
    val field_names_ref: ref list(string) = ast.data.model_instantiation.field_names;
    val field_values_ref: ref list(string) = ast.data.model_instantiation.field_values;

    val alloc_reg: string = next_register();

    StringStringMap.set(addr(g_var_registers), addr(g_llvm_arena), var_name, alloc_reg);
    StringStringMap.set(addr(g_var_types), addr(g_llvm_arena), var_name, model_name);

    mut sb: StringBuilder = StringBuilder.init(512);

    StringBuilder.append(addr(sb), str("  "));
    StringBuilder.append(addr(sb), alloc_reg);
    StringBuilder.append(addr(sb), str(" = alloca %struct."));
    StringBuilder.append(addr(sb), model_name);
    StringBuilder.append(addr(sb), str("\n"));

    if field_names_ref == nil or field_values_ref == nil {
        val zero_reg: string = next_register();
        StringBuilder.append(addr(sb), str("  "));
        StringBuilder.append(addr(sb), zero_reg);
        StringBuilder.append(addr(sb), str(" = bitcast %struct."));
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append(addr(sb), str("* "));
        StringBuilder.append(addr(sb), alloc_reg);
        StringBuilder.append(addr(sb), str(" to i8*\n"));
        StringBuilder.append(addr(sb), str("  call void @llvm.memset.p0i8.i32(i8* "));
        StringBuilder.append(addr(sb), zero_reg);
        StringBuilder.append(addr(sb), str(", i8 0, i32 ptrtoint (%struct."));
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append(addr(sb), str("* getelementptr (%struct."));
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append(addr(sb), str(", %struct."));
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append(addr(sb), str("* null, i32 1) to i32), i1 false)\n"));
        return StringBuilder.to_string(addr(sb));
    }

    val field_names: list(string) = deref(field_names_ref);
    val field_values: list(string) = deref(field_values_ref);
    val field_count: i32 = len(field_names);

    if field_count != len(field_values) {
        return str("");
    }

    mut i: i32 = 0;
    loop {
        if i >= field_count {
            break;
        }
        val field_ptr_reg: string = next_register();
        val field_value: string = field_values.data[i];

        StringBuilder.append(addr(sb), str("  "));
        StringBuilder.append(addr(sb), field_ptr_reg);
        StringBuilder.append(addr(sb), str(" = getelementptr inbounds %struct."));
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append(addr(sb), str(", %struct."));
        StringBuilder.append(addr(sb), model_name);
        StringBuilder.append(addr(sb), str("* "));
        StringBuilder.append(addr(sb), alloc_reg);
        StringBuilder.append(addr(sb), str(", i32 0, i32 "));
        StringBuilder.append(addr(sb), i32_to_string(i));
        StringBuilder.append(addr(sb), str("\n"));

        val field_key: string = concat(concat(model_name, str(".")), field_names.data[i]);
        val field_type: string = StringStringMap.get(addr(g_model_field_types), field_key);
        val llvm_type: string = axe_type_to_llvm(field_type);

        StringBuilder.append(addr(sb), str("  store "));
        StringBuilder.append(addr(sb), llvm_type);
        StringBuilder.append(addr(sb), str(" "));
        StringBuilder.append(addr(sb), field_value);
        StringBuilder.append(addr(sb), str(", "));
        StringBuilder.append(addr(sb), llvm_type);
        StringBuilder.append(addr(sb), str("* "));
        StringBuilder.append(addr(sb), field_ptr_reg);
        StringBuilder.append(addr(sb), str("\n"));

        i++;
    }

    return StringBuilder.to_string(addr(sb));
}

/// Render member access
def render_member_access(ast: ref ASTNode): string {
    val object_name: string = ast.data.member_access.object_name;
    val member_name: string = ast.data.member_access.member_name;
    val value: string = ast.data.member_access.value;

    if !StringStringMap.contains(addr(g_var_registers), object_name) {
        return str("");
    }

    val object_reg: string = StringStringMap.get(addr(g_var_registers), object_name);
    val object_type: string = StringStringMap.get(addr(g_var_types), object_name);
    val field_key: string = concat(concat(object_type, str(".")), member_name);

    if !StringStringMap.contains(addr(g_model_field_types), field_key) {
        return str("");
    }

    val field_type: string = StringStringMap.get(addr(g_model_field_types), field_key);
    val llvm_type: string = axe_type_to_llvm(field_type);
    val field_ptr_reg: string = next_register();
    mut sb: StringBuilder = StringBuilder.init(256);

    StringBuilder.append(addr(sb), str("  "));
    StringBuilder.append(addr(sb), field_ptr_reg);
    StringBuilder.append(addr(sb), str(" = getelementptr inbounds %struct."));
    StringBuilder.append(addr(sb), object_type);
    StringBuilder.append(addr(sb), str(", %struct."));
    StringBuilder.append(addr(sb), object_type);
    StringBuilder.append(addr(sb), str("* "));
    StringBuilder.append(addr(sb), object_reg);
    StringBuilder.append(addr(sb), str(", i32 0, i32 0\n"));

    if str_len(value) > 0 {
        StringBuilder.append(addr(sb), str("  store "));
        StringBuilder.append(addr(sb), llvm_type);
        StringBuilder.append(addr(sb), str(" "));
        StringBuilder.append(addr(sb), value);
        StringBuilder.append(addr(sb), str(", "));
        StringBuilder.append(addr(sb), llvm_type);
        StringBuilder.append(addr(sb), str("* "));
        StringBuilder.append(addr(sb), field_ptr_reg);
        StringBuilder.append(addr(sb), str("\n"));
    } else {
        val load_reg: string = next_register();
        StringBuilder.append(addr(sb), str("  "));
        StringBuilder.append(addr(sb), load_reg);
        StringBuilder.append(addr(sb), str(" = load "));
        StringBuilder.append(addr(sb), llvm_type);
        StringBuilder.append(addr(sb), str(", "));
        StringBuilder.append(addr(sb), llvm_type);
        StringBuilder.append(addr(sb), str("* "));
        StringBuilder.append(addr(sb), field_ptr_reg);
        StringBuilder.append(addr(sb), str("\n"));
    }

    return StringBuilder.to_string(addr(sb));
}
