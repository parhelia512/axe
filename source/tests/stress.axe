use stdlib/arena (
    Arena,
    arena_create,
    arena_destroy,
    arena_alloc
);

model Cell {
    temperature: int;
}

def init_grid(grid: Cell[rows][cols], rows: int, cols: int, arena: Arena) {
    mut val r: int = 0;
    loop {
        if r >= rows {
            break;
        }

        mut val c: int = 0;
        loop {
            if c >= cols {
                break;
            }

            // Allocate a Cell from the arena (not strictly necessary here but for stress-testing arena)
            val cell_ptr: long = arena_alloc(ref_of(arena), sizeof(Cell));

            grid[r][c].temperature = 20 + (r * c) mod 50;

            c = c + 1;
        }

        r = r + 1;
    }
}

def diffuse(grid: Cell[rows][cols], new_grid: Cell[rows][cols], rows: int, cols: int) {
    mut val r: int = 0;
    loop {
        if r >= rows {
            break;
        }

        mut val c: int = 0;
        loop {
            if c >= cols {
                break;
            }

            mut val sum: int = grid[r][c].temperature;
            mut val count: int = 1;

            if r > 0 {
                sum = sum + grid[r-1][c].temperature;
                count = count + 1;
            }

            if r < rows - 1 {
                sum = sum + grid[r+1][c].temperature;
                count = count + 1;
            }

            if c > 0 {
                sum = sum + grid[r][c-1].temperature;
                count = count + 1;
            }

            if c < cols - 1 {
                sum = sum + grid[r][c+1].temperature;
                count = count + 1;
            }

            new_grid[r][c].temperature = sum / count;

            c = c + 1;
        }

        r = r + 1;
    }
}

def print_grid(grid: Cell[rows][cols], rows: int, cols: int) {
    mut val r: int = 0;
    loop {
        if r >= rows {
            break;
        }

        mut val c: int = 0;
        loop {
            if c >= cols {
                break;
            }

            print grid[r][c].temperature;
            print " ";
            c = c + 1;
        }

        println "";
        r = r + 1;
    }
}

main {
    val rows: int = 10;
    val cols: int = 10;
    mut val arena: Arena = arena_create(65536);

    // Create two grids for double-buffering
    mut val grid: Cell[10][10];
    mut val new_grid: Cell[10][10];

    init_grid(grid, rows, cols, arena);

    println "Initial grid:";
    print_grid(grid, rows, cols);
    println "";

    mut val step: int = 0;
    loop {
        if step >= 5 {
            break;
        }

        diffuse(grid, new_grid, rows, cols);

        // Swap grids
        mut val temp: Cell[10][10] = grid;
        grid = new_grid;
        new_grid = temp;

        println "Step ";
        print step;
        println ":";
        print_grid(grid, rows, cols);
        println "";

        step = step + 1;
    }

    arena_destroy(ref_of(arena));
    println "Arena destroyed - memory freed!";
}
