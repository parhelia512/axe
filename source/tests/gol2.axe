/// Prints the grid
def print_grid(grid: i32[height][width], width: i32, height: i32) {
    for mut val y = 0; y < height; y++ {
        for mut val x = 0; x < width; x++ {
            if grid[y][x] == 1 {
                print "■";
            } else {
                print "□";
            }
        }
        println "";
    }
}

/// Counts the live neighbors
def count_neighbors(grid: i32[height][width], x: i32, y: i32, width: i32, height: i32): i32 {
    mut val count: i32 = 0;

    for mut val dy = -1; dy <= 1; dy++ {
        for mut val dx = -1; dx <= 1; dx++ {

            // Skip self
            if dx == 0 and dy == 0 {
                continue;
            }

            val nx: i32 = x + dx;
            val ny: i32 = y + dy;

            // Bounds check
            if nx >= 0 and nx < width and ny >= 0 and ny < height {
                count = count + grid[ny][nx];
            }
        }
    }

    return count;
}

/// Compute next generation
def next_generation(grid: i32[height][width], new_grid: i32[height][width], width: i32, height: i32) {
    for mut val y = 0; y < height; y++ {
        for mut val x = 0; x < width; x++ {

            val neighbors = count_neighbors(grid, x, y, width, height);

            if grid[y][x] == 1 {
                if neighbors == 2 or neighbors == 3 {
                    new_grid[y][x] = 1;
                } else {
                    new_grid[y][x] = 0;
                }
            } else {
                if neighbors == 3 {
                    new_grid[y][x] = 1;
                } else {
                    new_grid[y][x] = 0;
                }
            }
        }
    }
}

/// Copy new_grid → grid
def copy_grid(src: i32[height][width], dst: i32[height][width], width: i32, height: i32) {
    for mut val y = 0; y < height; y++ {
        for mut val x = 0; x < width; x++ {
            dst[y][x] = src[y][x];
        }
    }
}

main {
    val width: i32 = 20;
    val height: i32 = 20;

    // Allocate two static grids
    mut val grid: i32[20][20];
    mut val new_grid: i32[20][20];

    // Zero initialize
    for mut val y = 0; y < height; y++ {
        for mut val x = 0; x < width; x++ {
            grid[y][x] = 0;
            new_grid[y][x] = 0;
        }
    }

    // Add classic glider
    grid[1][2] = 1;
    grid[2][3] = 1;
    grid[3][1] = 1;
    grid[3][2] = 1;
    grid[3][3] = 1;

    println "Conway's Game of Life (pure Axe)";
    println "";

    for mut val gen = 0; gen < 20; gen++ {
        print "Generation ";
        println gen;
        println "";

        print_grid(grid, width, height);

        next_generation(grid, new_grid, width, height);
        copy_grid(new_grid, grid, width, height);

        println "";
        println "---";
        println "";
    }
}
