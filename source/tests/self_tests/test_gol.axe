use std.io;

/// Convert 2D coordinate (x, y) into 1D index
def idx(x: i32, y: i32, width: i32): i32 {
    return y * width + x;
}

/// Print the grid (1-D list)
def print_grid(grid: ref list(i32), width: i32, height: i32) {
    for mut y = 0; y < height; y++ {
        for mut x = 0; x < width; x++ {
            if grid.data[idx(x, y, width)] == 1 {
                print "■";
            } else {
                print "□";
            }
        }
        println "";
    }
}

/// Count live neighbors around (x, y)
def count_neighbors(grid: ref list(i32), x: i32, y: i32, width: i32, height: i32): i32 {
    mut count: i32 = 0;

    for mut dy = -1; dy <= 1; dy++ {
        for mut dx = -1; dx <= 1; dx++ {
            if dx == 0 and dy == 0 {
                continue;
            }

            val nx = x + dx;
            val ny = y + dy;

            if nx >= 0 and nx < width and ny >= 0 and ny < height {
                if grid.data[idx(nx, ny, width)] == 1 {
                    count++;
                }
            }
        }
    }

    return count;
}

/// Compute next generation
def next_generation(grid: ref list(i32), new_grid: ref list(i32), width: i32, height: i32) {
    for mut y = 0; y < height; y++ {
        for mut x = 0; x < width; x++ {

            val i = idx(x, y, width);
            val neighbors = count_neighbors(grid, x, y, width, height);

            if grid.data[i] == 1 {
                if neighbors == 2 or neighbors == 3 {
                    new_grid.data[i] = 1;
                } else {
                    new_grid.data[i] = 0;
                }
            } else {
                if neighbors == 3 {
                    new_grid.data[i] = 1;
                } else {
                    new_grid.data[i] = 0;
                }
            }
        }
    }
}

/// Copy new_grid back into grid
def copy_grid(src: ref list(i32), dst: ref list(i32), size: i32) {
    for mut i = 0; i < size; i++ {
        dst.data[i] = src.data[i];
    }
}

def main() {
    val width: i32 = 20;
    val height: i32 = 20;
    val size: i32 = width * height;

    mut grid: list(i32);
    mut new_grid: list(i32);

    for mut i = 0; i < size; i++ {
        append(grid, 0);
        append(new_grid, 0);
    }

    grid.data[idx(2,1,width)] = 1;
    grid.data[idx(3,2,width)] = 1;
    grid.data[idx(1,3,width)] = 1;
    grid.data[idx(2,3,width)] = 1;
    grid.data[idx(3,3,width)] = 1;

    println "Conway's Game of Life\n";

    for mut gen = 0; gen < 20; gen++ {
        print "Generation ";
        println gen;
        println "";

        print_grid(addr(grid), width, height);

        next_generation(addr(grid), addr(new_grid), width, height);
        copy_grid(addr(new_grid), addr(grid), size);

        println "\n---\n";
    }
}